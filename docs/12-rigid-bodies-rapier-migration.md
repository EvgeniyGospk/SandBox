# Миграция твёрдых тел на Rapier2D + векторный рендер + grid‑маска (Particula / SandBox)

> Цель документа: описать **качественный** (не обязательно быстрый) план перехода от текущих «пиксельных» rigid bodies к системе твёрдых тел с:
>
> - **аналитическими коллайдерами** (идеальный круг/квадрат, rotation, friction, restitution)
> - **векторным отображением** (идеальная геометрия на экране)
> - **интеграцией с клеточной песочной средой** через grid‑маску непроницаемости
>
> Документ ориентирован на текущую архитектуру репозитория:
>
> - `apps/web` — UI + worker + рендер (OffscreenCanvas)
> - `packages/engine` — Rust/WASM симуляция
>
> Важный инвариант: **частицы остаются клеточными** (grid), а твёрдые тела становятся **непрерывными** (continuous). Связь обеспечивается через мост (grid‑маска).

---

## 0) Короткое резюме (что мы получим)

### Что станет лучше

- **Идеальные формы**: круг реально круг, квадрат реально квадрат, поворот без «лесенки».
- **Нормальная физика тел**:
  - стабильные контакты
  - friction / restitution
  - вращение (torque)
  - взаимодействие тел между собой
- **Непроницаемость** для песка/жидкости: частицы не могут попасть внутрь фигуры.

### Цена

- Появляется **двойная модель мира**:
  - мир частиц (grid)
  - мир rigid bodies (Rapier)
- Нужен **мост** между ними: grid‑маска, очистка внутренности, (опционально) силы от среды, а также (важно) представление части grid‑мира как **terrain** для Rapier.

---

## 1) Термины

- **Grid / клеточный мир** — текущая симуляция частиц в `Grid` (`packages/engine`).
- **Rigid body (твёрдое тело)** — объект с pos/rot/vel, который двигается как единое целое.
- **Collider / Shape** — геометрия тела (circle, box, polygon).
- **Mask / Occupancy mask** — слой на grid, помечающий клетки, которые «заняты» твёрдым телом.
- **Непроницаемость** — частицы не могут оказаться внутри тела; любые попытки движения в область тела запрещены.

---

## 2) Текущее состояние в коде (что есть сейчас)

### 2.1 Текущая подсистема rigid bodies

Сейчас rigid bodies уже существуют, но они реализованы как **набор пикселей**:

- `packages/engine/src/systems/rigid_body/body.rs`

  - `RigidBody { pos, velocity, angle, angular_vel, pixels: Vec<BodyPixel>, ... }`
  - `new_rect(...)` и `new_circle(...)` генерируют **пиксельную маску** тела
- `packages/engine/src/systems/rigid_body_system/system.rs`

  - `RigidBodySystem::update`:
    - очищает тело из грида (`clear_body`)
    - применяет гравитацию
    - делает очень простое разрешение коллизии по осям через `collides_at`
    - снова растрирует тело в grid (`rasterize_body`)
- `packages/engine/src/systems/rigid_body_system/rasterize.rs`

  - `rasterize_body` пишет SOLID‑пиксели в `Grid`, но **не перезаписывает** существующие частицы
- `packages/engine/src/systems/rigid_body_system/collision.rs`

  - `collides_at` = проверка «не пусто ли» в grid

Также:

- `packages/engine/src/simulation/step/step.rs` уже вызывает `world.rigid_bodies.update(...)` **до** физики частиц.

### 2.2 Главные ограничения текущего подхода

- Геометрия тела фактически **клеточная** → окружность «лесенкой».
- Вращение подготовлено в структуре, но **практически не используется** (угол не интегрируется стабильно).
- Непроницаемость и «вытеснение среды» не гарантированы:
  - `rasterize_body` пропускает занятые клетки → тело может стать «дырявым».

Вывод: текущая подсистема — хороший временный прототип, но она не соответствует цели «идеальные векторные тела».

---

## 3) Требования к новой системе

### 3.1 Функциональные требования

- **Векторный внешний вид**:

  - circle/box должны выглядеть идеально гладко
  - поддержка rotation
- **Непроницаемость**:

  - частицы не могут попасть внутрь тела
  - если при спавне или телепорте частицы оказались внутри — движок обязан исправить состояние
- **Взаимодействие тел**:

  - тело‑тело: стабильные коллизии
  - тело‑мир: коллизии с границами мира
- **Интеграция с песком**:

  - частицы должны «упираться» в тело как в стенку
  - (опционально, следующий уровень качества) среда должна создавать сопротивление/давление, влияя на тело

### 3.2 Нефункциональные требования

- Работает в `wasm32-unknown-unknown`.
- Производительность: маска не должна убивать FPS на больших мирах.
- Память: маска должна быть компактной.
- Интеграция с chunk‑системой (у вас есть `ChunkGrid`, `mark_dirty` и т.п.).

---

## 4) Почему Rapier2D (и что она реально даст)

Rapier2D — физдвижок на Rust (подходит для WASM). Он даст из коробки:

- **аналитические формы** (circle/box/poly)
- **контактный solver** (устойчивые столкновения)
- **вращение** и torque от контактов
- **friction / restitution**
- **броадфаза** и нормальная производительность на N тел
- **joints** (если потом захочется)

Важно понимать:

- Rapier решает задачу **rigid ↔ rigid**.
- Задача **rigid ↔ sand (grid)** — это ваша собственная логика (мост).

---

## 5) Архитектура целевого решения

### 5.1 Общая схема

```
Particles (Grid)  <---- bridge: occupancy mask ---->  RigidBodies (Rapier)
       |                                 ^
       |                                 |
       |                    terrain colliders from Grid SOLID
       |
       | render (pixels)                                 render (vector)
       v                                                     v
OffscreenCanvas (worker): WebGL2 / Canvas2D + overlay vector bodies
```

### 5.2 Где будет жить Rapier

В `packages/engine`:

- новый модуль, условно: `simulation/rigid_rapier/` или `systems/rigid_rapier/`
- там хранится:
  - `RigidBodySet`
  - `ColliderSet`
  - `PhysicsPipeline`
  - `IslandManager`, `BroadPhase`, `NarrowPhase`, `CCDSolver`
  - `IntegrationParameters`

### 5.3 Где будет жить маска

В `WorldCore` рядом с `grid`:

- `rigid_mask: RigidMaskGrid`

Это отдельный слой, **не элементы** и не частицы.

**Зачем отдельный слой?**

- Не нужно «рисовать тело частицами», чтобы оно работало как препятствие.
- Не ломаем механику элементов (типы, цвет, температура).
- Можно хранить **id тела** на клетке (для debug/feedback), а можно только бит занятости.

---

## 6) Ключевое решение №1: единицы измерения (scale)

Чтобы стыковать Rapier и grid, нужна договорённость:

- **1 клетка grid = 1 world‑unit** (условные «метры»)
- позиции Rapier — `f32` в этих units
- центр клетки `(x + 0.5, y + 0.5)`

Плюсы:

- мост проще
- маска строится естественно

Минусы:

- Rapier любит реальные физические масштабы, но для игры это нормально.

---

## 7) Ключевое решение №2: фиксированный timestep

Для качества и стабильности:

- симуляция тел в Rapier должна идти **фиксированным шагом dt**
- если у вас есть variable speed — делайте «несколько substeps»

Рекомендация:

- `dt = 1.0 / 60.0`
- при ускорении симуляции — `n_steps_per_frame`

---

## 8) Bridge: grid‑маска непроницаемости

### 8.1 Цель маски

Сделать так, чтобы любая логика перемещения частиц могла сказать:

- «клетка занята твёрдым телом?»

Если да — движение частицы туда запрещено.

### 8.2 Формат данных

Минимальный вариант:

- `occupied: Vec<u8>` длины `width*height` (0/1)

Качественный/удобный вариант:

- `owner: Vec<u32>` длины `width*height`
  - `0` = свободно
  - `id` = тело, которое занимает клетку

Почему `owner` круче:

- можно дебажить
- можно делать «силы от среды» (зная, какое тело контактирует)

### 8.3 Когда перестраивать маску

Наивно: каждый кадр полностью.

Качественно:

- маска обновляется **инкрементально**:
  - у каждого тела хранится список клеток, которые оно занимало в прошлый кадр
  - сначала очищаем старые клетки
  - затем заполняем новые

Это концептуально похоже на текущий `prev_world_coords` в пиксельной системе.

### 8.4 Как заполнить клетки для circle

Для каждой клетки в AABB круга:

- берём центр клетки `p = (x+0.5, y+0.5)`
- проверяем `distance(p, center) <= radius`

Опционально для более «плотной» непроницаемости:

- использовать `<= radius + margin` где `margin ~ 0.25..0.5` клеток
- это помогает избежать «просачивания» из-за дискретности

### 8.5 Как заполнить клетки для box (с rotation)

- берём точку центра клетки
- переводим в локальные координаты бокса (обратный поворот)
- проверяем `abs(local.x) <= half_w` и `abs(local.y) <= half_h`

### 8.6 Важный нюанс: «водонепроницаемость» в grid

У вас уже есть анти‑corner‑cutting логика для порошка (`is_corner_blocked_by_solids`), чтобы частицы не просачивались через диагональные углы.

Если маска будет считаться как SOLID, **эта защита станет ещё важнее**.

Рекомендация:

- в `is_solid_cell(...)` учитывать `rigid_mask` как SOLID.

---

## 9) Синхронизация: порядок шагов симуляции

Сейчас порядок примерно такой (см. `step.rs`):

1) `rigid_bodies.update(...)`
2) `process_physics()` для частиц
3) behaviors

Целевой порядок (рекомендуемый):

1) **Rapier step** (движим тела)
2) **Update rigid_mask** под новые позиции тел
3) **Particle physics step** (частицы используют rigid_mask как препятствие)
4) behaviors
5) (опционально) **feedback**: сила/drag от среды на тела

Почему сначала Rapier:

- частицы «видят» новое положение тел сразу
- маска соответствует актуальному положению

---

## 10) Rigid bodies collide with grid solids (terrain)

Этот раздел — ключ к механике вида:

- **ты строишь горку из камня** (камень — это статичные SOLID‑частицы в grid)
- **спавнишь шарик/круг**
- шарик **падает**, **контактирует** с поверхностью и дальше:
  - **скользит** или **катится** вниз по наклону
  - может получать **угловую скорость** (как колесо), а не просто «съезжать как мыло»

Чтобы это работало, Rapier должен «видеть» поверхность, сформированную частицами в grid.

### 10.1 Почему одной grid‑маски недостаточно

`rigid_mask` решает задачу **particles → rigid** (частицы не проникают в твёрдое тело).

Но для механик «шарик катится по горке из камня/песка» нужно ещё **rigid → particles/terrain**:

- твёрдое тело в Rapier должно сталкиваться с препятствиями, которые живут в grid

Если этого не сделать, то:

- шарик может **пролетать сквозь** каменную горку (Rapier о ней не знает)

### 10.2 Два подхода (оба валидны)

- **Подход A (рекомендуемый): terrain‑colliders из grid по чанкам**
  - из клеточных SOLID строим набор **статических** коллайдеров в Rapier
  - Rapier сам даёт нормали, трение, torque → естественное катание
- **Подход B: кастомный solver body↔grid (контакт из SDF/penetration)**
  - Rapier остаётся для body↔body
  - а контакт body↔grid считается вашей процедурой (sweep + коррекция + friction/rolling)
  - потенциально можно сделать очень «идеально» под песочницу, но это существенно сложнее

Для цели «качественно и максимально физично» стоит начать с **A**, а **B** держать как запас/усилитель, если клеточная геометрия будет давать неприятные артефакты.

### 10.3 Что именно превращаем в terrain

Есть важное ограничение производительности:

- нельзя делать коллайдер на **каждую песчинку** каждый кадр

Поэтому terrain строится только из той части мира, которая ведёт себя как «поверхность»:

- **База (must‑have):** клетки с `CAT_SOLID` (камень/металл/статичные твёрдые элементы)
- **Опционально для “шарик катится по куче песка”:** клетки “песка/порошка”, которые находятся в **sleeping chunks** (т.е. куча стабилизировалась)
  - это даёт эффект: куча песка становится временным terrain, пока она не потревожена
  - как только куча меняется → chunk просыпается → terrain пересобирается

Примечание: если хочется “продавливание песка шариком” — это уже следующий уровень (нужно либо разрушать/двигать песок от контакта, либо вводить правила деформации). Но для старта механики катания достаточно временного terrain из sleeping‑кучи.

### 10.4 Построение terrain‑colliders по чанкам (pipeline)

Цель: из grid‑данных чанка сделать **набор сегментов/полилинию** в Rapier.

Рекомендуемый путь (качество + стабильность):

- **1) Вход:** chunk (например 32×32) + правило “является terrain?”
- **2) Извлечение поверхности:** строим контур границы «terrain vs empty/non‑terrain»
  - лучший алгоритм: **marching squares** (2D)
- **3) Упрощение (optional, но полезно):** polyline simplification (например, RDP)
- **4) Генерация коллайдера:**
  - Rapier 2D поддерживает **polyline/segments** (цепочку отрезков)
  - либо набор отдельных `segment` коллайдеров
- **5) Регистрация в Rapier как static/fixed:**
  - один “fixed rigid body” на chunk или на весь мир, но разные collider handles

Критически важно для отсутствия «дыр»:

- при сборке по чанкам нужно учитывать **границы чанков**
  - самый простой приём: строить контур не по 32×32, а по (32+2)×(32+2) с “рамкой” соседей
  - либо гарантировать overlap/стыковку сегментов на границе

### 10.5 Обновление terrain‑colliders (incremental, по dirty chunks)

Идея такая же, как у вас сейчас для частиц:

- если игрок рисует камень или физика изменила terrain‑клетки → chunk становится dirty
- только тогда пересобираем коллайдер

Нужно завести отдельный флаг/маркер:

- `terrain_dirty` (возможно прямо на уровне `ChunkGrid`, или отдельной структуры)

Схема обновления:

- на шаге симуляции:
  - после апдейта частиц (когда мир стабилизировался на текущем кадре)
  - перебрать dirty чанки
  - удалить старые colliders (по handle)
  - собрать новые colliders

Важно:

- rebuild terrain должен быть **детерминированным** (одинаковый порядок чанков)
- лучше делать rebuild **до** шага Rapier следующего кадра (или в начале кадра), чтобы Rapier не работал с устаревшей геометрией

### 10.6 Материалы поверхности: трение и катание (rolling)

Чтобы шарик реально «катился как колесо», нужны:

- достаточный `friction` между телом и поверхностью
- корректная `restitution` (обычно небольшая, чтобы не прыгало бесконечно)

Практическая рекомендация для ощущения:

- `restitution` маленький (например 0.0..0.2)

### 10.7 Альтернатива: кастомный body↔grid collision (когда нужно «идеально гладко»)

Terrain‑colliders из клеток неизбежно дают «ступеньки» на диагоналях, потому что исходная геометрия дискретна.

Если это будет мешать, есть усиление качества:

- считать **SDF** (signed distance field) для terrain (по чанкам)
- при контакте тела делать:
  - penetration depth
  - normal = grad(SDF)
  - корректировать позицию/скорость и добавлять трение

Это дороже по реализации, но даёт ощущение «гладкой горки» даже если горка собрана из клеток.

### 10.8 Режим 2 (максимально физично): rigid bodies деформируют песок (rigid → particles)

Этот режим отличается от terrain‑подхода принципиально:

- в режиме terrain шарик «едет по поверхности», но поверхность для него становится (временно) жёсткой
- в режиме deformations шарик **взаимодействует с песком как с сыпучей средой**:
  - толкает песчинки
  - проминает кучу
  - разбрасывает материал

Важно: это не означает, что песок перестаёт быть частицами. Наоборот — песок остаётся частицами, а мы добавляем мост **rigid → particles**.

#### 10.8.1 Инварианты (что должно быть правдой всегда)

- частицы не могут оказаться «внутри» аналитической формы тела (непроницаемость)
- количество частиц не должно «само по себе» расти/падать (кроме явных правил игры)
- шаг симуляции должен оставаться детерминированным (одинаковый порядок обработки)

#### 10.8.2 Базовая стратегия (практичная): push‑out + импульс

Идея:

- после шага Rapier берём область AABB тела и находим клетки, которые оказались «внутри» формы
- для каждой такой клетки, если там есть частица, мы пытаемся **вытолкнуть** её наружу:
  - поиск ближайшей свободной клетки вдоль нормали
  - либо BFS/волна в ограниченном радиусе
- параллельно считаем суммарную реакцию среды и прикладываем к телу:
  - линейный импульс (сопротивление/drag)
  - угловой импульс (torque), чтобы шарик мог раскручиваться от контакта

Это создаёт эффект «шарик вдавливает и раздвигает песок», при этом реализация остаётся управляемой по стоимости.

#### 10.8.3 Стратегия «контактный слой» (качество выше)

Вместо того, чтобы работать со всем объёмом пересечения, можно выделить **слой контакта**:

- берём клетки, которые лежат на границе тела (примерно кольцо толщиной 1 клетка)
- только для них делаем push‑out и считаем силы

Это обычно дешевле и стабильнее.

#### 10.8.4 Песок как среда: “веса” и материалы

Чтобы поведение было “физичным”, удобно завести параметры:

- коэффициент “сопротивления” для категорий (песок > жидкость > газ)
- коэффициент “залипания/трения” (влияет на кручение)

#### 10.8.5 Ограничения производительности (обязательно)

- лимит количества операций за кадр (budget)
- лимит радиуса поиска для push‑out
- fallback: если budget исчерпан — тело получает больше сопротивления и меньше продавливает

Иначе при больших телах и плотных кучах можно легко получить O(N²).

---

## 11) Спавн/удаление: непроницаемость и очистка внутренности

Когда создаётся rigid body:

- нельзя допускать, чтобы внутри тела уже были частицы

Стратегии:

### 11.1 Жёсткая (строгая)

- если хотя бы одна клетка внутри формы занята частицей → спавн запрещён

### 11.2 Игровая (обычно лучше)

- при спавне очищаем все частицы внутри формы
- корректируем `particle_count`
- помечаем соответствующие chunk’и dirty

Для цели «качественно и максимально физично» стоит начать с **11.1**, а **11.2** держать как запас/усилитель, если UX спавна будет неудовлетворительным.

Выбранная стратегия для этого проекта: **строгая (11.1)**.

Это означает, что UX спавна нужно довести до “идеально понятно пользователю”:

- показать превью/подсветку области, где спавн невозможен
- выдавать причину отказа (например: «внутри формы есть частицы»)

Удаление тела:

- очищаем маску (клетки становятся свободны)
- частицы могут сразу начать заполнять пространство

---

## 15) План миграции (по фазам)

Ниже план «качество важнее скорости». Каждый шаг должен оставлять проект в рабочем состоянии.

### Фаза 0 — Подготовка

- Добавить зависимости Rapier2D в `packages/engine/Cargo.toml`.
- Убедиться, что собирается в WASM.
- Создать модуль‑обёртку `rigid_rapier`.

**Критерии готовности:**

- CI/локальная сборка проходит
- WASM артефакты генерятся

### Фаза 1 — Новая модель твёрдых тел (данные)

- Ввести структуру описания тела на уровне игры:

  - `BodyId`
  - `Shape { Circle{r}, Box{hx,hy} }`
  - `Material { density?, friction, restitution }`
- Сделать маппинг `BodyId -> Rapier handle`.

**Критерии:**

- можно создать/удалить тело без привязки к grid

### Фаза 2 — Встроить step Rapier в `WorldCore.step`

- В `packages/engine/src/simulation/step/step.rs` заменить вызов `rigid_bodies.update` на:
  - `rapier_world.step(dt)`

Пока без маски.

**Критерии:**

- тела двигаются и сталкиваются друг с другом (внутренний тест)

### Фаза 3 — Реализовать `RigidMaskGrid`

- Добавить слой маски в `WorldCore`.
- Реализовать:

  - `clear_body_cells(id)`
  - `fill_body_cells(id, shape, transform)`
- Инкрементальное обновление.

**Критерии:**

- маска корректно обновляется при движении тел

### Фаза 4 — Подключить маску к физике частиц

- В местах, где частицы проверяют «solid ли клетка», добавить:

  - `rigid_mask.is_occupied(x,y)` как SOLID
- Протестировать corner‑cases:

  - диагональные щели
  - узкие проходы
  - вращение бокса

**Критерии:**

- частицы не проникают внутрь

### Фаза 5 — Terrain colliders: rigid bodies сталкиваются с SOLID поверхностью из grid

- Ввести понятие **terrain‑клеток** (минимум: `CAT_SOLID`, опционально: “sleeping sand surface”).
- Реализовать сборку коллайдеров по чанкам:

  - marching squares → polyline/segments
  - контроль стыков на границах чанков
  - инкрементальное обновление по `terrain_dirty`
- Встроить обновление terrain‑colliders в шаг симуляции в детерминированном порядке.

**Критерии:**

- круг/квадрат в Rapier падает на «горку из камня» (grid SOLID) и **не проваливается**
- при достаточном friction круг **катится** по наклонной, получая `angular velocity`

### Фаза 6 — Спавн/удаление с непроницаемостью

- При `spawn_rigid_*`:

  - строго проверить область спавна: если внутри формы есть частицы → отказ
  - создать Rapier body
  - построить `rigid_mask`
- При удалении:

  - очищаем маску (клетки становятся свободны)
  - частицы могут сразу начать заполнять пространство
  - удалить body/colliders из Rapier

**Критерии:**

- непроницаемость выполняется всегда

### Фаза 7 — Экспорт состояния тел и векторный рендер

- Сделать экспорт `RigidBodiesRenderBuffer`.
- На стороне worker нарисовать overlay.

**Критерии:**

- визуально круг/квадрат идеальные
- нет «лесенки»

### Фаза 8 — Полировка и расширения

- friction/restitution материалами
- (опционально) drag/pressure
- snapshot/save/load

### Фаза 9 — Deformations: rigid bodies деформируют песок (rigid → particles)

- Реализовать мост rigid → particles (push‑out / контактный слой / budget).
- Обеспечить непроницаемость: частицы не остаются внутри формы после шага.
- Добавить обратную связь на тело (impulse/torque) от вытеснения песка.
- Интегрировать с chunk‑системой:
 
   - все перемещения частиц помечают чанки dirty
   - terrain‑colliders пересобираются только после стабилизации/по флагам

 **Критерии:**

 - шарик реально продавливает и раздвигает кучу песка
 - шарик теряет скорость (drag) и может раскручиваться от контакта
 - производительность контролируема через budget
 
 ---

## 16) Риски и митигация

### Риск: «идеальная геометрия» vs клеточная среда

Даже при идеальном рендере, граница взаимодействия с песком всё равно дискретна (клетки). Это нормально для sand‑игры.

**Митигация:**

- подобрать `margin` в маске
- улучшить corner‑blocking

### Риск: недетерминизм Rapier

Физдвижки могут отличаться по поведению на разных платформах.

**Митигация:**

- фиксированный dt
- единый порядок обновления
- single‑threaded physics

### Риск: производительность маски

Если тел много и они большие, заполнение AABB станет дорогим.

**Митигация:**

- лимит на количество/размер тел
- инкрементальные обновления
- обновлять маску только если transform изменился больше epsilon

### Риск: производительность и стабильность terrain‑colliders

- слишком частые rebuild’ы коллайдеров при активной “сыпучей” сцене
- «зубчатые» диагонали (ступеньки) → дрожание/подпрыгивания
- «щели» на стыке чанков → проскакивание

 **Митигация:**
 
 - строить terrain только из `CAT_SOLID` + (опционально) sleeping‑порошка
 - rebuild только по `terrain_dirty` чанкам
 - стыковать чанки через overlap (рамка соседей) или общий контур
 - при необходимости добавить SDF‑подход как “quality upgrade”

### Риск: производительность режима deformations (rigid → particles)
 
 - push‑out может стать очень дорогим на плотных кучах
 - возможны «насосы» (частицы туда‑сюда), если порядок/правила нефиксированы
 
 **Митигация:**
 
 - budget на количество операций за кадр
 - детерминированный порядок обхода клеток
 - ограниченный радиус поиска + fallback (drag вместо продавливания)
 - отдельный режим debug: подсветка “вытолкнутых” частиц
 
---

## 17) Тест‑план (чтобы «суперкачественно»)

### Юнит‑тесты (Rust)

- `point_in_circle` / `point_in_rotated_box`
- корректность fill/clear маски
- инвариант: после шага нет частиц внутри occupied клеток

### Интеграционные тесты

- круг падает на песок и не проваливается
- круг падает на **наклонную поверхность из камня** и катится вниз (не только скользит)
- квадрат падает на наклон и корректно стабилизируется (без дрожания)
- куча песка в sleeping‑состоянии становится временным terrain: шарик может по ней катиться
- режим deformations: шарик продавливает кучу песка и разбрасывает материал
- режим deformations: при большом количестве песка система остаётся стабильной (budget не даёт взорвать кадр)
- бокc вращается и не пропускает частицы
- много тел в куче (стэкинг)

### Визуальные тесты

- режим debug: подсветка occupied клеток
- режим debug: отрисовка коллайдера

### Перф‑тесты

- измерение времени построения маски
- измерение времени сборки terrain‑коллайдеров на dirty чанки
- измерение времени/количества операций push‑out в режиме deformations (budget)
- worst‑case: большой box, быстро вращается

---

## 18) Как это соотносится с текущими файлами

Ключевые точки интеграции в текущем коде:

- `packages/engine/src/simulation/mod.rs`

  - `WorldCore` — добавить `rapier_world` + `rigid_mask`
- `packages/engine/src/simulation/step/step.rs`

  - порядок: Rapier step → mask update → particle physics
- `packages/engine/src/systems/rigid_body_system/*`

  - текущая пиксельная система станет legacy / будет удалена после миграции
- `apps/web/src/features/simulation/worker/*`

  - добавить overlay‑рендер тел (вектор)

---

## 19) Рекомендуемый минимальный MVP внутри «полного выигрыша»

Чтобы не утонуть, но двигаться к цели:

 1) Rapier тела + маска непроницаемости
 2) terrain‑colliders из `CAT_SOLID` по чанкам
 3) экспорт transforms → worker
 4) простой Canvas2D overlay
 5) потом WebGL2 SDF overlay
 6) потом силы от среды
 7) потом деформация песка rigid bodies (rigid → particles)

---

## 20) Итог

Переход на **Rapier2D + векторный рендер + grid‑маску** в вашем проекте **реалистичен** и архитектурно хорошо ложится на существующий мир частиц.

Ключевой принцип: **не пытаться сделать весь песок «коллайдерами Rapier»** (это дорого), а вместо этого:

- держать песок в grid
- держать тела в Rapier
- связывать их через occupancy mask и аккуратную очистку/инварианты
- terrain‑коллайдеры строить только для тех частей grid‑мира, которые реально являются «поверхностью» (минимум: `CAT_SOLID`, опционально: sleeping‑кучи)
