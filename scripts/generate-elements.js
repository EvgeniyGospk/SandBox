#!/usr/bin/env node
/**
 * Phase 4: Code Generation Pipeline
 * 
 * Reads definitions/elements.json and generates:
 * - packages/engine/src/generated_elements.rs (Rust)
 * - apps/web/src/lib/engine/generated_elements.ts (TypeScript)
 * 
 * Usage:
 *   node scripts/generate-elements.js
 *   npm run codegen
 */

const fs = require('fs');
const path = require('path');

// Paths
const ROOT = path.resolve(__dirname, '..');
const DEFINITIONS_PATH = path.join(ROOT, 'definitions', 'elements.json');
const RUST_OUTPUT = path.join(ROOT, 'packages', 'engine', 'src', 'generated_elements.rs');
const TS_OUTPUT = path.join(ROOT, 'apps', 'web', 'src', 'lib', 'engine', 'generated_elements.ts');

// Load definitions
console.log('ðŸ“– Reading definitions from:', DEFINITIONS_PATH);
const definitions = JSON.parse(fs.readFileSync(DEFINITIONS_PATH, 'utf8'));

const { categories, elements } = definitions;

// ============================================================================
// HELPERS
// ============================================================================

/**
 * Convert a number to Rust f32 literal (always with .0 suffix)
 */
function toRustFloat(value) {
  if (typeof value !== 'number') return String(value);
  // If it's already a float (has decimal), return as-is
  if (String(value).includes('.')) return String(value);
  // Add .0 for integers to make them f32
  return `${value}.0`;
}

// ============================================================================
// RUST CODE GENERATION
// ============================================================================

function generateRust() {
  const lines = [];
  
  lines.push(`//! Generated Element Definitions - DO NOT EDIT MANUALLY!`);
  lines.push(`//!`);
  lines.push(`//! This file is auto-generated by scripts/generate-elements.js`);
  lines.push(`//! Source: definitions/elements.json`);
  lines.push(`//!`);
  lines.push(`//! To add a new element: edit definitions/elements.json and run 'npm run codegen'`);
  lines.push(``);
  lines.push(`use wasm_bindgen::prelude::*;`);
  lines.push(``);
  lines.push(`/// Element ID as u8 for compact storage`);
  lines.push(`pub type ElementId = u8;`);
  lines.push(``);
  
  // Element constants
  lines.push(`// ============================================================================`);
  lines.push(`// ELEMENT CONSTANTS`);
  lines.push(`// ============================================================================`);
  lines.push(``);
  
  for (const el of elements) {
    lines.push(`pub const ${el.rustName}: ElementId = ${el.id};`);
  }
  lines.push(`pub const ELEMENT_COUNT: usize = ${elements.length};`);
  lines.push(``);
  
  // Category constants
  lines.push(`// ============================================================================`);
  lines.push(`// CATEGORY CONSTANTS`);
  lines.push(`// ============================================================================`);
  lines.push(``);
  lines.push(`pub type CategoryId = u8;`);
  
  for (const cat of categories) {
    lines.push(`pub const ${cat.rustName}: CategoryId = ${cat.id};`);
  }
  lines.push(``);
  
  // ElementProps struct
  lines.push(`// ============================================================================`);
  lines.push(`// ELEMENT PROPERTIES`);
  lines.push(`// ============================================================================`);
  lines.push(``);
  lines.push(`/// Element properties struct`);
  lines.push(`#[derive(Clone, Copy)]`);
  lines.push(`pub struct ElementProps {`);
  lines.push(`    pub color: u32,`);
  lines.push(`    pub density: f32,`);
  lines.push(`    pub category: CategoryId,`);
  lines.push(`    pub dispersion: u8,`);
  lines.push(`    pub lifetime: u16,`);
  lines.push(`    pub default_temp: f32,`);
  lines.push(`    pub heat_conductivity: u8,`);
  lines.push(`    pub flammable: bool,`);
  lines.push(`    pub conductive: bool,`);
  lines.push(`}`);
  lines.push(``);
  
  // Element data array
  lines.push(`/// Static element data - indexed by ElementId`);
  lines.push(`pub static ELEMENT_DATA: [ElementProps; ELEMENT_COUNT] = [`);
  
  for (const el of elements) {
    const catConst = categories.find(c => c.name === el.category)?.rustName || 'CAT_SOLID';
    const density = el.density === 'Infinity' ? 'f32::INFINITY' : toRustFloat(el.density);
    const defaultTemp = toRustFloat(el.defaultTemp);
    
    lines.push(`    // ${el.id}: ${el.name.charAt(0).toUpperCase() + el.name.slice(1)}`);
    lines.push(`    ElementProps {`);
    lines.push(`        color: ${el.color},`);
    lines.push(`        density: ${density},`);
    lines.push(`        category: ${catConst},`);
    lines.push(`        dispersion: ${el.dispersion},`);
    lines.push(`        lifetime: ${el.lifetime},`);
    lines.push(`        default_temp: ${defaultTemp},`);
    lines.push(`        heat_conductivity: ${el.heatConductivity},`);
    lines.push(`        flammable: ${el.flammable},`);
    lines.push(`        conductive: ${el.conductive},`);
    lines.push(`    },`);
  }
  
  lines.push(`];`);
  lines.push(``);
  
  // Helper functions
  lines.push(`/// Get element properties by ID`);
  lines.push(`#[inline]`);
  lines.push(`pub fn get_props(id: ElementId) -> &'static ElementProps {`);
  lines.push(`    &ELEMENT_DATA[id as usize]`);
  lines.push(`}`);
  lines.push(``);
  
  // Color with variation function
  lines.push(`/// Get color with variation - EXACT TypeScript algorithm`);
  lines.push(`/// Returns ABGR format for direct copy to Canvas ImageData`);
  lines.push(`pub fn get_color_with_variation(id: ElementId, seed: u8) -> u32 {`);
  lines.push(`    let base = ELEMENT_DATA[id as usize].color;`);
  lines.push(`    let i = (seed & 31) as i32;`);
  lines.push(`    let variation = (i - 16) * 2;`);
  lines.push(`    `);
  lines.push(`    let a = (base >> 24) & 0xFF;`);
  lines.push(`    let r = (((base >> 16) & 0xFF) as i32 + variation).clamp(0, 255) as u32;`);
  lines.push(`    let g = (((base >> 8) & 0xFF) as i32 + variation).clamp(0, 255) as u32;`);
  lines.push(`    let b = ((base & 0xFF) as i32 + variation).clamp(0, 255) as u32;`);
  lines.push(`    `);
  lines.push(`    (a << 24) | (b << 16) | (g << 8) | r`);
  lines.push(`}`);
  lines.push(``);
  
  // ElementType enum for JS compatibility
  lines.push(`// ============================================================================`);
  lines.push(`// ELEMENT TYPE ENUM (for JS compatibility)`);
  lines.push(`// ============================================================================`);
  lines.push(``);
  lines.push(`#[wasm_bindgen]`);
  lines.push(`#[repr(u8)]`);
  lines.push(`#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]`);
  lines.push(`pub enum ElementType {`);
  
  for (const el of elements) {
    const enumName = el.name.charAt(0).toUpperCase() + el.name.slice(1);
    lines.push(`    ${enumName} = ${el.id},`);
  }
  
  lines.push(`}`);
  lines.push(``);
  lines.push(`impl ElementType {`);
  lines.push(`    pub fn to_id(self) -> ElementId {`);
  lines.push(`        self as ElementId`);
  lines.push(`    }`);
  lines.push(`    `);
  lines.push(`    pub fn props(self) -> &'static ElementProps {`);
  lines.push(`        get_props(self as ElementId)`);
  lines.push(`    }`);
  lines.push(`}`);
  lines.push(``);
  
  return lines.join('\n');
}

// ============================================================================
// TYPESCRIPT CODE GENERATION
// ============================================================================

function generateTypeScript() {
  const lines = [];
  
  lines.push(`/**`);
  lines.push(` * Generated Element Definitions - DO NOT EDIT MANUALLY!`);
  lines.push(` *`);
  lines.push(` * This file is auto-generated by scripts/generate-elements.js`);
  lines.push(` * Source: definitions/elements.json`);
  lines.push(` *`);
  lines.push(` * To add a new element: edit definitions/elements.json and run 'npm run codegen'`);
  lines.push(` */`);
  lines.push(``);
  
  // Element ID constants
  lines.push(`// ============================================================================`);
  lines.push(`// ELEMENT ID CONSTANTS`);
  lines.push(`// ============================================================================`);
  lines.push(``);
  
  for (const el of elements) {
    lines.push(`export const ${el.rustName} = ${el.id}`);
  }
  lines.push(`export const ELEMENT_COUNT = ${elements.length}`);
  lines.push(``);
  
  // Category constants
  lines.push(`// ============================================================================`);
  lines.push(`// CATEGORY CONSTANTS`);
  lines.push(`// ============================================================================`);
  lines.push(``);
  
  for (const cat of categories) {
    lines.push(`export const ${cat.rustName} = ${cat.id}`);
  }
  lines.push(``);
  
  // Type definitions
  lines.push(`// ============================================================================`);
  lines.push(`// TYPE DEFINITIONS`);
  lines.push(`// ============================================================================`);
  lines.push(``);
  lines.push(`export type ElementId = number`);
  lines.push(`export type CategoryId = number`);
  lines.push(``);
  
  // ElementType union
  const elementNames = elements.map(e => `'${e.name}'`).join(' | ');
  lines.push(`export type ElementType = ${elementNames}`);
  lines.push(``);
  
  // CategoryType union
  const categoryNames = categories.map(c => `'${c.name}'`).join(' | ');
  lines.push(`export type CategoryType = ${categoryNames}`);
  lines.push(``);
  
  // Name to ID mapping
  lines.push(`// ============================================================================`);
  lines.push(`// MAPPINGS`);
  lines.push(`// ============================================================================`);
  lines.push(``);
  lines.push(`export const ELEMENT_NAME_TO_ID: Record<ElementType, ElementId> = {`);
  for (const el of elements) {
    lines.push(`  ${el.name}: ${el.rustName},`);
  }
  lines.push(`}`);
  lines.push(``);
  
  // ID to name array
  lines.push(`export const ELEMENT_ID_TO_NAME: ElementType[] = [`);
  for (const el of elements) {
    lines.push(`  '${el.name}',`);
  }
  lines.push(`]`);
  lines.push(``);
  
  // Category name to ID
  lines.push(`export const CATEGORY_NAME_TO_ID: Record<CategoryType, CategoryId> = {`);
  for (const cat of categories) {
    lines.push(`  ${cat.name}: ${cat.rustName},`);
  }
  lines.push(`}`);
  lines.push(``);
  
  // Element properties interface
  lines.push(`// ============================================================================`);
  lines.push(`// ELEMENT PROPERTIES`);
  lines.push(`// ============================================================================`);
  lines.push(``);
  lines.push(`export interface ElementProps {`);
  lines.push(`  id: ElementId`);
  lines.push(`  name: ElementType`);
  lines.push(`  category: CategoryId`);
  lines.push(`  color: number`);
  lines.push(`  density: number`);
  lines.push(`  dispersion: number`);
  lines.push(`  lifetime: number`);
  lines.push(`  defaultTemp: number`);
  lines.push(`  heatConductivity: number`);
  lines.push(`  flammable: boolean`);
  lines.push(`  conductive: boolean`);
  lines.push(`  hidden?: boolean`);
  lines.push(`}`);
  lines.push(``);
  
  // Element data array
  lines.push(`export const ELEMENT_DATA: ElementProps[] = [`);
  
  for (const el of elements) {
    const catConst = categories.find(c => c.name === el.category)?.rustName || 'CAT_SOLID';
    const density = el.density === 'Infinity' ? 'Infinity' : el.density;
    const hiddenStr = el.hidden ? `, hidden: true` : '';
    
    lines.push(`  {`);
    lines.push(`    id: ${el.rustName},`);
    lines.push(`    name: '${el.name}',`);
    lines.push(`    category: ${catConst},`);
    lines.push(`    color: ${el.color},`);
    lines.push(`    density: ${density},`);
    lines.push(`    dispersion: ${el.dispersion},`);
    lines.push(`    lifetime: ${el.lifetime},`);
    lines.push(`    defaultTemp: ${el.defaultTemp},`);
    lines.push(`    heatConductivity: ${el.heatConductivity},`);
    lines.push(`    flammable: ${el.flammable},`);
    lines.push(`    conductive: ${el.conductive}${hiddenStr},`);
    lines.push(`  },`);
  }
  
  lines.push(`]`);
  lines.push(``);
  
  // UI helper - get visible elements for the palette
  lines.push(`// ============================================================================`);
  lines.push(`// UI HELPERS`);
  lines.push(`// ============================================================================`);
  lines.push(``);
  lines.push(`/** Get elements visible in the UI palette (excludes 'empty') */`);
  lines.push(`export const VISIBLE_ELEMENTS = ELEMENT_DATA.filter(e => !e.hidden)`);
  lines.push(``);
  lines.push(`/** Get elements by category for UI grouping */`);
  lines.push(`export function getElementsByCategory(category: CategoryType): ElementProps[] {`);
  lines.push(`  const catId = CATEGORY_NAME_TO_ID[category]`);
  lines.push(`  return ELEMENT_DATA.filter(e => e.category === catId && !e.hidden)`);
  lines.push(`}`);
  lines.push(``);
  
  return lines.join('\n');
}

// ============================================================================
// MAIN
// ============================================================================

function main() {
  console.log(`\nðŸ”§ Phase 4: Code Generation Pipeline\n`);
  console.log(`   Source: ${DEFINITIONS_PATH}`);
  console.log(`   Elements: ${elements.length}`);
  console.log(`   Categories: ${categories.length}\n`);
  
  // Generate Rust
  console.log('ðŸ¦€ Generating Rust code...');
  const rustCode = generateRust();
  fs.writeFileSync(RUST_OUTPUT, rustCode);
  console.log(`   â†’ ${RUST_OUTPUT}`);
  
  // Generate TypeScript
  console.log('ðŸ“˜ Generating TypeScript code...');
  const tsCode = generateTypeScript();
  fs.writeFileSync(TS_OUTPUT, tsCode);
  console.log(`   â†’ ${TS_OUTPUT}`);
  
  console.log('\nâœ… Code generation complete!\n');
  console.log('   To add a new element:');
  console.log('   1. Edit definitions/elements.json');
  console.log('   2. Run: npm run codegen');
  console.log('   3. Done! No manual code changes needed.\n');
}

main();
