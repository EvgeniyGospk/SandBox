--- File: apps/web/package.json ---

{
  "name": "@particula/web",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "preview": "vite preview",
    "lint": "eslint ."
  },
  "dependencies": {
    "@tailwindcss/vite": "^4.1.17",
    "clsx": "latest",
    "framer-motion": "latest",
    "lucide-react": "latest",
    "react": "latest",
    "react-dom": "latest",
    "tailwind-merge": "latest",
    "zustand": "latest"
  },
  "devDependencies": {
    "@eslint/js": "latest",
    "@types/node": "^24.10.1",
    "@types/react": "latest",
    "@types/react-dom": "latest",
    "@vitejs/plugin-react": "latest",
    "autoprefixer": "latest",
    "eslint": "latest",
    "eslint-plugin-react-hooks": "latest",
    "eslint-plugin-react-refresh": "latest",
    "globals": "latest",
    "postcss": "latest",
    "tailwindcss": "latest",
    "typescript": "latest",
    "typescript-eslint": "latest",
    "vite": "latest",
    "vitest": "^4.0.14"
  }
}

--- End of File: apps/web/package.json ---


--- File: apps/web/public/wasm/package.json ---

{
  "name": "particula-engine",
  "type": "module",
  "collaborators": [
    "Particula Team"
  ],
  "description": "Physics engine for Particula sandbox simulation",
  "version": "0.1.0",
  "files": [
    "particula_engine_bg.wasm",
    "particula_engine.js",
    "particula_engine.d.ts"
  ],
  "main": "particula_engine.js",
  "types": "particula_engine.d.ts",
  "sideEffects": [
    "./snippets/*"
  ]
}

--- End of File: apps/web/public/wasm/package.json ---


--- File: apps/web/src/App.tsx ---

import { useEffect, useState } from 'react'
import { Canvas } from '@/components/Canvas'
import { LeftPanel } from '@/components/panels/LeftPanel'
import { TopToolbar } from '@/components/panels/TopToolbar'
import { BottomBar } from '@/components/panels/BottomBar'
import { RightPanel } from '@/components/panels/RightPanel'

function App() {
  const [isEngineReady, setIsEngineReady] = useState(false)

  useEffect(() => {
    // TODO: Initialize WASM engine here
    // For now, just mark as ready
    setIsEngineReady(true)
  }, [])

  if (!isEngineReady) {
    return (
      <div className="flex items-center justify-center h-screen bg-[#0D0D0D]">
        <div className="text-white text-xl">Loading Particula...</div>
      </div>
    )
  }

  return (
    <div className="flex flex-col h-screen bg-[#0D0D0D] text-white overflow-hidden">
      {/* Top Toolbar */}
      <TopToolbar />

      {/* Main Content */}
      <div className="flex flex-1 overflow-hidden">
        {/* Left Panel - Elements */}
        <LeftPanel />

        {/* Canvas - Center */}
        <main className="flex-1 relative">
          <Canvas />
        </main>

        {/* Right Panel - Settings */}
        <RightPanel />
      </div>

      {/* Bottom Bar */}
      <BottomBar />
    </div>
  )
}

export default App

--- End of File: apps/web/src/App.tsx ---


--- File: apps/web/src/components/Canvas.tsx ---

import { useRef, useEffect, useCallback, useState } from 'react'
import { useSimulationStore } from '@/stores/simulationStore'
import { useToolStore } from '@/stores/toolStore'
import { WorkerBridge, isWorkerSupported } from '@/lib/engine/WorkerBridge'
import { WasmParticleEngine } from '@/lib/engine'
import { screenToWorld as invertTransform, solvePanForZoom } from '@/lib/engine/transform'
import { ELEMENT_ID_TO_NAME } from '@/lib/engine/generated_elements'
import * as SimulationController from '@/lib/engine/SimulationController'

// Global bridge for external access (reset, etc.)
let globalBridge: WorkerBridge | null = null
let globalEngine: WasmParticleEngine | null = null // Fallback

export function getEngine(): WasmParticleEngine | null { return globalEngine }
export function getBridge(): WorkerBridge | null { return globalBridge }

// Camera reset callback
let resetCameraCallback: (() => void) | null = null
export function resetCamera(): void { resetCameraCallback?.() }

// Clear simulation callback
let clearSimulationCallback: (() => void) | null = null
export function clearSimulation(): void { clearSimulationCallback?.() }

/**
 * Canvas Component - Phase 1: WebWorker Architecture
 * 
 * Main thread only handles:
 * - User input (mouse events)
 * - Camera state
 * - React state updates (FPS, particle count)
 * 
 * Worker handles:
 * - WASM engine
 * - Physics simulation
 * - Rendering to OffscreenCanvas
 */
export function Canvas() {
  const canvasRef = useRef<HTMLCanvasElement>(null)
  const containerRef = useRef<HTMLDivElement>(null)
  const bridgeRef = useRef<WorkerBridge | null>(null)
  const engineRef = useRef<WasmParticleEngine | null>(null) // Fallback
  
  // Input state
  const isDrawing = useRef(false)
  const isDragging = useRef(false)
  const lastPos = useRef<{ x: number; y: number } | null>(null)
  const lastMousePos = useRef({ x: 0, y: 0 })
  
  // Loading state
  const [isLoading, setIsLoading] = useState(true)
  const [useWorker, setUseWorker] = useState(true)
  
  // Camera state (stored on main thread for coordinate conversion)
  const cameraRef = useRef({ x: 0, y: 0, zoom: 1 })
  
  // FIX 2: Ð”Ð¾ÑÑ‚Ð°ÐµÐ¼ renderMode Ð¸Ð· ÑÑ‚Ð¾Ñ€Ð°
  const { isPlaying, speed, gravity, ambientTemperature, renderMode, setFps, setParticleCount } = useSimulationStore()
  const { 
    selectedElement, 
    brushSize, 
    brushShape, 
    selectedTool,
    rigidBodyShape,
    rigidBodySize,
    rigidBodyElement,
  } = useToolStore()

  // Register callbacks
  useEffect(() => {
    resetCameraCallback = () => {
      cameraRef.current = { x: 0, y: 0, zoom: 1 }
      if (bridgeRef.current) {
        bridgeRef.current.setTransform(1, 0, 0)
      } else if (engineRef.current) {
        engineRef.current.setTransform(1, 0, 0)
      }
    }
    
    clearSimulationCallback = () => {
      if (bridgeRef.current) {
        bridgeRef.current.clear()
      } else if (engineRef.current) {
        engineRef.current.clear()
      }
    }
    
    return () => { 
      resetCameraCallback = null 
      clearSimulationCallback = null
    }
  }, [])

  // Sync play/pause state with worker
  useEffect(() => {
    if (bridgeRef.current) {
      if (isPlaying) {
        bridgeRef.current.play()
      } else {
        bridgeRef.current.pause()
      }
    }
  }, [isPlaying])

  // FIX 2: Sync renderMode (Thermal Vision)
  useEffect(() => {
    if (bridgeRef.current) {
      bridgeRef.current.setRenderMode(renderMode)
    } else if (engineRef.current) {
      engineRef.current.setRenderMode(renderMode)
    }
  }, [renderMode])

  // Sync physics settings
  useEffect(() => {
    if (bridgeRef.current) {
      bridgeRef.current.setSettings({ gravity, ambientTemperature, speed })
    } else if (engineRef.current) {
      engineRef.current.setSettings({ gravity, ambientTemperature })
    }
  }, [gravity, ambientTemperature, speed])

  // Initialize engine (Worker or Fallback)
  useEffect(() => {
    const canvas = canvasRef.current
    const container = containerRef.current
    if (!canvas || !container) return

    const { width, height } = container.getBoundingClientRect()
    if (width <= 0 || height <= 0) return
    
    canvas.width = width
    canvas.height = height
    
    const workerSupported = isWorkerSupported()
    setUseWorker(workerSupported)
    
    if (workerSupported) {
      // === PHASE 1: WORKER MODE ===
      const bridge = new WorkerBridge()
      bridgeRef.current = bridge
      globalBridge = bridge
      
      // Setup callbacks
      bridge.onStats = (stats) => {
        setFps(stats.fps)
        setParticleCount(stats.particleCount)
      }
      
      bridge.onReady = () => {
        console.log('ðŸš€ Worker ready! Physics runs in separate thread.')
        setIsLoading(false)
        // Auto-play on ready
        if (isPlaying) {
          bridge.play()
        }
      }
      
      bridge.onError = (msg) => {
        console.error('Worker error:', msg)
        // Fall back to main thread mode
        setUseWorker(false)
        initFallbackEngine(canvas, width, height)
      }
      
      bridge.onCrash = (msg) => {
        console.error('Worker crash:', msg)
        setUseWorker(false)
        initFallbackEngine(canvas, width, height)
      }
      
      // Initialize worker with canvas
      bridge.init(canvas, width, height).catch((err) => {
        console.warn('Worker init failed, falling back:', err)
        setUseWorker(false)
        initFallbackEngine(canvas, width, height)
      })
      
    } else {
      // === FALLBACK: MAIN THREAD MODE ===
      initFallbackEngine(canvas, width, height)
    }

    return () => {
      if (bridgeRef.current) {
        bridgeRef.current.destroy()
        bridgeRef.current = null
        globalBridge = null
      }
      if (engineRef.current) {
        engineRef.current.destroy()
        engineRef.current = null
        globalEngine = null
      }
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  // Fallback engine initialization (main thread)
  const initFallbackEngine = async (canvas: HTMLCanvasElement, width: number, height: number) => {
    try {
      console.log('ðŸ¦€ Fallback: Loading WASM in main thread...')
      const ctx = canvas.getContext('2d', { alpha: false })
      if (!ctx) throw new Error('No 2d context')
      
      const engine = await WasmParticleEngine.create(width, height)
      engine.attachRenderer(ctx)
      
      engineRef.current = engine
      globalEngine = engine
      setIsLoading(false)
      console.log('ðŸ¦€ Fallback engine ready!')
      
      // Start main thread render loop
      startFallbackRenderLoop(engine, ctx)
    } catch (err) {
      console.error('Failed to load WASM engine:', err)
      setIsLoading(false)
    }
  }
  
  // Main thread render loop (fallback)
  const startFallbackRenderLoop = (engine: WasmParticleEngine, _ctx: CanvasRenderingContext2D) => {
    let lastStatsUpdate = 0
    let lastTime = performance.now()
    const STATS_INTERVAL = 200
    
    const render = (time: number) => {
      if (!engineRef.current) return
      const dt = Math.min(Math.max((time - lastTime) / 1000, 0), 0.25)
      lastTime = time
      
      // Step simulation
      if (isPlaying) {
        const simDt = dt * speed
        engine.stepWithDt(simDt)
      }
      
      // Render
      const renderer = engine.getRenderer()
      const memory = engine.memory
      if (renderer && memory) {
        renderer.renderSmart(engine, memory)
      } else {
        engine.render()
      }
      
      // Stats update
      if (time - lastStatsUpdate > STATS_INTERVAL) {
        const approxFps = dt > 0 ? Math.round(1 / dt) : 60
        setFps(approxFps)
        setParticleCount(engine.particleCount)
        lastStatsUpdate = time
      }
      
      requestAnimationFrame(render)
    }
    
    requestAnimationFrame(render)
  }

  // Handle resize
  useEffect(() => {
    const handleResize = () => {
      const container = containerRef.current
      if (!container) return

      const { width, height } = container.getBoundingClientRect()
      
      if (bridgeRef.current) {
        bridgeRef.current.resize(width, height)
      } else if (engineRef.current) {
        const canvas = canvasRef.current
        if (canvas) {
          canvas.width = width
          canvas.height = height
        }
        engineRef.current.resize(width, height)
      }
    }

    window.addEventListener('resize', handleResize)
    return () => window.removeEventListener('resize', handleResize)
  }, [])

  // === INPUT HANDLERS ===

  const getCanvasPosition = useCallback((e: React.MouseEvent) => {
    const canvas = canvasRef.current
    if (!canvas) return { x: 0, y: 0 }
    
    const rect = canvas.getBoundingClientRect()
    return {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    }
  }, [])

  const screenToWorld = useCallback((sx: number, sy: number) => {
    const canvas = canvasRef.current
    if (!canvas) return { x: 0, y: 0 }
    const cam = cameraRef.current
    const viewport = { width: canvas.width, height: canvas.height }

    const world = invertTransform(
      sx,
      sy,
      { zoom: cam.zoom, panX: cam.x, panY: cam.y },
      viewport
    )

    return {
      x: Math.floor(world.x),
      y: Math.floor(world.y)
    }
  }, [])

  // Draw particles (send to worker or call engine directly)
  const draw = useCallback((screenX: number, screenY: number) => {
    const radius = Math.floor(brushSize / 2)
    
    if (bridgeRef.current) {
      const cam = cameraRef.current
      
      bridgeRef.current.setTransform(cam.zoom, cam.x, cam.y)

      // Fill is one-shot, handle separately
      if (selectedTool === 'fill') {
        bridgeRef.current.fill(screenX, screenY, selectedElement)
      } else if (selectedTool === 'rigid_body') {
        // Rigid body placement - convert to world coords and spawn
        const worldPos = screenToWorld(screenX, screenY)
        bridgeRef.current.spawnRigidBody(
          worldPos.x, 
          worldPos.y, 
          rigidBodySize, 
          rigidBodyShape, 
          rigidBodyElement
        )
      } else {
        // Worker mode: send screen coordinates, worker converts to world
        bridgeRef.current.handleInput(screenX, screenY, radius, selectedElement, selectedTool as any, brushShape)
      }
    } else if (engineRef.current) {
      // Fallback: convert to world and call engine
      const worldPos = screenToWorld(screenX, screenY)
      if (selectedTool === 'eraser') {
        engineRef.current.removeParticlesInRadius(worldPos.x, worldPos.y, radius)
      } else if (selectedTool === 'brush') {
        if (brushShape === 'square') {
          const half = Math.max(1, radius)
          for (let dy = -half; dy <= half; dy++) {
            for (let dx = -half; dx <= half; dx++) {
              engineRef.current.addParticlesInRadius(worldPos.x + dx, worldPos.y + dy, 1, selectedElement)
            }
          }
        } else if (brushShape === 'line') {
          engineRef.current.addParticlesInRadius(worldPos.x, worldPos.y, radius, selectedElement)
        } else {
          engineRef.current.addParticlesInRadius(worldPos.x, worldPos.y, radius, selectedElement)
        }
      } else if (selectedTool === 'fill') {
        engineRef.current.floodFill(worldPos.x, worldPos.y, selectedElement)
      } else if (selectedTool === 'rigid_body') {
        // Spawn rigid body in fallback mode
        if (rigidBodyShape === 'circle') {
          engineRef.current.spawnRigidCircle(worldPos.x, worldPos.y, Math.floor(rigidBodySize / 2), rigidBodyElement)
        } else {
          engineRef.current.spawnRigidBody(worldPos.x, worldPos.y, rigidBodySize, rigidBodySize, rigidBodyElement)
        }
      }
    }
  }, [brushSize, brushShape, selectedElement, selectedTool, screenToWorld, rigidBodyShape, rigidBodySize, rigidBodyElement])

  // Zoom handler - uses native event (not React) to allow preventDefault
  const handleWheel = useCallback((e: WheelEvent) => {
    e.preventDefault()

    const delta = e.deltaY > 0 ? 0.9 : 1.1
    const cam = cameraRef.current
    const newZoom = Math.min(Math.max(cam.zoom * delta, 0.1), 10)

    const canvas = canvasRef.current
    if (!canvas) return

    const rect = canvas.getBoundingClientRect()
    const mouseX = e.clientX - rect.left
    const mouseY = e.clientY - rect.top

    const viewport = { width: canvas.width, height: canvas.height }
    const nextCam = solvePanForZoom(
      mouseX,
      mouseY,
      newZoom,
      { zoom: cam.zoom, panX: cam.x, panY: cam.y },
      viewport
    )

    cam.x = nextCam.panX
    cam.y = nextCam.panY
    cam.zoom = nextCam.zoom
    
    if (bridgeRef.current) {
      bridgeRef.current.setTransform(cam.zoom, cam.x, cam.y)
    } else if (engineRef.current) {
      engineRef.current.setTransform(cam.zoom, cam.x, cam.y)
    }
  }, [])

  // Attach wheel listener with passive: false (React can't do this)
  useEffect(() => {
    const canvas = canvasRef.current
    if (!canvas) return
    
    canvas.addEventListener('wheel', handleWheel, { passive: false })
    return () => canvas.removeEventListener('wheel', handleWheel)
  }, [handleWheel])

  // Mouse handlers
  const handleMouseDown = useCallback((e: React.MouseEvent) => {
    const pos = getCanvasPosition(e)
    lastMousePos.current = { x: e.clientX, y: e.clientY }

    // Capture snapshot for undo before mutation
    SimulationController.captureSnapshotForUndo()

    // Pan mode
    if (selectedTool === 'move' || e.button === 1) {
      isDragging.current = true
      e.preventDefault()
      return
    }

    // Pipette
    if (selectedTool === 'pipette') {
      if (bridgeRef.current) {
        bridgeRef.current.pipette(pos.x, pos.y)
          .then((el) => { if (el) useToolStore.getState().setElement(el) })
      } else if (engineRef.current) {
        const world = screenToWorld(pos.x, pos.y)
        const elId = engineRef.current.getElementAt(world.x, world.y)
        const el = ELEMENT_ID_TO_NAME[elId] ?? null
        if (el) useToolStore.getState().setElement(el)
      }
      return
    }

    // Drawing
    isDrawing.current = true
    lastPos.current = pos
    draw(pos.x, pos.y)
  }, [getCanvasPosition, draw, selectedTool])

  const handleMouseMove = useCallback((e: React.MouseEvent) => {
    const pos = getCanvasPosition(e)

    // Pan mode
    if (isDragging.current) {
      const dx = e.clientX - lastMousePos.current.x
      const dy = e.clientY - lastMousePos.current.y
      
      const cam = cameraRef.current
      cam.x += dx
      cam.y += dy
      
      if (bridgeRef.current) {
        bridgeRef.current.setTransform(cam.zoom, cam.x, cam.y)
      } else if (engineRef.current) {
        engineRef.current.setTransform(cam.zoom, cam.x, cam.y)
      }
      
      lastMousePos.current = { x: e.clientX, y: e.clientY }
      return
    }

    // Drawing mode
    if (!isDrawing.current) return
    
    // Phase 5: Send raw events to Worker. Worker does Bresenham interpolation!
    // No need for client-side interpolation anymore.
    draw(pos.x, pos.y)
    lastPos.current = pos
  }, [getCanvasPosition, draw])

  const handleMouseUp = useCallback(() => {
    // CRITICAL: Reset Bresenham tracking in Worker to prevent lines between strokes!
    if (isDrawing.current && bridgeRef.current) {
      bridgeRef.current.endStroke()
    }
    isDrawing.current = false
    isDragging.current = false
    lastPos.current = null
  }, [])

  const handleMouseLeave = useCallback(() => {
    // Also reset Bresenham on mouse leave
    if (isDrawing.current && bridgeRef.current) {
      bridgeRef.current.endStroke()
    }
    isDrawing.current = false
    isDragging.current = false
    lastPos.current = null
  }, [])

  const getCursorClass = () => {
    switch (selectedTool) {
      case 'eraser': return 'cursor-cell'
      case 'pipette': return 'cursor-copy'
      case 'move': return 'cursor-grab'
      default: return 'cursor-crosshair'
    }
  }

  return (
    <div 
      ref={containerRef} 
      className="w-full h-full bg-[#0a0a0a] overflow-hidden relative"
    >
      {/* Loading overlay */}
      {isLoading && (
        <div className="absolute inset-0 flex items-center justify-center bg-[#0a0a0a] z-10">
          <div className="text-white text-lg">
            {useWorker ? 'ðŸš€ Starting WebWorker...' : 'ðŸ¦€ Loading WASM engine...'}
          </div>
        </div>
      )}
      
      {/* Worker mode indicator (dev only) */}
      {!isLoading && process.env.NODE_ENV === 'development' && (
        <div className="absolute top-2 right-2 text-xs text-gray-500 z-10">
          {useWorker ? 'ðŸš€ Worker' : 'ðŸ¦€ Main Thread'}
        </div>
      )}
      
      <canvas
        ref={canvasRef}
        className={`w-full h-full ${getCursorClass()}`}
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseLeave}
        onContextMenu={(e) => e.preventDefault()}
      />
    </div>
  )
}

--- End of File: apps/web/src/components/Canvas.tsx ---


--- File: apps/web/src/components/panels/BottomBar.tsx ---

import { useSimulationStore } from '@/stores/simulationStore'
import { Play, Pause, SkipForward, RotateCcw } from 'lucide-react'

export function BottomBar() {
  const {
    isPlaying,
    speed,
    fps,
    particleCount,
    play,
    pause,
    step,
    reset,
    setSpeed
  } = useSimulationStore()

  const speedOptions = [0.5, 1, 2, 4] as const

  return (
    <footer className="h-12 bg-[#1A1A1A] border-t border-[#333] flex items-center px-4 gap-4">
      {/* Playback Controls */}
      <div className="flex items-center gap-1">
        <button
          onClick={isPlaying ? pause : play}
          className="p-2 rounded-lg hover:bg-[#252525] transition-colors"
          title={isPlaying ? 'Pause' : 'Play'}
        >
          {isPlaying ? <Pause size={18} /> : <Play size={18} />}
        </button>
        <button
          onClick={step}
          disabled={isPlaying}
          className="p-2 rounded-lg hover:bg-[#252525] transition-colors disabled:opacity-50"
          title="Step"
        >
          <SkipForward size={18} />
        </button>
        <button
          onClick={reset}
          className="p-2 rounded-lg hover:bg-[#252525] transition-colors text-[#EF4444]"
          title="Reset"
        >
          <RotateCcw size={18} />
        </button>
      </div>

      {/* Divider */}
      <div className="w-px h-6 bg-[#333]" />

      {/* Speed Control */}
      <div className="flex items-center gap-2">
        <span className="text-sm text-[#A0A0A0]">Speed:</span>
        <div className="flex gap-0.5">
          {speedOptions.map((s) => (
            <button
              key={s}
              onClick={() => setSpeed(s)}
              className={`px-3 py-1 text-sm rounded-lg transition-colors ${
                speed === s
                  ? 'bg-[#3B82F6] text-white'
                  : 'bg-[#252525] text-[#A0A0A0] hover:text-white'
              }`}
            >
              {s}x
            </button>
          ))}
        </div>
      </div>

      {/* Spacer */}
      <div className="flex-1" />

      {/* Stats */}
      <div className="flex items-center gap-6 text-sm">
        <div className="flex items-center gap-1.5">
          <span 
            className={`w-2.5 h-2.5 rounded-full ${
              fps >= 50 ? 'bg-[#22C55E]' : fps >= 30 ? 'bg-[#F59E0B]' : 'bg-[#EF4444]'
            }`} 
          />
          <span className="text-[#A0A0A0]">FPS:</span>
          <span className="font-mono w-6">{fps}</span>
        </div>
        <div className="flex items-center gap-1.5">
          <span className="text-[#A0A0A0]">Particles:</span>
          <span className="font-mono">{formatNumber(particleCount)}</span>
        </div>
      </div>
    </footer>
  )
}

function formatNumber(num: number): string {
  if (num >= 1_000_000) return `${(num / 1_000_000).toFixed(1)}M`
  if (num >= 1_000) return `${(num / 1_000).toFixed(1)}K`
  return num.toString()
}

--- End of File: apps/web/src/components/panels/BottomBar.tsx ---


--- File: apps/web/src/components/panels/LeftPanel.tsx ---

import { useState } from 'react'
import { useToolStore } from '@/stores/toolStore'
import { ELEMENTS, ELEMENT_CATEGORIES } from '@/lib/elements'
import { ChevronLeft, ChevronRight, Square, Circle } from 'lucide-react'

// Rigid body shape definitions
const RIGID_BODY_SHAPES = [
  { id: 'box', name: 'Box', icon: Square, description: 'Rectangular rigid body' },
  { id: 'circle', name: 'Ball', icon: Circle, description: 'Circular rigid body' },
] as const

// Materials available for rigid bodies
const RIGID_BODY_MATERIALS = [
  { id: 'stone', name: 'Stone', color: '#808080' },
  { id: 'metal', name: 'Metal', color: '#A9A9A9' },
  { id: 'wood', name: 'Wood', color: '#8B4513' },
  { id: 'ice', name: 'Ice', color: '#A5F2F3' },
] as const

type PanelMode = 'elements' | 'bodies'

export function LeftPanel() {
  const [isCollapsed, setIsCollapsed] = useState(false)
  const [panelMode, setPanelMode] = useState<PanelMode>('elements')
  const [activeCategory, setActiveCategory] = useState<string>('solids')
  const { 
    selectedElement, 
    setElement,
    rigidBodyShape,
    rigidBodySize,
    rigidBodyElement,
    setRigidBodyShape,
    setRigidBodySize,
    setRigidBodyElement,
    selectedTool,
  } = useToolStore()

  const categories = Object.entries(ELEMENT_CATEGORIES)
  const elementsInCategory = ELEMENTS.filter(el => el.category === activeCategory)

  if (isCollapsed) {
    return (
      <div className="w-14 bg-[#1A1A1A] border-r border-[#333] flex flex-col items-center py-4">
        <button
          onClick={() => setIsCollapsed(false)}
          className="p-2.5 hover:bg-[#252525] rounded-lg transition-colors"
          title="Expand panel"
        >
          <ChevronRight size={18} />
        </button>
      </div>
    )
  }

  return (
    <aside className="w-64 bg-[#1A1A1A] border-r border-[#333] flex flex-col">
      {/* Header with mode toggle */}
      <div className="flex items-center justify-between px-5 py-4 border-b border-[#333]">
        <div className="flex gap-2">
          <button
            onClick={() => setPanelMode('elements')}
            className={`px-3 py-1.5 text-sm font-medium rounded-lg transition-all ${
              panelMode === 'elements'
                ? 'bg-[#3B82F6] text-white'
                : 'bg-[#252525] text-[#808080] hover:text-white'
            }`}
          >
            Elements
          </button>
          <button
            onClick={() => setPanelMode('bodies')}
            className={`px-3 py-1.5 text-sm font-medium rounded-lg transition-all ${
              panelMode === 'bodies'
                ? 'bg-[#8B5CF6] text-white'
                : 'bg-[#252525] text-[#808080] hover:text-white'
            }`}
          >
            Bodies
          </button>
        </div>
        <button
          onClick={() => setIsCollapsed(true)}
          className="p-2 hover:bg-[#252525] rounded-lg transition-colors"
          title="Collapse panel"
        >
          <ChevronLeft size={16} />
        </button>
      </div>

      {panelMode === 'elements' ? (
        <>
          {/* Category Tabs */}
          <div className="px-4 py-3 border-b border-[#333]">
            <div
              className="flex gap-2 overflow-x-auto scrollbar-hide"
              onWheel={(e) => {
                e.currentTarget.scrollLeft += e.deltaY
              }}
            >
              {categories.map(([key, label]) => (
                <button
                  key={key}
                  onClick={() => setActiveCategory(key)}
                  className={`px-4 py-2 text-sm font-medium rounded-lg whitespace-nowrap transition-all ${
                    activeCategory === key
                      ? 'bg-[#3B82F6] text-white shadow-lg shadow-blue-500/20'
                      : 'bg-[#252525] text-[#808080] hover:text-white hover:bg-[#2a2a2a]'
                  }`}
                >
                  {label}
                </button>
              ))}
            </div>
          </div>

          {/* Elements Grid */}
          <div
            className="flex-1 overflow-y-auto p-3"
            onWheel={(e) => {
              e.currentTarget.scrollTop += e.deltaY
            }}
          >
            <div className="grid grid-cols-3 gap-2">
              {elementsInCategory.map((element) => (
                <ElementButton
                  key={element.id}
                  element={element}
                  isSelected={selectedElement === element.id && selectedTool !== 'rigid_body'}
                  onClick={() => setElement(element.id)}
                />
              ))}
            </div>
          </div>
        </>
      ) : (
        <>
          {/* Rigid Bodies Panel */}
          <div className="flex-1 overflow-y-auto p-4">
            {/* Shape Selection */}
            <div className="mb-4">
              <label className="text-xs text-[#808080] uppercase tracking-wider mb-2 block">Shape</label>
              <div className="grid grid-cols-2 gap-2">
                {RIGID_BODY_SHAPES.map((shape) => {
                  const Icon = shape.icon
                  return (
                    <button
                      key={shape.id}
                      onClick={() => setRigidBodyShape(shape.id)}
                      className={`
                        flex flex-col items-center justify-center p-3 rounded-lg transition-all
                        ${rigidBodyShape === shape.id && selectedTool === 'rigid_body'
                          ? 'bg-[#8B5CF6] text-white ring-2 ring-purple-400'
                          : 'bg-[#252525] text-[#808080] hover:text-white hover:bg-[#2a2a2a]'
                        }
                      `}
                      title={shape.description}
                    >
                      <Icon size={24} />
                      <span className="text-xs mt-1">{shape.name}</span>
                    </button>
                  )
                })}
              </div>
            </div>

            {/* Size Slider */}
            <div className="mb-4">
              <label className="text-xs text-[#808080] uppercase tracking-wider mb-2 block">
                Size: {rigidBodySize}px
              </label>
              <input
                type="range"
                min="5"
                max="50"
                value={rigidBodySize}
                onChange={(e) => setRigidBodySize(parseInt(e.target.value))}
                className="w-full h-2 bg-[#252525] rounded-lg appearance-none cursor-pointer accent-[#8B5CF6]"
              />
            </div>

            {/* Material Selection */}
            <div className="mb-4">
              <label className="text-xs text-[#808080] uppercase tracking-wider mb-2 block">Material</label>
              <div className="grid grid-cols-2 gap-2">
                {RIGID_BODY_MATERIALS.map((material) => (
                  <button
                    key={material.id}
                    onClick={() => setRigidBodyElement(material.id as any)}
                    className={`
                      flex items-center gap-2 p-2 rounded-lg transition-all
                      ${rigidBodyElement === material.id
                        ? 'bg-[#252525] ring-2 ring-[#8B5CF6]'
                        : 'bg-[#1f1f1f] hover:bg-[#252525]'
                      }
                    `}
                  >
                    <div
                      className="w-6 h-6 rounded"
                      style={{ backgroundColor: material.color }}
                    />
                    <span className="text-xs">{material.name}</span>
                  </button>
                ))}
              </div>
            </div>

            {/* Instructions */}
            <div className="mt-4 p-3 bg-[#252525] rounded-lg">
              <p className="text-xs text-[#808080]">
                ðŸ’¡ Click on canvas to place a rigid body. It will fall and collide with other objects!
              </p>
            </div>
          </div>
        </>
      )}
    </aside>
  )
}

interface ElementButtonProps {
  element: typeof ELEMENTS[0]
  isSelected: boolean
  onClick: () => void
}

function ElementButton({ element, isSelected, onClick }: ElementButtonProps) {
  return (
    <button
      onClick={onClick}
      className={`
        aspect-square
        flex flex-col items-center justify-center 
        p-2 rounded-lg 
        transition-all duration-200 
        ${isSelected
          ? 'bg-[#252525] ring-2 ring-[#3B82F6] shadow-lg shadow-blue-500/20'
          : 'bg-[#1f1f1f] hover:bg-[#252525]'
        }
      `}
      title={`${element.name}: ${element.description}`}
    >
      {/* Element Color Box */}
      <div
        className="w-10 h-10 rounded-lg shadow-md flex-shrink-0"
        style={{
          background: `linear-gradient(145deg, ${element.color}, ${adjustColor(element.color, -30)})`,
          boxShadow: isSelected 
            ? `0 0 12px ${element.color}50, inset 0 1px 0 ${adjustColor(element.color, 50)}40` 
            : `inset 0 1px 0 ${adjustColor(element.color, 50)}30`,
        }}
      />
      
      {/* Element Name */}
      <span className={`
        text-xs mt-1.5 font-medium text-center w-full truncate
        ${isSelected ? 'text-white' : 'text-[#707070]'}
      `}>
        {element.name}
      </span>
    </button>
  )
}

// Helper to darken/lighten color
function adjustColor(hex: string, amount: number): string {
  const num = parseInt(hex.replace('#', ''), 16)
  const r = Math.min(255, Math.max(0, (num >> 16) + amount))
  const g = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + amount))
  const b = Math.min(255, Math.max(0, (num & 0x0000FF) + amount))
  return `#${((r << 16) | (g << 8) | b).toString(16).padStart(6, '0')}`
}

--- End of File: apps/web/src/components/panels/LeftPanel.tsx ---


--- File: apps/web/src/components/panels/RightPanel.tsx ---

import { useState } from 'react'
import { useSimulationStore } from '@/stores/simulationStore'
import { ChevronLeft, ChevronRight } from 'lucide-react'

export function RightPanel() {
  const [isCollapsed, setIsCollapsed] = useState(false)
  const { gravity, ambientTemperature, setGravity, setAmbientTemperature } = useSimulationStore()

  if (isCollapsed) {
    return (
      <div className="w-12 bg-[#1A1A1A] border-l border-[#333] flex flex-col items-center py-3">
        <button
          onClick={() => setIsCollapsed(false)}
          className="p-2 hover:bg-[#252525] rounded transition-colors"
        >
          <ChevronLeft size={16} />
        </button>
      </div>
    )
  }

  return (
    <aside className="w-64 bg-[#1A1A1A] border-l border-[#333] flex flex-col">
      {/* Header */}
      <div className="flex items-center justify-between px-4 py-3 border-b border-[#333]">
        <span className="text-base font-semibold">Settings</span>
        <button
          onClick={() => setIsCollapsed(true)}
          className="p-1.5 hover:bg-[#252525] rounded transition-colors"
        >
          <ChevronRight size={14} />
        </button>
      </div>

      {/* Settings */}
      <div className="flex-1 overflow-y-auto p-4 space-y-5">
        {/* Gravity */}
        <div className="space-y-2">
          <label className="text-sm text-[#A0A0A0] font-medium">Gravity</label>
          
          <div className="space-y-1">
            <div className="flex items-center gap-2">
              <span className="text-sm text-[#A0A0A0] w-5">X:</span>
              <input
                type="range"
                min={-10}
                max={10}
                step={0.1}
                value={gravity.x}
                onChange={(e) => setGravity({ ...gravity, x: Number(e.target.value) })}
                className="flex-1 h-1.5 bg-[#333] rounded-full appearance-none cursor-pointer
                           [&::-webkit-slider-thumb]:appearance-none
                           [&::-webkit-slider-thumb]:w-4
                           [&::-webkit-slider-thumb]:h-4
                           [&::-webkit-slider-thumb]:bg-[#3B82F6]
                           [&::-webkit-slider-thumb]:rounded-full"
              />
              <span className="text-xs font-mono w-10 text-right">{gravity.x.toFixed(1)}</span>
            </div>
            <div className="flex items-center gap-2">
              <span className="text-sm text-[#A0A0A0] w-5">Y:</span>
              <input
                type="range"
                min={-10}
                max={10}
                step={0.1}
                value={gravity.y}
                onChange={(e) => setGravity({ ...gravity, y: Number(e.target.value) })}
                className="flex-1 h-1.5 bg-[#333] rounded-full appearance-none cursor-pointer
                           [&::-webkit-slider-thumb]:appearance-none
                           [&::-webkit-slider-thumb]:w-4
                           [&::-webkit-slider-thumb]:h-4
                           [&::-webkit-slider-thumb]:bg-[#3B82F6]
                           [&::-webkit-slider-thumb]:rounded-full"
              />
              <span className="text-xs font-mono w-10 text-right">{gravity.y.toFixed(1)}</span>
            </div>
          </div>
          
          {/* Gravity Presets */}
          <div className="flex gap-1">
            <PresetButton 
              label="Earth" 
              onClick={() => setGravity({ x: 0, y: 9.8 })} 
            />
            <PresetButton 
              label="Moon" 
              onClick={() => setGravity({ x: 0, y: 1.6 })} 
            />
            <PresetButton 
              label="None" 
              onClick={() => setGravity({ x: 0, y: 0 })} 
            />
          </div>
        </div>

        {/* Divider */}
        <div className="h-px bg-[#333]" />

        {/* Ambient Temperature */}
        <div className="space-y-2">
          <label className="text-sm text-[#A0A0A0] font-medium">
            Ambient Temperature
          </label>
          <div className="flex items-center gap-2">
            <input
              type="range"
              min={-50}
              max={100}
              value={ambientTemperature}
              onChange={(e) => setAmbientTemperature(Number(e.target.value))}
              className="flex-1 h-1.5 bg-[#333] rounded-full appearance-none cursor-pointer
                         [&::-webkit-slider-thumb]:appearance-none
                         [&::-webkit-slider-thumb]:w-4
                         [&::-webkit-slider-thumb]:h-4
                         [&::-webkit-slider-thumb]:bg-[#3B82F6]
                         [&::-webkit-slider-thumb]:rounded-full"
            />
            <span className="text-xs font-mono w-12 text-right">{ambientTemperature}Â°C</span>
          </div>
          
          {/* Temperature Presets */}
          <div className="flex gap-1">
            <PresetButton 
              label="Cold" 
              onClick={() => setAmbientTemperature(-20)} 
            />
            <PresetButton 
              label="Normal" 
              onClick={() => setAmbientTemperature(20)} 
            />
            <PresetButton 
              label="Hot" 
              onClick={() => setAmbientTemperature(50)} 
            />
          </div>
        </div>
      </div>
    </aside>
  )
}

interface PresetButtonProps {
  label: string
  onClick: () => void
}

function PresetButton({ label, onClick }: PresetButtonProps) {
  return (
    <button
      onClick={onClick}
      className="flex-1 px-2 py-1.5 text-xs bg-[#252525] rounded-lg
                 text-[#A0A0A0] hover:text-white transition-colors"
    >
      {label}
    </button>
  )
}

--- End of File: apps/web/src/components/panels/RightPanel.tsx ---


--- File: apps/web/src/components/panels/TopToolbar.tsx ---

import { useToolStore } from '@/stores/toolStore'
import { useSimulationStore } from '@/stores/simulationStore'
import { resetCamera } from '@/components/Canvas'
import * as SimulationController from '@/lib/engine/SimulationController'
import { 
  Circle, 
  Square, 
  Minus, 
  Eraser, 
  Pipette, 
  PaintBucket,
  Hand,
  Focus,
  Undo,
  Redo,
  Save,
  FolderOpen,
  Thermometer
} from 'lucide-react'

export function TopToolbar() {
  const { 
    selectedTool, 
    brushShape, 
    brushSize, 
    setTool, 
    setBrushShape, 
    setBrushSize 
  } = useToolStore()
  
  const { renderMode, toggleRenderMode } = useSimulationStore()

  return (
    <header className="h-14 bg-[#1A1A1A] border-b border-[#333] flex items-center px-4 gap-4">
      {/* Logo */}
      <div className="flex items-center gap-2 mr-4">
        <div className="w-7 h-7 bg-gradient-to-br from-[#3B82F6] to-purple-500 rounded" />
        <span className="font-semibold text-base">Particula</span>
      </div>

      {/* Divider */}
      <div className="w-px h-6 bg-[#333]" />

      {/* Brush Shapes */}
      <div className="flex items-center gap-1">
        <ToolButton
          icon={<Circle size={16} />}
          isActive={brushShape === 'circle'}
          onClick={() => setBrushShape('circle')}
          tooltip="Circle Brush"
        />
        <ToolButton
          icon={<Square size={16} />}
          isActive={brushShape === 'square'}
          onClick={() => setBrushShape('square')}
          tooltip="Square Brush"
        />
        <ToolButton
          icon={<Minus size={16} />}
          isActive={brushShape === 'line'}
          onClick={() => setBrushShape('line')}
          tooltip="Line Tool"
        />
      </div>

      {/* Divider */}
      <div className="w-px h-6 bg-[#333]" />

      {/* Brush Size */}
      <div className="flex items-center gap-2">
        <span className="text-sm text-[#A0A0A0]">Size:</span>
        <input
          type="range"
          min={1}
          max={50}
          value={brushSize}
          onChange={(e) => setBrushSize(Number(e.target.value))}
          className="w-28 h-1.5 bg-[#333] rounded-full appearance-none cursor-pointer
                     [&::-webkit-slider-thumb]:appearance-none
                     [&::-webkit-slider-thumb]:w-4
                     [&::-webkit-slider-thumb]:h-4
                     [&::-webkit-slider-thumb]:bg-[#3B82F6]
                     [&::-webkit-slider-thumb]:rounded-full
                     [&::-webkit-slider-thumb]:cursor-pointer"
        />
        <span className="text-sm text-[#A0A0A0] w-8 font-mono">{brushSize}</span>
      </div>

      {/* Divider */}
      <div className="w-px h-6 bg-[#333]" />

      {/* Tools */}
      <div className="flex items-center gap-1">
        <ToolButton
          icon={<Eraser size={16} />}
          isActive={selectedTool === 'eraser'}
          onClick={() => setTool('eraser')}
          tooltip="Eraser"
        />
        <ToolButton
          icon={<Hand size={16} />}
          isActive={selectedTool === 'move'}
          onClick={() => setTool('move')}
          tooltip="Move / Pan (Middle Mouse)"
        />
        <ToolButton
          icon={<Pipette size={16} />}
          isActive={selectedTool === 'pipette'}
          onClick={() => setTool('pipette')}
          tooltip="Pipette"
        />
        <ToolButton
          icon={<PaintBucket size={16} />}
          isActive={selectedTool === 'fill'}
          onClick={() => setTool('fill')}
          tooltip="Fill"
        />
      </div>

      {/* Divider */}
      <div className="w-px h-6 bg-[#333]" />

      {/* View Controls */}
      <div className="flex items-center gap-1">
        <ToolButton
          icon={<Thermometer size={16} />}
          isActive={renderMode === 'thermal'}
          onClick={toggleRenderMode}
          tooltip={renderMode === 'thermal' ? 'Normal View' : 'Thermal Vision'}
        />
        <ToolButton
          icon={<Focus size={16} />}
          onClick={resetCamera}
          tooltip="Reset View (1:1)"
        />
      </div>

      {/* Spacer */}
      <div className="flex-1" />

      {/* Actions */}
      <div className="flex items-center gap-1">
        <ToolButton
          icon={<Undo size={16} />}
          onClick={() => SimulationController.undo()}
          tooltip="Undo"
        />
        <ToolButton
          icon={<Redo size={16} />}
          onClick={() => SimulationController.redo()}
          tooltip="Redo"
        />
        <div className="w-px h-6 bg-border mx-1" />
        <ToolButton
          icon={<Save size={16} />}
          onClick={() => SimulationController.saveSnapshot()}
          tooltip="Save"
        />
        <ToolButton
          icon={<FolderOpen size={16} />}
          onClick={() => SimulationController.loadSnapshot()}
          tooltip="Load"
        />
      </div>
    </header>
  )
}

interface ToolButtonProps {
  icon: React.ReactNode
  isActive?: boolean
  onClick: () => void
  tooltip: string
}

function ToolButton({ icon, isActive, onClick, tooltip }: ToolButtonProps) {
  return (
    <button
      onClick={onClick}
      title={tooltip}
      className={`p-2.5 rounded-lg transition-colors ${
        isActive
          ? 'bg-[#3B82F6] text-white'
          : 'hover:bg-[#252525] text-[#A0A0A0] hover:text-white'
      }`}
    >
      {icon}
    </button>
  )
}

--- End of File: apps/web/src/components/panels/TopToolbar.tsx ---


--- File: apps/web/src/lib/InputBuffer.ts ---

/**
 * SharedInputBuffer - Lock-free Ring Buffer for Mouse Input
 * 
 * Phase 5: "Telemetry" - Zero-latency input via SharedArrayBuffer
 * Phase 3 (Fort Knox): Overflow protection to prevent Bresenham artifacts
 * 
 * Instead of postMessage (async, serialization overhead), we write
 * mouse events directly to shared memory. Worker reads every frame.
 * 
 * Buffer Layout:
 * [0] = Write Head (Main Thread writes here)
 * [1] = Read Head (Worker reads here)
 * [2] = Overflow Flag (Phase 3: set when buffer overflows)
 * [3..] = Events: [x, y, type, brushSize] * INPUT_BUFFER_SIZE
 * 
 * Total size: (3 + 4 * 100) * 4 = 1612 bytes
 */

export const INPUT_BUFFER_SIZE = 100 // Max events in queue
export const EVENT_SIZE = 4 // Int32 per event: x, y, type, brushSize
const HEAD_OFFSET = 3 // First 3 slots are write/read heads + overflow flag
const OVERFLOW_INDEX = 2 // Index of overflow flag in buffer

// Input event types (matches ToolType + element encoding)
export const INPUT_TYPE_BRUSH = 0
export const INPUT_TYPE_ERASE = 1
export const INPUT_TYPE_END_STROKE = 254 // Sentinel: reset Bresenham tracking
export const INPUT_TYPE_NONE = 255 // No-op / skip
export const INPUT_TYPE_BRUSH_OFFSET = 100 // Keep brush payload distinct from erase sentinel

/**
 * Calculate required buffer size in bytes
 */
export function getInputBufferSize(): number {
  return (HEAD_OFFSET + INPUT_BUFFER_SIZE * EVENT_SIZE) * 4 // Int32 = 4 bytes
}

/**
 * Check if SharedArrayBuffer is available
 */
export function isSharedArrayBufferAvailable(): boolean {
  return typeof SharedArrayBuffer !== 'undefined'
}

/**
 * Shared Input Buffer for Main Thread <-> Worker communication
 * 
 * Uses Atomics for thread-safe read/write without locks.
 * Lock-free SPSC (Single Producer Single Consumer) queue.
 */
export class SharedInputBuffer {
  private buffer: Int32Array
  
  constructor(sharedBuffer: SharedArrayBuffer) {
    this.buffer = new Int32Array(sharedBuffer)
    // Initialize heads and overflow flag to 0
    Atomics.store(this.buffer, 0, 0) // Write head
    Atomics.store(this.buffer, 1, 0) // Read head
    Atomics.store(this.buffer, OVERFLOW_INDEX, 0) // Overflow flag (Phase 3)
  }
  
  /**
   * Get the underlying SharedArrayBuffer for transfer to Worker
   */
  getBuffer(): SharedArrayBuffer {
    return this.buffer.buffer as SharedArrayBuffer
  }
  
  // === MAIN THREAD API ===
  
  /**
   * Push input event to buffer (called from Main Thread)
   * 
   * @param x Screen X coordinate
   * @param y Screen Y coordinate
   * @param type INPUT_TYPE_BRUSH or INPUT_TYPE_ERASE
   * @param val Brush size or element ID
   * @returns true if pushed, false if buffer full
   */
  push(x: number, y: number, type: number, val: number): boolean {
    const writeIndex = Atomics.load(this.buffer, 0)
    const readIndex = Atomics.load(this.buffer, 1)
    
    // Calculate next write position (ring buffer wrap)
    const nextWriteIndex = (writeIndex + 1) % INPUT_BUFFER_SIZE
    
    // Check if buffer is full (writer caught up to reader)
    if (nextWriteIndex === readIndex) {
      // Phase 3 (Fort Knox): Set overflow flag when buffer is full
      // This tells the Worker to reset Bresenham state
      Atomics.store(this.buffer, OVERFLOW_INDEX, 1)
      return false
    }
    
    // Write event data
    const offset = HEAD_OFFSET + writeIndex * EVENT_SIZE
    this.buffer[offset + 0] = Math.floor(x)
    this.buffer[offset + 1] = Math.floor(y)
    this.buffer[offset + 2] = type
    this.buffer[offset + 3] = Math.floor(val)
    
    // Atomically update write head (makes event visible to worker)
    Atomics.store(this.buffer, 0, nextWriteIndex)
    
    return true
  }
  
  /**
   * Push brush event
   */
  pushBrush(x: number, y: number, brushSize: number, elementId: number): boolean {
    // Encode element ID in type field (offset to avoid colliding with erase sentinel)
    return this.push(x, y, INPUT_TYPE_BRUSH_OFFSET + elementId, brushSize)
  }
  
  /**
   * Push erase event
   */
  pushErase(x: number, y: number, brushSize: number): boolean {
    return this.push(x, y, INPUT_TYPE_ERASE, brushSize)
  }
  
  /**
   * Push end-stroke sentinel (resets Bresenham tracking in worker)
   * CRITICAL: Must go through same channel as brush events to prevent race conditions!
   */
  pushEndStroke(): boolean {
    return this.push(0, 0, INPUT_TYPE_END_STROKE, 0)
  }
  
  // === WORKER THREAD API ===
  
  /**
   * Read all pending events (called from Worker Thread)
   * Returns array of events to process this frame
   */
  readAll(): Array<{ x: number; y: number; type: number; val: number }> {
    const writeIndex = Atomics.load(this.buffer, 0)
    let readIndex = Atomics.load(this.buffer, 1)
    
    const events: Array<{ x: number; y: number; type: number; val: number }> = []
    
    // Read all events between read head and write head
    while (readIndex !== writeIndex) {
      const offset = HEAD_OFFSET + readIndex * EVENT_SIZE
      
      events.push({
        x: this.buffer[offset + 0],
        y: this.buffer[offset + 1],
        type: this.buffer[offset + 2],
        val: this.buffer[offset + 3]
      })
      
      // Move to next slot (ring wrap)
      readIndex = (readIndex + 1) % INPUT_BUFFER_SIZE
    }
    
    // Atomically update read head (marks events as consumed)
    Atomics.store(this.buffer, 1, readIndex)
    
    return events
  }
  
  /**
   * Process events directly without allocation (zero-GC version)
   * Calls callback for each event
   */
  processAll(callback: (x: number, y: number, type: number, val: number) => void): number {
    const writeIndex = Atomics.load(this.buffer, 0)
    let readIndex = Atomics.load(this.buffer, 1)
    let count = 0
    
    while (readIndex !== writeIndex) {
      const offset = HEAD_OFFSET + readIndex * EVENT_SIZE
      
      callback(
        this.buffer[offset + 0],
        this.buffer[offset + 1],
        this.buffer[offset + 2],
        this.buffer[offset + 3]
      )
      
      readIndex = (readIndex + 1) % INPUT_BUFFER_SIZE
      count++
    }
    
    Atomics.store(this.buffer, 1, readIndex)
    return count
  }
  
  /**
   * Get number of pending events (for debugging)
   */
  pendingCount(): number {
    const writeIndex = Atomics.load(this.buffer, 0)
    const readIndex = Atomics.load(this.buffer, 1)
    
    if (writeIndex >= readIndex) {
      return writeIndex - readIndex
    }
    return INPUT_BUFFER_SIZE - readIndex + writeIndex
  }
  
  // === PHASE 3 (Fort Knox): Overflow Protection ===
  
  /**
   * Check if overflow occurred (buffer was full when push was attempted)
   * This should be checked by Worker before processing events.
   * If true, Worker should reset Bresenham tracking to prevent line artifacts.
   */
  checkOverflow(): boolean {
    return Atomics.load(this.buffer, OVERFLOW_INDEX) === 1
  }
  
  /**
   * Clear overflow flag (called by Worker after handling overflow)
   */
  clearOverflow(): void {
    Atomics.store(this.buffer, OVERFLOW_INDEX, 0)
  }
  
  /**
   * Check and clear overflow atomically
   * Returns true if overflow occurred (and clears the flag)
   */
  checkAndClearOverflow(): boolean {
    // Atomics.exchange returns the old value and sets the new value
    return Atomics.exchange(this.buffer, OVERFLOW_INDEX, 0) === 1
  }
}

--- End of File: apps/web/src/lib/InputBuffer.ts ---


--- File: apps/web/src/lib/elements.ts ---

/**
 * UI-facing element definitions for LeftPanel
 */

import type { ElementType } from './engine'

export type { ElementType }

export interface Element {
  id: ElementType
  name: string
  category: string
  color: string
  description: string
}

export const ELEMENT_CATEGORIES: Record<string, string> = {
  solids: 'Solids',
  liquids: 'Liquids',
  gases: 'Gases',
  energy: 'Energy',
  utility: 'Utility',
  bio: 'Nature',
}

export const ELEMENTS: Element[] = [
  // Solids
  {
    id: 'stone',
    name: 'Stone',
    category: 'solids',
    color: '#808080',
    description: 'Heavy solid, melts at high temperature',
  },
  {
    id: 'sand',
    name: 'Sand',
    category: 'solids',
    color: '#C2B280',
    description: 'Falls and piles up, melts into glass',
  },
  {
    id: 'wood',
    name: 'Wood',
    category: 'solids',
    color: '#8B4513',
    description: 'Flammable solid',
  },
  {
    id: 'metal',
    name: 'Metal',
    category: 'solids',
    color: '#A9A9A9',
    description: 'Conducts heat and electricity',
  },
  {
    id: 'ice',
    name: 'Ice',
    category: 'solids',
    color: '#A5F2F3',
    description: 'Melts from fire/lava, floats on water',
  },
  {
    id: 'gunpowder',
    name: 'Gunpowder',
    category: 'solids',
    color: '#404040',
    description: 'Explosive! Ignites instantly from fire',
  },
  
  // Liquids
  {
    id: 'water',
    name: 'Water',
    category: 'liquids',
    color: '#4169E1',
    description: 'Flows, evaporates, extinguishes fire',
  },
  {
    id: 'oil',
    name: 'Oil',
    category: 'liquids',
    color: '#4A4A2A',
    description: 'Flammable liquid, floats on water',
  },
  {
    id: 'lava',
    name: 'Lava',
    category: 'liquids',
    color: '#FF4500',
    description: 'Hot liquid, ignites flammables',
  },
  {
    id: 'acid',
    name: 'Acid',
    category: 'liquids',
    color: '#39FF14',
    description: 'Dissolves stone, metal, wood (1:1)',
  },
  
  // Gases
  {
    id: 'steam',
    name: 'Steam',
    category: 'gases',
    color: '#E0E0E0',
    description: 'Rises up, condenses into water',
  },
  {
    id: 'smoke',
    name: 'Smoke',
    category: 'gases',
    color: '#2F2F2F',
    description: 'Rises and dissipates',
  },
  
  // Energy
  {
    id: 'fire',
    name: 'Fire',
    category: 'energy',
    color: '#FF6600',
    description: 'Burns flammables, extinguished by water',
  },
  {
    id: 'spark',
    name: 'Spark',
    category: 'energy',
    color: '#FFFF00',
    description: 'Brief ignition source',
  },
  {
    id: 'electricity',
    name: 'Electric',
    category: 'energy',
    color: '#00FFFF',
    description: 'Flows through conductors',
  },
  
  // Utility
  {
    id: 'clone',
    name: 'Clone',
    category: 'utility',
    color: '#00FF00',
    description: 'Duplicates touching particles',
  },
  {
    id: 'void',
    name: 'Void',
    category: 'utility',
    color: '#000000',
    description: 'Destroys all particles',
  },
  
  // Nature/Bio
  {
    id: 'dirt',
    name: 'Dirt',
    category: 'bio',
    color: '#5C4033',
    description: 'Fertile soil for plants',
  },
  {
    id: 'seed',
    name: 'Seed',
    category: 'bio',
    color: '#E2C489',
    description: 'Plant on wet dirt to grow!',
  },
  {
    id: 'plant',
    name: 'Plant',
    category: 'bio',
    color: '#228B22',
    description: 'Grows with water, burns easily',
  },
]

export function getElementById(id: ElementType): Element | undefined {
  return ELEMENTS.find(el => el.id === id)
}

export function getElementColor(id: ElementType): string {
  return getElementById(id)?.color ?? '#FFFFFF'
}

--- End of File: apps/web/src/lib/elements.ts ---


--- File: apps/web/src/lib/engine/MemoryManager.ts ---

/**
 * MemoryManager - Safe WASM Memory Access (Phase 3: Fort Knox)
 * 
 * Problem: WASM memory can grow dynamically (resize in Rust).
 * When this happens, the underlying ArrayBuffer is DETACHED,
 * and all existing TypedArray views become invalid.
 * 
 * Solution: Never store views as long-lived variables.
 * Always access memory through this manager, which automatically
 * detects detached buffers and recreates views.
 * 
 * Usage:
 *   const mm = new MemoryManager(wasmMemory, engine)
 *   const types = mm.types  // Always valid!
 *   const colors = mm.colors // Always valid!
 */

export class MemoryManager {
  private memory: WebAssembly.Memory
  private engine: any  // WASM World instance
  
  // Cached views (recreated on buffer detach)
  private _types: Uint8Array | null = null
  private _colors: Uint32Array | null = null
  private _temperature: Float32Array | null = null
  
  // Track buffer state for detach detection
  private lastByteLength: number = 0
  private lastTypesPtr: number = 0
  private lastColorsPtr: number = 0
  private lastTempPtr: number = 0
  
  constructor(memory: WebAssembly.Memory, engine: any) {
    this.memory = memory
    this.engine = engine
    this.rebuildViews()
  }
  
  /**
   * Check if memory buffer was detached or resized
   */
  private isStale(): boolean {
    // Check if buffer was detached (byteLength becomes 0)
    // or if memory grew (byteLength changed)
    try {
      const currentLength = this.memory.buffer.byteLength
      if (currentLength !== this.lastByteLength) {
        return true
      }
      
      // Also check if pointers changed (world was recreated)
      const typesPtr = this.engine.types_ptr()
      const colorsPtr = this.engine.colors_ptr()
      const tempPtr = this.engine.temperature_ptr()
      
      if (typesPtr !== this.lastTypesPtr ||
          colorsPtr !== this.lastColorsPtr ||
          tempPtr !== this.lastTempPtr) {
        return true
      }
      
      return false
    } catch (e) {
      // If we can't access buffer, it's definitely stale
      return true
    }
  }
  
  /**
   * Ensure views are valid, rebuild if necessary
   */
  private ensureValid(): void {
    if (this.isStale()) {
      this.rebuildViews()
    }
  }
  
  /**
   * Rebuild all TypedArray views from current WASM memory
   */
  rebuildViews(): void {
    try {
      const size = this.engine.types_len()
      const typesPtr = this.engine.types_ptr()
      const colorsPtr = this.engine.colors_ptr()
      const tempPtr = this.engine.temperature_ptr()
      
      this._types = new Uint8Array(this.memory.buffer, typesPtr, size)
      this._colors = new Uint32Array(this.memory.buffer, colorsPtr, size)
      this._temperature = new Float32Array(this.memory.buffer, tempPtr, size)
      
      // Update tracking
      this.lastByteLength = this.memory.buffer.byteLength
      this.lastTypesPtr = typesPtr
      this.lastColorsPtr = colorsPtr
      this.lastTempPtr = tempPtr
      
      console.log(`ðŸ”’ MemoryManager: Views rebuilt (${size} cells, ${this.lastByteLength} bytes)`)
    } catch (e) {
      console.error('MemoryManager: Failed to rebuild views:', e)
      this._types = null
      this._colors = null
      this._temperature = null
    }
  }
  
  /**
   * Force rebuild (call after engine.step() if memory might have grown)
   */
  refresh(): void {
    if (this.isStale()) {
      this.rebuildViews()
    }
  }
  
  // === Safe Getters ===
  
  /**
   * Get types view (element IDs) - always valid
   */
  get types(): Uint8Array {
    this.ensureValid()
    if (!this._types) {
      throw new Error('MemoryManager: types view unavailable')
    }
    return this._types
  }
  
  /**
   * Get colors view (RGBA packed as u32) - always valid
   */
  get colors(): Uint32Array {
    this.ensureValid()
    if (!this._colors) {
      throw new Error('MemoryManager: colors view unavailable')
    }
    return this._colors
  }
  
  /**
   * Get temperature view (f32 per cell) - always valid
   */
  get temperature(): Float32Array {
    this.ensureValid()
    if (!this._temperature) {
      throw new Error('MemoryManager: temperature view unavailable')
    }
    return this._temperature
  }
  
  /**
   * Get raw memory view (for WebGL uploads) - always valid
   */
  get memoryView(): Uint8Array {
    this.ensureValid()
    return new Uint8Array(this.memory.buffer)
  }
  
  /**
   * Check if views are currently valid
   */
  get isValid(): boolean {
    return !this.isStale() && 
           this._types !== null && 
           this._colors !== null && 
           this._temperature !== null
  }
  
  /**
   * Get current memory buffer size
   */
  get bufferSize(): number {
    return this.memory.buffer.byteLength
  }
}

--- End of File: apps/web/src/lib/engine/MemoryManager.ts ---


--- File: apps/web/src/lib/engine/Renderer.ts ---

/**
 * High-performance renderer using Double Buffering
 * Phase 5: ABGR direct copy + OffscreenCanvas optimization
 * 
 * Optimizations:
 * - ABGR format: Direct pixels32.set() from WASM memory
 * - OffscreenCanvas: Better memory management, no DOM overhead
 * - Uint32Array.fill(): 50-100x faster clear
 * - No object access = no pointer chasing = cache friendly
 */

import { EL_EMPTY } from './types'

export type RenderMode = 'normal' | 'thermal'

// Check OffscreenCanvas support
const hasOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'

export class CanvasRenderer {
  private ctx: CanvasRenderingContext2D  // Screen (visible)
  
  // Virtual buffer (Offscreen) - use OffscreenCanvas if available
  private bufferCanvas: HTMLCanvasElement | OffscreenCanvas
  private bufferCtx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D
  private imageData: ImageData
  private pixels: Uint8ClampedArray
  private pixels32: Uint32Array  // View over pixels for fast fill
  
  private width: number
  private height: number
  private mode: RenderMode = 'normal'

  // Camera state
  private zoom: number = 1
  private panX: number = 0
  private panY: number = 0
  
  // Background color as packed ABGR (for Uint32Array)
  // 0xFF0A0A0A = alpha=255, r=10, g=10, b=10
  private readonly BG_COLOR_32 = 0xFF0A0A0A
  private readonly BG_R = 10
  private readonly BG_G = 10
  private readonly BG_B = 10
  
  // Phase 3: Smart Rendering (Dirty Rectangles)
  private static readonly CHUNK_SIZE = 32
  private chunkImageData: ImageData

  constructor(ctx: CanvasRenderingContext2D, width: number, height: number) {
    this.ctx = ctx
    this.width = width
    this.height = height

    // 1. Create offscreen buffer - prefer OffscreenCanvas for better performance
    if (hasOffscreenCanvas) {
      this.bufferCanvas = new OffscreenCanvas(width, height)
      const bCtx = this.bufferCanvas.getContext('2d', { alpha: false })
      if (!bCtx) throw new Error('Failed to create OffscreenCanvas context')
      this.bufferCtx = bCtx
    } else {
      this.bufferCanvas = document.createElement('canvas')
      this.bufferCanvas.width = width
      this.bufferCanvas.height = height
      const bCtx = this.bufferCanvas.getContext('2d', { alpha: false })
      if (!bCtx) throw new Error('Failed to create buffer context')
      this.bufferCtx = bCtx
    }

    // 2. Pixels are tied to buffer
    this.imageData = this.bufferCtx.createImageData(width, height)
    this.pixels = this.imageData.data
    // Create Uint32 view over the same buffer for fast operations
    this.pixels32 = new Uint32Array(this.pixels.buffer)
    
    // Pixel-art rendering (no smoothing on zoom)
    this.ctx.imageSmoothingEnabled = false
    
    // Phase 3: Create chunk ImageData once (32x32)
    this.chunkImageData = new ImageData(CanvasRenderer.CHUNK_SIZE, CanvasRenderer.CHUNK_SIZE)
    
    this.clearPixels()
  }

  // Camera control from outside
  setTransform(zoom: number, panX: number, panY: number): void {
    this.zoom = zoom
    this.panX = panX
    this.panY = panY
  }

  resize(width: number, height: number): void {
    this.width = width
    this.height = height
    
    // Resize buffer (works for both HTMLCanvasElement and OffscreenCanvas)
    this.bufferCanvas.width = width
    this.bufferCanvas.height = height
    this.imageData = this.bufferCtx.createImageData(width, height)
    this.pixels = this.imageData.data
    this.pixels32 = new Uint32Array(this.pixels.buffer)
    
    // Re-disable smoothing after resize
    this.ctx.imageSmoothingEnabled = false
    
    this.clearPixels()
  }

  setMode(mode: RenderMode): void {
    this.mode = mode
  }

  getMode(): RenderMode {
    return this.mode
  }

  // OPTIMIZED: Use Uint32Array.fill() - 50-100x faster than loop!
  private clearPixels(): void {
    this.pixels32.fill(this.BG_COLOR_32)
  }

  // NEW API: Accept TypedArrays directly
  render(types: Uint8Array, colors: Uint32Array, temperatureData?: Float32Array): void {
    // 1. Render pixels to BUFFER
    if (this.mode === 'thermal' && temperatureData) {
      this.renderThermal(temperatureData)
    } else {
      this.renderNormalTyped(types, colors)
    }

    // Put pixels to buffer context
    this.bufferCtx.putImageData(this.imageData, 0, 0)

    // 2. Draw BUFFER to SCREEN with camera transform
    // Clear screen with background
    this.ctx.fillStyle = `rgb(${this.BG_R}, ${this.BG_G}, ${this.BG_B})`
    this.ctx.fillRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height)
    
    this.ctx.save()
    // Match WebGL transform: scale around viewport center, then apply screen-space pan
    const centerX = this.ctx.canvas.width / 2
    const centerY = this.ctx.canvas.height / 2
    this.ctx.translate(centerX + this.panX, centerY + this.panY)
    this.ctx.scale(this.zoom, this.zoom)
    this.ctx.translate(-centerX, -centerY)
    
    // Draw buffer image
    this.ctx.drawImage(this.bufferCanvas, 0, 0)
    
    // 3. Draw world border (neon glow effect)
    this.drawWorldBorder()
    
    this.ctx.restore()
  }

  /**
   * Draw a stylish border around the simulation world
   * Creates a neon glow effect with gradient
   */
  private drawWorldBorder(): void {
    const ctx = this.ctx
    const w = this.width
    const h = this.height
    
    // Outer glow (wider, more transparent)
    ctx.strokeStyle = 'rgba(59, 130, 246, 0.3)' // Blue glow
    ctx.lineWidth = 6 / this.zoom // Compensate for zoom
    ctx.strokeRect(-3 / this.zoom, -3 / this.zoom, w + 6 / this.zoom, h + 6 / this.zoom)
    
    // Middle glow
    ctx.strokeStyle = 'rgba(59, 130, 246, 0.5)'
    ctx.lineWidth = 3 / this.zoom
    ctx.strokeRect(-1.5 / this.zoom, -1.5 / this.zoom, w + 3 / this.zoom, h + 3 / this.zoom)
    
    // Inner sharp border
    ctx.strokeStyle = 'rgba(59, 130, 246, 0.8)'
    ctx.lineWidth = 1 / this.zoom
    ctx.strokeRect(0, 0, w, h)
    
    // Corner accents (bright dots)
    const cornerSize = 8 / this.zoom
    ctx.fillStyle = '#3B82F6'
    
    // Top-left
    ctx.fillRect(-cornerSize / 2, -cornerSize / 2, cornerSize, 2 / this.zoom)
    ctx.fillRect(-cornerSize / 2, -cornerSize / 2, 2 / this.zoom, cornerSize)
    
    // Top-right
    ctx.fillRect(w - cornerSize / 2, -cornerSize / 2, cornerSize, 2 / this.zoom)
    ctx.fillRect(w - 2 / this.zoom + cornerSize / 2, -cornerSize / 2, 2 / this.zoom, cornerSize)
    
    // Bottom-left
    ctx.fillRect(-cornerSize / 2, h - 2 / this.zoom + cornerSize / 2, cornerSize, 2 / this.zoom)
    ctx.fillRect(-cornerSize / 2, h - cornerSize / 2, 2 / this.zoom, cornerSize)
    
    // Bottom-right
    ctx.fillRect(w - cornerSize / 2, h - 2 / this.zoom + cornerSize / 2, cornerSize, 2 / this.zoom)
    ctx.fillRect(w - 2 / this.zoom + cornerSize / 2, h - cornerSize / 2, 2 / this.zoom, cornerSize)
  }

  /**
   * Phase 5: ULTRA-OPTIMIZED direct copy from WASM memory!
   * WASM now returns ABGR format - direct copy with pixels32.set()
   * ~3-5x faster than byte-by-byte unpacking
   */
  private renderNormalTyped(types: Uint8Array, colors: Uint32Array): void {
    const pixels32 = this.pixels32
    const len = Math.min(types.length, this.width * this.height)
    
    // Fast path: Direct copy all colors (WASM provides ABGR format)
    // Background is already correct format, just set everything!
    pixels32.set(colors.subarray(0, len))
    
    // Fix empty cells to background color (particles have correct colors)
    // This is still fast because most cells are particles in active simulations
    for (let i = 0; i < len; i++) {
      if (types[i] === EL_EMPTY) {
        pixels32[i] = this.BG_COLOR_32
      }
    }
  }

  /**
   * Render thermal vision - temperature to color gradient
   */
  private renderThermal(temps: Float32Array): void {
    const pixels = this.pixels
    const len = Math.min(temps.length, this.width * this.height)

    for (let i = 0; i < len; i++) {
      const temp = temps[i]
      const base = i << 2
      
      const [r, g, b] = this.getThermalColor(temp)
      
      pixels[base] = r
      pixels[base + 1] = g
      pixels[base + 2] = b
      pixels[base + 3] = 255
    }
  }

  /**
   * Temperature to color gradient:
   * Blue (-20) -> Cyan (0) -> Green (20) -> Yellow (100) -> Red (500) -> White (1000)
   */
  private getThermalColor(t: number): [number, number, number] {
    // Freezing: Deep Blue to Blue
    if (t < 0) {
      const intensity = Math.min(1, Math.abs(t) / 30)
      return [0, 0, Math.floor(128 + 127 * intensity)]
    }
    
    // Cold: Blue to Cyan (0-20)
    if (t < 20) {
      const ratio = t / 20
      return [0, Math.floor(ratio * 255), 255]
    }
    
    // Ambient: Cyan to Green (20-50)
    if (t < 50) {
      const ratio = (t - 20) / 30
      return [0, 255, Math.floor(255 * (1 - ratio))]
    }
    
    // Warm: Green to Yellow (50-100)
    if (t < 100) {
      const ratio = (t - 50) / 50
      return [Math.floor(255 * ratio), 255, 0]
    }
    
    // Hot: Yellow to Red (100-500)
    if (t < 500) {
      const ratio = (t - 100) / 400
      return [255, Math.floor(255 * (1 - ratio)), 0]
    }
    
    // Extreme: Red to White (500-1000+)
    const ratio = Math.min(1, (t - 500) / 500)
    return [255, Math.floor(255 * ratio), Math.floor(255 * ratio)]
  }
  
  // === PHASE 3: SMART RENDERING (Dirty Rectangles) ===
  
  /**
   * Smart render - only update dirty chunks
   * Massive performance improvement when most of the screen is static
   */
  renderSmart(
    engine: { 
      getDirtyChunksCount: () => number
      getDirtyListPtr: () => number
      extractChunkPixels: (idx: number) => number
      getChunksX: () => number
      render: () => void
    },
    memory: WebAssembly.Memory
  ): void {
    // 1. Ask Rust: how many chunks changed?
    const count = engine.getDirtyChunksCount()
    
    // Heuristic: If >70% of chunks changed, full render is faster
    const totalChunks = Math.ceil(this.width / CanvasRenderer.CHUNK_SIZE) * 
                        Math.ceil(this.height / CanvasRenderer.CHUNK_SIZE)
    
    if (count > totalChunks * 0.7) {
      // Fallback to full render
      engine.render()
      return
    }
    
    if (count === 0) {
      // Nothing changed, just redraw buffer to screen (for zoom/pan)
      this.drawBufferToScreen()
      return
    }
    
    // 2. Get dirty chunk list (zero-copy view into WASM memory)
    const listPtr = engine.getDirtyListPtr()
    const dirtyIds = new Uint32Array(memory.buffer, listPtr, count)
    
    const chunksX = engine.getChunksX()
    const CHUNK_SIZE = CanvasRenderer.CHUNK_SIZE
    
    // 3. Process each dirty chunk
    for (let i = 0; i < count; i++) {
      const chunkIdx = dirtyIds[i]
      
      // Ask Rust to copy chunk pixels to transfer buffer
      const pixelsPtr = engine.extractChunkPixels(chunkIdx)
      
      // Create view into chunk pixels (4096 bytes = 32*32*4)
      const chunkPixels = new Uint8ClampedArray(memory.buffer, pixelsPtr, 4096)
      
      // Copy to ImageData
      this.chunkImageData.data.set(chunkPixels)
      
      // Calculate screen position
      const cx = chunkIdx % chunksX
      const cy = Math.floor(chunkIdx / chunksX)
      const x = cx * CHUNK_SIZE
      const y = cy * CHUNK_SIZE
      
      // Stamp chunk to buffer
      this.bufferCtx.putImageData(this.chunkImageData, x, y)
    }
    
    // 4. Draw buffer to screen with camera transform
    this.drawBufferToScreen()
  }
  
  /**
   * Draw buffer canvas to screen with camera transform
   */
  private drawBufferToScreen(): void {
    // Clear screen with background
    this.ctx.fillStyle = `rgb(${this.BG_R}, ${this.BG_G}, ${this.BG_B})`
    this.ctx.fillRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height)
    
    this.ctx.save()
    // Apply Pan then Zoom
    this.ctx.translate(this.panX, this.panY)
    this.ctx.scale(this.zoom, this.zoom)
    
    // Draw buffer image
    this.ctx.drawImage(this.bufferCanvas, 0, 0)
    
    // Draw world border
    this.drawWorldBorder()
    
    this.ctx.restore()
  }
}

--- End of File: apps/web/src/lib/engine/Renderer.ts ---


--- File: apps/web/src/lib/engine/SimulationController.ts ---

/**
 * SimulationController
 *
 * Unified faÃ§ade that routes simulation commands to the active runtime:
 * - WorkerBridge (preferred)
 * - WasmParticleEngine fallback (main thread)
 *
 * UI/store should call these helpers instead of touching engine/worker directly.
 */
import { getBridge, getEngine } from '@/components/Canvas'
import type { RenderMode } from './types'

function getTarget() {
  return getBridge() ?? getEngine()
}

export function play(): void {
  const bridge = getBridge()
  bridge?.play()
}

export function pause(): void {
  const bridge = getBridge()
  bridge?.pause()
}

export function step(): void {
  const bridge = getBridge()
  if (bridge) {
    // Worker single-step
    bridge.step()
  } else {
    // Fallback engine single-step
    getEngine()?.step()
  }
}

export function reset(): void {
  const target = getTarget()
  target?.clear?.()
}

export function setRenderMode(mode: RenderMode): void {
  const bridge = getBridge()
  if (bridge) {
    bridge.setRenderMode(mode)
  } else {
    getEngine()?.setRenderMode(mode)
  }
}

export function setGravity(gravity: { x: number; y: number }): void {
  const bridge = getBridge()
  if (bridge) {
    bridge.setSettings({ gravity })
  } else {
    getEngine()?.setSettings?.({ gravity })
  }
}

export function setAmbientTemperature(ambientTemperature: number): void {
  const bridge = getBridge()
  if (bridge) {
    bridge.setSettings({ ambientTemperature })
  } else {
    getEngine()?.setSettings?.({ ambientTemperature })
  }
}

export function setSpeed(speed: number): void {
  const bridge = getBridge()
  if (bridge) {
    bridge.setSettings({ speed })
  }
}

// === Snapshots ===
let lastSnapshot: ArrayBuffer | null = null
const history: ArrayBuffer[] = []
let historyIndex = -1
const HISTORY_LIMIT = 20

async function getCurrentSnapshot(): Promise<ArrayBuffer | null> {
  const bridge = getBridge()
  if (bridge) {
    const buffer = await bridge.saveSnapshot() as ArrayBuffer | null
    if (!buffer) return null
    let out: ArrayBuffer
    if (buffer instanceof ArrayBuffer) {
      out = buffer.slice(0)
    } else {
      const view = new Uint8Array(buffer as ArrayBuffer)
      const copy = new Uint8Array(view)
      out = copy.buffer
    } 
    return out
  }
  const engine = getEngine()
  if (engine) {
    const snap = engine.saveSnapshot()
    if (!snap) return null
    const copy = new Uint8Array(snap)
    return copy.buffer
  }
  return null
}

export async function saveSnapshot(): Promise<void> {
  const buffer = await getCurrentSnapshot()
  lastSnapshot = buffer ?? null
  if (buffer) {
    // push into history
    if (historyIndex < history.length - 1) history.splice(historyIndex + 1)
    history.push(buffer.slice(0))
    if (history.length > HISTORY_LIMIT) {
      history.shift()
    }
    historyIndex = history.length - 1
  }
}

export function loadSnapshot(): void {
  if (!lastSnapshot) return
  const bridge = getBridge()
  if (bridge) {
    bridge.loadSnapshot(lastSnapshot.slice(0))
    return
  }
  const engine = getEngine()
  if (engine) {
    engine.loadSnapshot(new Uint8Array(lastSnapshot))
  }
}

export async function captureSnapshotForUndo(): Promise<void> {
  const buffer = await getCurrentSnapshot()
  if (!buffer) return
  if (historyIndex < history.length - 1) {
    history.splice(historyIndex + 1)
  }
  history.push(buffer.slice(0))
  if (history.length > HISTORY_LIMIT) {
    history.shift()
  }
  historyIndex = history.length - 1
}

export function undo(): void {
  if (historyIndex <= 0) return
  historyIndex -= 1
  const buffer = history[historyIndex]
  lastSnapshot = buffer
  loadSnapshot()
}

export function redo(): void {
  if (historyIndex >= history.length - 1) return
  historyIndex += 1
  const buffer = history[historyIndex]
  lastSnapshot = buffer
  loadSnapshot()
}

--- End of File: apps/web/src/lib/engine/SimulationController.ts ---


--- File: apps/web/src/lib/engine/WasmParticleEngine.ts ---

/**
 * WasmParticleEngine - WASM-powered particle simulation
 * 
 * Phase 3: Maximum performance with Rust + WebAssembly
 * 
 * The simulation runs entirely in WASM. JS only handles:
 * - Initialization
 * - User input (add/remove particles)
 * - Rendering (reading from WASM memory)
 */

import { CanvasRenderer, RenderMode } from './Renderer'
import { ElementType } from './types'

// Element name to WASM ID mapping
const ELEMENT_TO_WASM_ID: Record<ElementType, number> = {
  'empty': 0,
  'stone': 1,
  'sand': 2,
  'wood': 3,
  'metal': 4,
  'ice': 5,
  'water': 6,
  'oil': 7,
  'lava': 8,
  'acid': 9,
  'steam': 10,
  'smoke': 11,
  'fire': 12,
  'spark': 13,
  'electricity': 14,
  'gunpowder': 15,
  'clone': 16,
  'void': 17,
  'dirt': 18,
  'seed': 19,
  'plant': 20,
}

// WASM module type (will be loaded dynamically)
interface WasmModule {
  init: () => void
  version: () => string
  World: new (width: number, height: number) => WasmWorld
}

interface WasmWorld {
  width: number
  height: number
  particle_count: number
  frame: bigint
  set_gravity: (x: number, y: number) => void
  set_ambient_temperature: (temp: number) => void
  add_particle: (x: number, y: number, element: number) => boolean
  add_particles_in_radius: (cx: number, cy: number, radius: number, element: number) => void
  remove_particle: (x: number, y: number) => boolean
  remove_particles_in_radius: (cx: number, cy: number, radius: number) => void
  clear: () => void
  step: () => void
  step_with_dt: (dt: number) => void
  types_ptr: () => number
  colors_ptr: () => number
  types_len: () => number
  colors_len: () => number
  temperature_ptr: () => number
  temperature_len: () => number
  // Phase 3: Smart Rendering
  collect_dirty_chunks: () => number
  get_dirty_list_ptr: () => number
  extract_chunk_pixels: (chunkIdx: number) => number
  chunks_x: () => number
  chunks_y: () => number
  // Rigid Bodies
  spawn_rigid_body: (x: number, y: number, w: number, h: number, element_id: number) => number
  spawn_rigid_circle: (x: number, y: number, radius: number, element_id: number) => number
  remove_rigid_body: (id: number) => void
  rigid_body_count: () => number
}

let wasmModule: WasmModule | null = null
let wasmMemory: WebAssembly.Memory | null = null

/**
 * Load WASM module
 */
export async function loadWasmEngine(): Promise<WasmModule> {
  if (wasmModule) return wasmModule
  
  try {
    // Dynamic import of WASM package
    // @ts-ignore - WASM module loaded dynamically
    const wasm = await import('@particula/engine-wasm/particula_engine')
    
    // Initialize WASM and get exports (including memory!)
    const wasmExports = await wasm.default()
    
    // Memory is in the exports returned by init
    wasmMemory = wasmExports.memory
    
    if (!wasmMemory) {
      console.error('WASM memory not found in exports:', Object.keys(wasmExports))
      throw new Error('WASM memory not available')
    }
    
    wasmModule = wasm as unknown as WasmModule
    wasmModule.init()
    
    console.log(`ðŸ¦€ WASM Engine loaded, version: ${wasmModule.version()}`)
    console.log(`ðŸ¦€ WASM memory size: ${wasmMemory.buffer.byteLength} bytes`)
    return wasmModule
  } catch (err) {
    console.error('Failed to load WASM engine:', err)
    throw err
  }
}

/**
 * Check if WASM is available
 */
export function isWasmAvailable(): boolean {
  return typeof WebAssembly !== 'undefined'
}

export class WasmParticleEngine {
  private world: WasmWorld
  private renderer: CanvasRenderer | null = null
  private wasm: WasmModule
  
  private _width: number
  private _height: number
  
  // TypedArray views into WASM memory (updated each frame)
  private typesView: Uint8Array | null = null
  private colorsView: Uint32Array | null = null
  private temperatureView: Float32Array | null = null
  
  // Prevent recursive WASM calls
  private _isBusy: boolean = false
  
  private constructor(wasm: WasmModule, width: number, height: number) {
    this.wasm = wasm
    this._width = width
    this._height = height
    this.world = new wasm.World(width, height)
    this.updateMemoryViews()
  }
  
  /**
   * Create WasmParticleEngine (async factory)
   */
  static async create(width: number, height: number): Promise<WasmParticleEngine> {
    const wasm = await loadWasmEngine()
    return new WasmParticleEngine(wasm, width, height)
  }
  
  /**
   * Update TypedArray views into WASM memory
   */
  private updateMemoryViews(): void {
    if (!wasmMemory) return
    
    const typesPtr = this.world.types_ptr()
    const colorsPtr = this.world.colors_ptr()
    const tempPtr = this.world.temperature_ptr()
    const size = this.world.types_len()
    
    this.typesView = new Uint8Array(wasmMemory.buffer, typesPtr, size)
    this.colorsView = new Uint32Array(wasmMemory.buffer, colorsPtr, size)
    this.temperatureView = new Float32Array(wasmMemory.buffer, tempPtr, size)
  }
  
  // === Public API ===
  
  get width(): number { return this._width }
  get height(): number { return this._height }
  get particleCount(): number { return this.world.particle_count }
  get frame(): number { return Number(this.world.frame) }
  
  attachRenderer(ctx: CanvasRenderingContext2D): void {
    this.renderer = new CanvasRenderer(ctx, this._width, this._height)
  }
  
  setSettings(settings: { gravity?: { x: number; y: number }; ambientTemperature?: number }): void {
    if (settings.gravity) {
      this.world.set_gravity(settings.gravity.x, settings.gravity.y)
    }
    if (settings.ambientTemperature !== undefined) {
      this.world.set_ambient_temperature(settings.ambientTemperature)
    }
  }
  
  addParticle(x: number, y: number, element: ElementType): boolean {
    if (this._isBusy) return false
    const wasmId = ELEMENT_TO_WASM_ID[element] ?? 0
    if (wasmId === 0) return false  // Don't add empty
    return this.world.add_particle(Math.floor(x), Math.floor(y), wasmId)
  }
  
  addParticlesInRadius(cx: number, cy: number, radius: number, element: ElementType): void {
    if (this._isBusy) return
    const wasmId = ELEMENT_TO_WASM_ID[element] ?? 0
    if (wasmId === 0) return  // Don't add empty
    this.world.add_particles_in_radius(Math.floor(cx), Math.floor(cy), Math.floor(radius), wasmId)
  }
  
  removeParticle(x: number, y: number): boolean {
    if (this._isBusy) return false
    return this.world.remove_particle(Math.floor(x), Math.floor(y))
  }
  
  removeParticlesInRadius(cx: number, cy: number, radius: number): void {
    if (this._isBusy) return
    this.world.remove_particles_in_radius(Math.floor(cx), Math.floor(cy), Math.floor(radius))
  }
  
  // === Rigid Body Methods ===
  
  /** Spawn a rectangular rigid body */
  spawnRigidBody(x: number, y: number, w: number, h: number, element: ElementType): number {
    if (this._isBusy) return 0
    const wasmId = ELEMENT_TO_WASM_ID[element] ?? 1 // Default to stone
    return this.world.spawn_rigid_body(Math.floor(x), Math.floor(y), Math.floor(w), Math.floor(h), wasmId)
  }
  
  /** Spawn a circular rigid body */
  spawnRigidCircle(x: number, y: number, radius: number, element: ElementType): number {
    if (this._isBusy) return 0
    const wasmId = ELEMENT_TO_WASM_ID[element] ?? 1 // Default to stone
    return this.world.spawn_rigid_circle(Math.floor(x), Math.floor(y), Math.floor(radius), wasmId)
  }
  
  /** Remove a rigid body by ID */
  removeRigidBody(id: number): void {
    if (this._isBusy) return
    this.world.remove_rigid_body(id)
  }
  
  /** Get number of rigid bodies */
  get rigidBodyCount(): number {
    return this.world.rigid_body_count()
  }

  /** Flood fill contiguous area of the same element */
  floodFill(cx: number, cy: number, element: ElementType): void {
    if (!this.typesView || !wasmMemory) return
    const width = this._width
    const height = this._height
    if (cx < 0 || cy < 0 || cx >= width || cy >= height) return
    const targetId = ELEMENT_TO_WASM_ID[element] ?? 0
    const types = this.typesView
    const idx = cy * width + cx
    const sourceId = types[idx] ?? 0
    if (sourceId === targetId) return
    const visited = new Uint8Array(width * height)
    const stack: Array<{ x: number; y: number }> = [{ x: cx, y: cy }]
    let processed = 0
    const LIMIT = 200_000

    while (stack.length > 0) {
      const { x, y } = stack.pop() as { x: number; y: number }
      if (x < 0 || y < 0 || x >= width || y >= height) continue
      const i = y * width + x
      if (visited[i]) continue
      if (types[i] !== sourceId) continue
      visited[i] = 1
      processed++
      if (processed > LIMIT) break

      if (targetId === 0) {
        this.world.remove_particle(x, y)
      } else {
        this.world.remove_particle(x, y)
        this.world.add_particle(x, y, targetId)
      }

      stack.push({ x: x + 1, y })
      stack.push({ x: x - 1, y })
      stack.push({ x, y: y + 1 })
      stack.push({ x, y: y - 1 })
    }

    // Memory views might change if world resized
    this.updateMemoryViews()
  }
  
  clear(): void {
    if (this._isBusy) return
    this.world.clear()
  }
  
  stepWithDt(dtSeconds: number): void {
    if (this._isBusy) return
    this._isBusy = true
    try {
      this.world.step_with_dt(dtSeconds)
      // Memory views may need to be refreshed if WASM memory grew
      this.updateMemoryViews()
    } finally {
      this._isBusy = false
    }
  }
  
  step(): void {
    // Backwards compatibility: single fixed tick at 60 FPS baseline
    this.stepWithDt(1 / 60)
  }
  
  render(): void {
    if (!this.renderer || !this.typesView || !this.colorsView) return
    
    // Render directly from WASM memory - zero copy!
    // Pass temperature for thermal view mode
    this.renderer.render(this.typesView, this.colorsView, this.temperatureView ?? undefined)
  }
  
  /** Snapshot world types (Uint8Array copy) */
  saveSnapshot(): Uint8Array | null {
    if (!this.typesView) return null
    return new Uint8Array(this.typesView)
  }
  
  /** Load snapshot (types only) */
  loadSnapshot(types: Uint8Array): void {
    const expected = this._width * this._height
    if (types.length !== expected) {
      console.warn('Snapshot size mismatch, skipping load')
      return
    }
    // Clear world then reapply particles
    this.world = new this.wasm.World(this._width, this._height)
    this.updateMemoryViews()
    for (let i = 0; i < types.length; i++) {
      const id = types[i]
      if (id === 0) continue
      const x = i % this._width
      const y = Math.floor(i / this._width)
      this.world.add_particle(x, y, id)
    }
    this.updateMemoryViews()
  }
  
  // === Phase 3: Smart Rendering API ===
  
  /** Get WASM memory for zero-copy access */
  get memory(): WebAssembly.Memory | null {
    return wasmMemory
  }
  
  /** Get the renderer instance */
  getRenderer(): CanvasRenderer | null {
    return this.renderer
  }
  
  /** Collect dirty chunks and return count */
  getDirtyChunksCount(): number {
    return this.world.collect_dirty_chunks()
  }
  
  /** Get pointer to dirty chunk list */
  getDirtyListPtr(): number {
    return this.world.get_dirty_list_ptr()
  }
  
  /** Extract chunk pixels to transfer buffer, returns pointer */
  extractChunkPixels(chunkIdx: number): number {
    return this.world.extract_chunk_pixels(chunkIdx)
  }
  
  /** Get chunks X count */
  getChunksX(): number {
    return this.world.chunks_x()
  }
  
  /** Get chunks Y count */
  getChunksY(): number {
    return this.world.chunks_y()
  }
  
  /** Get total chunks count */
  getTotalChunks(): number {
    return this.world.chunks_x() * this.world.chunks_y()
  }
  
  setRenderMode(mode: RenderMode): void {
    this.renderer?.setMode(mode)
  }
  
  getRenderMode(): RenderMode {
    return this.renderer?.getMode() ?? 'normal'
  }
  
  setTransform(zoom: number, panX: number, panY: number): void {
    this.renderer?.setTransform(zoom, panX, panY)
  }
  
  resize(width: number, height: number): void {
    // Create new world with new dimensions
    this._width = width
    this._height = height
    this.world = new this.wasm.World(width, height)
    this.updateMemoryViews()
    this.renderer?.resize(width, height)
  }
  
  destroy(): void {
    // WASM world will be garbage collected
  }

  /** Read element id at world coordinate */
  getElementAt(x: number, y: number): number {
    if (!this.typesView) return 0
    if (x < 0 || y < 0 || x >= this._width || y >= this._height) return 0
    return this.typesView[y * this._width + x] ?? 0
  }
}

--- End of File: apps/web/src/lib/engine/WasmParticleEngine.ts ---


--- File: apps/web/src/lib/engine/WebGLRenderer.ts ---

/**
 * WebGLRenderer - Production Grade
 * 
 * Phase 3: WebGL Revolution + Border Rendering
 * Phase 2: GPU Batching with Merged Rectangles + PBO
 * 
 * Features:
 * - Zero-copy upload (WASM -> GPU via texSubImage2D)
 * - Hardware accelerated Zoom & Pan (Vertex Shader)
 * - Dirty Rectangles support (only upload changed chunks)
 * - PHASE 2: Merged rectangle batching (fewer GPU calls)
 * - PHASE 2: PBO double-buffering for async upload
 * - Neon Border rendering (Line Shader)
 */

const CHUNK_SIZE = 32;

// Phase 2: Use merged rectangles for batching
const USE_MERGED_RECTS = true;

// Phase 2: PBO for async texture upload (WebGL 2.0)
const USE_PBO = true;

export class WebGLRenderer {
  private gl: WebGL2RenderingContext;
  private forceFullUpload: boolean = false;
  
  // Phase 5: Context loss handling
  private contextLost: boolean = false;
  
  // === Texture Pass (World) ===
  private texProgram: WebGLProgram;
  private texture: WebGLTexture;
  private quadBuffer: WebGLBuffer;
  private uTexTransform: WebGLUniformLocation | null = null;
  private uTexWorldSize: WebGLUniformLocation | null = null;
  private uTexViewportSize: WebGLUniformLocation | null = null;
  
  // === Border Pass (Lines) ===
  private lineProgram: WebGLProgram;
  private lineBuffer: WebGLBuffer;
  private uLineTransform: WebGLUniformLocation | null = null;
  private uLineWorldSize: WebGLUniformLocation | null = null;
  private uLineViewportSize: WebGLUniformLocation | null = null;
  private uLineColor: WebGLUniformLocation | null = null;
  
  // Memory view (reused)
  private memoryView: Uint8Array | null = null;
  
  // === PHASE 2: PBO Double-Buffering ===
  private pbo: [WebGLBuffer | null, WebGLBuffer | null] = [null, null];
  private pboIndex: number = 0; // Current PBO being uploaded to
  private pboSize: number = 0;  // Size of PBO in bytes
  private usePBO: boolean = false;
  
  // Dimensions (MUST be integers!)
  private worldWidth: number;
  private worldHeight: number;
  private viewportWidth: number;
  private viewportHeight: number;

  constructor(canvas: OffscreenCanvas, worldWidth: number, worldHeight: number) {
    // CRITICAL: Force integer sizes to prevent "falling through" bug
    this.worldWidth = Math.floor(worldWidth);
    this.worldHeight = Math.floor(worldHeight);
    this.viewportWidth = canvas.width;
    this.viewportHeight = canvas.height;
    
    // Phase 5: Setup context loss handlers
    this.setupContextLossHandlers(canvas);

    const gl = canvas.getContext('webgl2', {
      alpha: false,
      desynchronized: true,
      powerPreference: 'high-performance',
      antialias: false
    });

    if (!gl) throw new Error('WebGL 2 not supported');
    this.gl = gl;

    // Enable blending for border glow
    this.gl.enable(this.gl.BLEND);
    this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);

    // === Setup Texture Shader ===
    this.texProgram = this.createProgram(TEX_VERTEX_SHADER, TEX_FRAGMENT_SHADER);
    this.quadBuffer = this.createQuadBuffer();

    // Setup Texture
    const tex = this.gl.createTexture();
    if (!tex) throw new Error('Failed to create texture');
    this.texture = tex;
    
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);

    this.gl.texImage2D(
      this.gl.TEXTURE_2D, 0, this.gl.RGBA, 
      this.worldWidth, this.worldHeight, 0, 
      this.gl.RGBA, this.gl.UNSIGNED_BYTE, null
    );

    this.uTexTransform = this.gl.getUniformLocation(this.texProgram, 'u_transform');
    this.uTexWorldSize = this.gl.getUniformLocation(this.texProgram, 'u_worldSize');
    this.uTexViewportSize = this.gl.getUniformLocation(this.texProgram, 'u_viewportSize');

    // === Setup Line Shader (Border) ===
    this.lineProgram = this.createProgram(LINE_VERTEX_SHADER, LINE_FRAGMENT_SHADER);
    this.lineBuffer = this.createBorderBuffer();
    
    this.uLineTransform = this.gl.getUniformLocation(this.lineProgram, 'u_transform');
    this.uLineWorldSize = this.gl.getUniformLocation(this.lineProgram, 'u_worldSize');
    this.uLineViewportSize = this.gl.getUniformLocation(this.lineProgram, 'u_viewportSize');
    this.uLineColor = this.gl.getUniformLocation(this.lineProgram, 'u_color');
    
    // === PHASE 2: Setup PBO Double-Buffering ===
    if (USE_PBO) {
      this.initPBO();
    }
    
    console.log(`ðŸŽ® WebGLRenderer: ${this.worldWidth}x${this.worldHeight} world, WebGL2 + Border${this.usePBO ? ' + PBO' : ''}`);
  }
  
  /**
   * PHASE 2: Initialize PBO double-buffer for async texture upload
   */
  private initPBO(): void {
    const gl = this.gl;
    
    // PBO size = world pixels * 4 bytes (RGBA)
    this.pboSize = this.worldWidth * this.worldHeight * 4;
    
    try {
      // Create two PBOs for double-buffering
      this.pbo[0] = gl.createBuffer();
      this.pbo[1] = gl.createBuffer();
      
      if (!this.pbo[0] || !this.pbo[1]) {
        console.warn('Failed to create PBOs, falling back to direct upload');
        return;
      }
      
      // Initialize both PBOs with empty data
      for (let i = 0; i < 2; i++) {
        gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, this.pbo[i]);
        gl.bufferData(gl.PIXEL_UNPACK_BUFFER, this.pboSize, gl.STREAM_DRAW);
      }
      
      // Unbind PBO
      gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, null);
      
      this.usePBO = true;
      console.log(`ðŸ“¦ PBO initialized: 2x ${(this.pboSize / 1024 / 1024).toFixed(2)}MB`);
    } catch (e) {
      console.warn('PBO init failed:', e);
      this.usePBO = false;
    }
  }

  /**
   * Phase 5: Setup WebGL context loss handlers
   * 
   * Context loss can happen when:
   * - GPU driver crashes
   * - Tab is in background too long (browser reclaims GPU resources)
   * - Switching between integrated/discrete GPU
   */
  private setupContextLossHandlers(canvas: OffscreenCanvas): void {
    // Note: OffscreenCanvas uses different event names
    canvas.addEventListener('webglcontextlost', ((e: Event) => {
      e.preventDefault();
      console.warn('âš ï¸ WebGL context lost');
      this.contextLost = true;
    }) as EventListener);
    
    canvas.addEventListener('webglcontextrestored', (() => {
      console.log('âœ… WebGL context restored, reinitializing...');
      this.contextLost = false;
      // Note: Full reinitialization would require recreating all GL resources
      // For now, we just mark context as restored and force a full upload
      this.forceFullUpload = true;
    }) as EventListener);
  }

  /**
   * Check if WebGL context is available
   */
  get isContextLost(): boolean {
    return this.contextLost || this.gl.isContextLost();
  }

  /**
   * Render with Dirty Rectangles optimization
   */
  renderWithDirtyRects(
    engine: any,
    memory: WebAssembly.Memory,
    transform: { zoom: number; panX: number; panY: number }
  ): void {
    // Phase 5: Skip rendering if context is lost
    if (this.isContextLost) {
      return;
    }
    
    if (!this.memoryView || this.memoryView.buffer !== memory.buffer) {
      this.memoryView = new Uint8Array(memory.buffer);
    }

    // 1. Clear
    this.gl.viewport(0, 0, this.viewportWidth, this.viewportHeight);
    this.gl.clearColor(0.04, 0.04, 0.04, 1.0);
    this.gl.clear(this.gl.COLOR_BUFFER_BIT);

    // 2. Upload texture data
    this.uploadTexture(engine, memory);

    // 3. Draw World
    this.drawTexturePass(transform);

    // 4. Draw Border (Neon Style)
    this.drawBorderPass(transform);
  }

  private uploadTexture(engine: any, memory: WebAssembly.Memory): void {
    const gl = this.gl;
    gl.bindTexture(gl.TEXTURE_2D, this.texture);

    // PHASE 2: Use merged rectangles for fewer GPU calls
    if (USE_MERGED_RECTS && engine.collect_merged_rects) {
      this.uploadWithMergedRects(engine, memory);
      return;
    }

    // Fallback: Original per-chunk upload
    const dirtyCount = engine.collect_dirty_chunks();

    if (this.forceFullUpload) {
      this.uploadFull(engine);
      this.forceFullUpload = false;
      return;
    }

    if (dirtyCount === 0) return;

    const chunksX = engine.chunks_x();
    const chunksY = engine.chunks_y();
    const totalChunks = chunksX * chunksY;
    
    // Check if world size is not aligned to chunk size (has edge chunks)
    const hasEdgeChunksX = (this.worldWidth % CHUNK_SIZE) !== 0;
    const hasEdgeChunksY = (this.worldHeight % CHUNK_SIZE) !== 0;
    const hasEdgeChunks = hasEdgeChunksX || hasEdgeChunksY;

    // Heuristic: Full upload if > 40% dirty OR if we have edge chunks (to avoid black bars)
    if (dirtyCount > totalChunks * 0.4 || (hasEdgeChunks && dirtyCount > 0)) {
      this.uploadFull(engine);
    } else {
      // Upload only dirty chunks, clamping edge chunk sizes to avoid GL errors
      const dirtyListPtr = engine.get_dirty_list_ptr();
      const dirtyList = new Uint32Array(memory.buffer, dirtyListPtr, dirtyCount);

      for (let i = 0; i < dirtyCount; i++) {
        const chunkIdx = dirtyList[i];
        
        const cx = chunkIdx % chunksX;
        const cy = (chunkIdx / chunksX) | 0;

        const xOffset = cx * CHUNK_SIZE;
        const yOffset = cy * CHUNK_SIZE;
        const uploadW = Math.min(CHUNK_SIZE, this.worldWidth - xOffset);
        const uploadH = Math.min(CHUNK_SIZE, this.worldHeight - yOffset);
        if (uploadW <= 0 || uploadH <= 0) continue;
        
        const pixelsPtr = engine.extract_chunk_pixels(chunkIdx);
        
        gl.texSubImage2D(
          gl.TEXTURE_2D, 0,
          xOffset, yOffset, uploadW, uploadH,
          gl.RGBA, gl.UNSIGNED_BYTE,
          this.memoryView!, pixelsPtr
        );
      }
    }
  }

  /**
   * PHASE 2: Upload using merged rectangles
   * 
   * Instead of N calls for N dirty chunks, we merge adjacent chunks
   * and upload fewer, larger rectangles.
   */
  private uploadWithMergedRects(engine: any, _memory: WebAssembly.Memory): void {
    const gl = this.gl;
    
    // DEBUG WORKAROUND: can be enabled via env flag for diagnostics
    const DEBUG_FORCE_FULL =
      (typeof process !== 'undefined' && process.env?.VITE_FORCE_FULL_UPLOAD === 'true') ||
      (typeof import.meta !== 'undefined' && (import.meta as any).env?.VITE_FORCE_FULL_UPLOAD === 'true') ||
      false;
    if (DEBUG_FORCE_FULL) {
      this.uploadFull(engine);
      return;
    }
    
    const rectCount = engine.collect_merged_rects();
    
    if (rectCount === 0) return;
    
    // Check if world size is not aligned to chunk size
    const hasEdgeChunksX = (this.worldWidth % CHUNK_SIZE) !== 0;
    const hasEdgeChunksY = (this.worldHeight % CHUNK_SIZE) !== 0;
    const hasEdgeChunks = hasEdgeChunksX || hasEdgeChunksY;
    
    // Heuristic: if many rects, just do full upload
    // Also full upload if edge chunks to avoid black bars
    const chunksX = engine.chunks_x();
    const chunksY = engine.chunks_y();
    const totalChunks = chunksX * chunksY;
    
    if (rectCount > totalChunks * 0.3 || hasEdgeChunks) {
      this.uploadFull(engine);
      return;
    }
    
    // Upload each merged rectangle
    for (let i = 0; i < rectCount; i++) {
      const x = engine.get_merged_rect_x(i);
      const y = engine.get_merged_rect_y(i);
      const w = engine.get_merged_rect_w(i);
      const h = engine.get_merged_rect_h(i);
      
      // Skip invalid rects
      if (w === 0 || h === 0) continue;
      
      // Clamp to world bounds
      const actualW = Math.min(w, this.worldWidth - x);
      const actualH = Math.min(h, this.worldHeight - y);
      
      if (actualW <= 0 || actualH <= 0) continue;
      
      // Extract pixels for this rectangle
      const pixelsPtr = engine.extract_rect_pixels(i);
      
      // Upload to texture
      // Note: texSubImage2D expects row-major data with stride = width
      gl.texSubImage2D(
        gl.TEXTURE_2D, 0,
        x, y, actualW, actualH,
        gl.RGBA, gl.UNSIGNED_BYTE,
        this.memoryView!, pixelsPtr
      );
    }
  }
  
  /**
   * PHASE 2: Full texture upload (with optional PBO)
   */
  private uploadFull(engine: any): void {
    const gl = this.gl;
    const colorsPtr = engine.colors_ptr();
    
    if (this.usePBO && this.pbo[this.pboIndex]) {
      // PBO path: async upload
      // 1. Bind next PBO for upload
      const uploadPBO = this.pbo[this.pboIndex];
      const texturePBO = this.pbo[1 - this.pboIndex];
      
      // 2. Upload data to PBO (CPU â†’ PBO, async DMA)
      gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, uploadPBO);
      gl.bufferSubData(gl.PIXEL_UNPACK_BUFFER, 0, 
        this.memoryView!.subarray(colorsPtr, colorsPtr + this.pboSize));
      
      // 3. Upload from other PBO to texture (PBO â†’ GPU, async)
      gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, texturePBO);
      gl.texSubImage2D(
        gl.TEXTURE_2D, 0, 0, 0,
        this.worldWidth, this.worldHeight,
        gl.RGBA, gl.UNSIGNED_BYTE,
        0 // Offset in PBO
      );
      
      // 4. Unbind and swap
      gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, null);
      this.pboIndex = 1 - this.pboIndex;
    } else {
      // Direct upload (no PBO)
      gl.texSubImage2D(
        gl.TEXTURE_2D, 0, 0, 0,
        this.worldWidth, this.worldHeight,
        gl.RGBA, gl.UNSIGNED_BYTE,
        this.memoryView!, colorsPtr
      );
    }
  }

  /**
   * Request a full texture upload on next render (e.g., after mode switch)
   */
  requestFullUpload(): void {
    this.forceFullUpload = true;
  }

  private drawTexturePass(transform: { zoom: number; panX: number; panY: number }): void {
    this.gl.useProgram(this.texProgram);
    
    this.gl.uniform4f(this.uTexTransform, transform.zoom, transform.panX, transform.panY, 0);
    this.gl.uniform2f(this.uTexWorldSize, this.worldWidth, this.worldHeight);
    this.gl.uniform2f(this.uTexViewportSize, this.viewportWidth, this.viewportHeight);

    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.quadBuffer);
    const posLoc = this.gl.getAttribLocation(this.texProgram, 'a_position');
    this.gl.enableVertexAttribArray(posLoc);
    this.gl.vertexAttribPointer(posLoc, 2, this.gl.FLOAT, false, 0, 0);
    
    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
  }

  private drawBorderPass(transform: { zoom: number; panX: number; panY: number }): void {
    this.gl.useProgram(this.lineProgram);

    this.gl.uniform4f(this.uLineTransform, transform.zoom, transform.panX, transform.panY, 0);
    this.gl.uniform2f(this.uLineWorldSize, this.worldWidth, this.worldHeight);
    this.gl.uniform2f(this.uLineViewportSize, this.viewportWidth, this.viewportHeight);

    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.lineBuffer);
    const posLoc = this.gl.getAttribLocation(this.lineProgram, 'a_position');
    this.gl.enableVertexAttribArray(posLoc);
    this.gl.vertexAttribPointer(posLoc, 2, this.gl.FLOAT, false, 0, 0);

    // Outer Glow (transparent blue)
    this.gl.lineWidth(3.0);
    this.gl.uniform4f(this.uLineColor, 0.2, 0.5, 1.0, 0.4);
    this.gl.drawArrays(this.gl.LINE_LOOP, 0, 4);

    // Inner Sharp Line (bright blue)
    this.gl.lineWidth(1.0);
    this.gl.uniform4f(this.uLineColor, 0.4, 0.7, 1.0, 0.9);
    this.gl.drawArrays(this.gl.LINE_LOOP, 0, 4);
  }

  /**
   * Resize both viewport and world
   */
  resize(width: number, height: number): void {
    this.worldWidth = Math.floor(width);
    this.worldHeight = Math.floor(height);
    this.viewportWidth = this.worldWidth;
    this.viewportHeight = this.worldHeight;
    this.forceFullUpload = true;
    
    // Resize texture
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
    this.gl.texImage2D(
      this.gl.TEXTURE_2D, 0, this.gl.RGBA,
      this.worldWidth, this.worldHeight, 0,
      this.gl.RGBA, this.gl.UNSIGNED_BYTE, null
    );
    
    // Update border geometry
    this.updateBorderBuffer();
    
    console.log(`ðŸŽ® WebGLRenderer resized: ${this.worldWidth}x${this.worldHeight}`);
  }

  /**
   * Render thermal mode: upload ImageData to texture and draw
   */
  renderThermal(imageData: ImageData, transform: { zoom: number; panX: number; panY: number }): void {
    // Phase 5: Skip rendering if context is lost
    if (this.isContextLost) {
      return;
    }
    
    const gl = this.gl;
    
    // Clear with dark background
    gl.clearColor(0.04, 0.04, 0.04, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    
    // Upload thermal image data to texture
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.texSubImage2D(
      gl.TEXTURE_2D, 0, 0, 0,
      gl.RGBA, gl.UNSIGNED_BYTE,
      imageData
    );
    
    // Draw texture with transform
    this.drawTexturePass(transform);
    
    // Draw border
    this.drawBorderPass(transform);
  }

  // === Buffer Helpers ===

  private createQuadBuffer(): WebGLBuffer {
    const buffer = this.gl.createBuffer()!;
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
    const positions = new Float32Array([
      -1, -1,
       1, -1,
      -1,  1,
       1,  1,
    ]);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, positions, this.gl.STATIC_DRAW);
    return buffer;
  }

  private createBorderBuffer(): WebGLBuffer {
    const buffer = this.gl.createBuffer()!;
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
    // Border coordinates in world pixels (0,0) -> (W,0) -> (W,H) -> (0,H)
    const vertices = new Float32Array([
      0, 0,
      this.worldWidth, 0,
      this.worldWidth, this.worldHeight,
      0, this.worldHeight
    ]);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.DYNAMIC_DRAW);
    return buffer;
  }

  private updateBorderBuffer(): void {
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.lineBuffer);
    const vertices = new Float32Array([
      0, 0,
      this.worldWidth, 0,
      this.worldWidth, this.worldHeight,
      0, this.worldHeight
    ]);
    this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, vertices);

    // Recreate PBOs to match new texture size
    if (USE_PBO) {
      // Delete old PBOs
      if (this.pbo[0]) this.gl.deleteBuffer(this.pbo[0]);
      if (this.pbo[1]) this.gl.deleteBuffer(this.pbo[1]);
      this.pbo = [null, null];
      this.pboIndex = 0;
      
      this.initPBO();
    }
  }

  private createProgram(vs: string, fs: string): WebGLProgram {
    const p = this.gl.createProgram()!;
    const v = this.compileShader(this.gl.VERTEX_SHADER, vs);
    const f = this.compileShader(this.gl.FRAGMENT_SHADER, fs);
    this.gl.attachShader(p, v);
    this.gl.attachShader(p, f);
    this.gl.linkProgram(p);
    if (!this.gl.getProgramParameter(p, this.gl.LINK_STATUS)) {
      throw new Error(this.gl.getProgramInfoLog(p)!);
    }
    return p;
  }

  private compileShader(type: number, src: string): WebGLShader {
    const s = this.gl.createShader(type)!;
    this.gl.shaderSource(s, src);
    this.gl.compileShader(s);
    if (!this.gl.getShaderParameter(s, this.gl.COMPILE_STATUS)) {
      throw new Error(this.gl.getShaderInfoLog(s)!);
    }
    return s;
  }

  destroy(): void {
    this.gl.deleteTexture(this.texture);
    this.gl.deleteProgram(this.texProgram);
    this.gl.deleteProgram(this.lineProgram);
    this.gl.deleteBuffer(this.quadBuffer);
    this.gl.deleteBuffer(this.lineBuffer);
    
    // PHASE 2: Cleanup PBOs
    if (this.pbo[0]) this.gl.deleteBuffer(this.pbo[0]);
    if (this.pbo[1]) this.gl.deleteBuffer(this.pbo[1]);
  }
}

// === SHADERS ===

// Texture shader - renders world pixels
const TEX_VERTEX_SHADER = `#version 300 es
precision highp float;

in vec2 a_position;
out vec2 v_texCoord;

uniform vec4 u_transform;     // x=zoom, y=panX, z=panY
uniform vec2 u_worldSize;
uniform vec2 u_viewportSize;

void main() {
  v_texCoord = a_position * 0.5 + 0.5;
  v_texCoord.y = 1.0 - v_texCoord.y;
  
  vec2 pos = a_position;
  
  // Aspect ratio correction
  float worldAspect = u_worldSize.x / u_worldSize.y;
  float viewportAspect = u_viewportSize.x / u_viewportSize.y;
  
  if (worldAspect > viewportAspect) {
    pos.y *= viewportAspect / worldAspect;
  } else {
    pos.x *= worldAspect / viewportAspect;
  }
  
  // Transform (clip): zoom around viewport center, then apply screen-space pan
  
  // 1. Zoom FIRST (scale from origin)
  pos *= u_transform.x;
  
  // 2. Pan SECOND (translate in clip space)
  vec2 panClip = (u_transform.yz / u_viewportSize) * 2.0;
  panClip.y = -panClip.y;
  pos += panClip;
  
  gl_Position = vec4(pos, 0.0, 1.0);
}`;

// Phase 5: Fragment shader with Bloom/Glow post-processing
const TEX_FRAGMENT_SHADER = `#version 300 es
precision highp float;

in vec2 v_texCoord;
out vec4 outColor;

uniform sampler2D u_image;
uniform vec2 u_worldSize;

// Pseudo-Bloom: sample neighbors for glow effect
vec3 getBloom(vec2 uv) {
    vec3 sum = vec3(0.0);
    vec2 pixel = 1.0 / u_worldSize;
    
    // 8-direction sampling for glow
    sum += texture(u_image, uv + vec2(-pixel.x, 0.0)).rgb;
    sum += texture(u_image, uv + vec2(pixel.x, 0.0)).rgb;
    sum += texture(u_image, uv + vec2(0.0, -pixel.y)).rgb;
    sum += texture(u_image, uv + vec2(0.0, pixel.y)).rgb;
    sum += texture(u_image, uv + vec2(-pixel.x, -pixel.y)).rgb * 0.7;
    sum += texture(u_image, uv + vec2(pixel.x, -pixel.y)).rgb * 0.7;
    sum += texture(u_image, uv + vec2(-pixel.x, pixel.y)).rgb * 0.7;
    sum += texture(u_image, uv + vec2(pixel.x, pixel.y)).rgb * 0.7;
    
    return sum * 0.12; // Glow intensity
}

void main() {
    vec4 color = texture(u_image, v_texCoord);
    
    // 1. Brightness threshold - only hot pixels glow (Fire/Lava/Spark)
    // Fire is orange/red, Lava is red/yellow - high R channel
    float brightness = max(color.r, max(color.g * 0.8, color.b * 0.3));
    
    vec3 glow = vec3(0.0);
    if (brightness > 0.6) {
        glow = getBloom(v_texCoord) * (brightness - 0.5);
    }
    
    // 2. Additive blending
    vec3 finalColor = color.rgb + glow;
    
    // 3. Subtle vignette (darken edges)
    vec2 uv = v_texCoord * (1.0 - v_texCoord.yx);
    float vig = uv.x * uv.y * 20.0;
    vig = clamp(pow(vig, 0.15), 0.6, 1.0);
    finalColor *= vig;
    
    // 4. Tone mapping (Reinhard) - prevents oversaturation
    finalColor = finalColor / (finalColor + vec3(1.0));
    
    // 5. Slight contrast boost
    finalColor = pow(finalColor, vec3(0.95));
    
    outColor = vec4(finalColor, color.a);
}`;

// Line shader - renders border
const LINE_VERTEX_SHADER = `#version 300 es
precision highp float;

in vec2 a_position;  // In world pixels

uniform vec4 u_transform;
uniform vec2 u_worldSize;
uniform vec2 u_viewportSize;

void main() {
  // Convert world pixels to normalized (0..1)
  vec2 norm = a_position / u_worldSize;
  
  // Convert to clip space (-1..1)
  vec2 clip = norm * 2.0 - 1.0;
  clip.y = -clip.y;
  
  // Aspect ratio correction (same as texture)
  float worldAspect = u_worldSize.x / u_worldSize.y;
  float viewportAspect = u_viewportSize.x / u_viewportSize.y;
  
  if (worldAspect > viewportAspect) {
    clip.y *= viewportAspect / worldAspect;
  } else {
    clip.x *= worldAspect / viewportAspect;
  }
  
  // Transform (clip): zoom around viewport center, then apply screen-space pan
  // 1. Zoom FIRST
  clip *= u_transform.x;
  
  // 2. Pan SECOND
  vec2 panClip = (u_transform.yz / u_viewportSize) * 2.0;
  panClip.y = -panClip.y;
  clip += panClip;
  
  gl_Position = vec4(clip, 0.0, 1.0);
}`;

const LINE_FRAGMENT_SHADER = `#version 300 es
precision mediump float;

uniform vec4 u_color;
out vec4 outColor;

void main() {
  outColor = u_color;
}`;

--- End of File: apps/web/src/lib/engine/WebGLRenderer.ts ---


--- File: apps/web/src/lib/engine/WorkerBridge.ts ---

/**
 * WorkerBridge - Main thread interface to simulation worker
 * 
 * Phase 5: Uses SharedArrayBuffer Ring Buffer for zero-latency input!
 * 
 * Provides the same API as WasmParticleEngine but delegates to worker.
 * Main thread never touches WASM directly.
 */

import type { ElementType, RenderMode, ToolType } from './types'
import { ELEMENT_NAME_TO_ID } from './generated_elements'
import { screenToWorld as invertTransform } from './transform'
import { 
  SharedInputBuffer, 
  getInputBufferSize, 
  isSharedArrayBufferAvailable
} from '../InputBuffer'

// Create worker with Vite's ?worker import
import SimulationWorker from '@/workers/simulation.worker.ts?worker'

export interface SimulationStats {
  fps: number
  particleCount: number
}

export type StatsCallback = (stats: { fps: number; particleCount: number }) => void
export type ReadyCallback = (width: number, height: number) => void
export type ErrorCallback = (message: string) => void
export type CrashCallback = (message: string, canRecover: boolean) => void

/**
 * Bridge between Main Thread and Simulation Worker
 * 
 * Usage:
 * ```ts
 * const bridge = new WorkerBridge()
 * bridge.onStats = (stats) => setFps(stats.fps)
 * await bridge.init(canvas, width, height)
 * bridge.play()
 * bridge.addParticles(x, y, radius, element)
 * ```
 */
export class WorkerBridge {
  private worker: Worker | null = null
  private _width: number = 0
  private _height: number = 0
  private _isReady: boolean = false
  
  // Phase 5: Shared input buffer for zero-latency input
  private inputBuffer: SharedInputBuffer | null = null
  private useSharedInput: boolean = false
  private pipetteResolvers: Map<number, (el: ElementType | null) => void> = new Map()
  private snapshotResolvers: Map<number, (data: ArrayBuffer | null) => void> = new Map()
  private requestId = 1
  
  // Callbacks
  public onStats: StatsCallback | null = null
  public onReady: ReadyCallback | null = null
  public onError: ErrorCallback | null = null
  public onCrash: CrashCallback | null = null  // Phase 5: Crash recovery
  
  // Camera state (stored on main thread for coordinate conversion)
  private zoom: number = 1
  private panX: number = 0
  private panY: number = 0
  
  constructor() {
    // Worker will be created on init
  }
  
  /**
   * Initialize the simulation worker with an OffscreenCanvas
   */
  async init(canvas: HTMLCanvasElement, width: number, height: number): Promise<void> {
    return new Promise((resolve, reject) => {
      try {
        // Create worker
        this.worker = new SimulationWorker()
        this._width = width
        this._height = height
        
        // Setup message handler
        this.worker.onmessage = (e) => {
          const msg = e.data
          
          switch (msg.type) {
            case 'READY':
              this._isReady = true
              this._width = msg.width
              this._height = msg.height
              this.onReady?.(msg.width, msg.height)
              resolve()
              break
              
            case 'STATS':
              this.onStats?.({
                fps: msg.fps,
                particleCount: msg.particleCount
              })
              break
              
            case 'ERROR':
              this.onError?.(msg.message)
              reject(new Error(msg.message))
              break
              
            // Phase 5: WASM crash recovery
            case 'CRASH':
              console.error('ðŸ’¥ WASM Crash:', msg.message)
              this.onCrash?.(msg.message, msg.canRecover ?? true)
              break
            
            case 'PIPETTE_RESULT': {
              const resolver = this.pipetteResolvers.get(msg.id)
              if (resolver) {
                resolver(msg.element ?? null)
                this.pipetteResolvers.delete(msg.id)
              }
              break
            }

            case 'SNAPSHOT_RESULT': {
              const resolver = this.snapshotResolvers.get(msg.id)
              if (resolver) {
                resolver(msg.buffer ?? null)
                this.snapshotResolvers.delete(msg.id)
              }
              break
            }
          }
        }
        
        this.worker.onerror = (e) => {
          this.onError?.(e.message)
          reject(e)
        }
        
        // Transfer canvas control to worker
        const offscreen = canvas.transferControlToOffscreen()
        
        // Phase 5: Create shared input buffer if available
        let inputBufferData: SharedArrayBuffer | null = null
        if (isSharedArrayBufferAvailable()) {
          try {
            inputBufferData = new SharedArrayBuffer(getInputBufferSize())
            this.inputBuffer = new SharedInputBuffer(inputBufferData)
            this.useSharedInput = true
            console.log('ðŸš€ WorkerBridge: Using SharedArrayBuffer for input (zero-latency)')
          } catch (e) {
            console.warn('SharedArrayBuffer not available, falling back to postMessage')
          }
        }
        
        // Send init message with canvas and optional input buffer
        this.worker.postMessage(
          {
            type: 'INIT',
            canvas: offscreen,
            width,
            height,
            inputBuffer: inputBufferData // May be null
          },
          [offscreen] // Transfer list (SAB is not transferred, just shared)
        )
        
      } catch (error) {
        reject(error)
      }
    })
  }
  
  // === Getters ===
  
  get width(): number { return this._width }
  get height(): number { return this._height }
  get isReady(): boolean { return this._isReady }
  
  // === Playback Control ===
  
  play(): void {
    this.worker?.postMessage({ type: 'PLAY' })
  }

  pause(): void {
    this.worker?.postMessage({ type: 'PAUSE' })
  }

  step(): void {
    this.worker?.postMessage({ type: 'STEP' })
  }
  
  clear(): void {
    this.worker?.postMessage({ type: 'CLEAR' })
  }
  
  // === Input ===
  
  /**
   * Add/remove particles (screen coordinates are converted to world)
   * Phase 5: Uses SharedArrayBuffer when available for zero-latency!
   */
  handleInput(
    screenX: number,
    screenY: number,
    radius: number,
    element: ElementType,
    tool: ToolType,
    brushShape: 'circle' | 'square' | 'line' = 'circle'
  ): void {
    const viewport = { width: this._width, height: this._height }
    const world = invertTransform(
      screenX,
      screenY,
      { zoom: this.zoom, panX: this.panX, panY: this.panY },
      viewport
    )
    const worldX = Math.floor(world.x)
    const worldY = Math.floor(world.y)
    
    // Phase 5: Use shared buffer for instant input (no postMessage delay!)
    if (this.useSharedInput && this.inputBuffer) {
      if (tool === 'eraser') {
        this.inputBuffer.pushErase(worldX, worldY, radius)
      } else if (tool === 'brush') {
        const elementId = ELEMENT_NAME_TO_ID[element] ?? 0
        if (elementId !== 0) { // Don't push empty
          this.inputBuffer.pushBrush(worldX, worldY, radius, elementId)
        }
      }
      return
    }
    
    // Fallback: postMessage (slower but always works)
    this.worker?.postMessage({
      type: 'INPUT',
      x: screenX,
      y: screenY,
      radius,
      element,
      brushShape,
      tool
    })
  }
  
  /**
   * Shorthand for brush tool
   */
  addParticles(screenX: number, screenY: number, radius: number, element: ElementType): void {
    this.handleInput(screenX, screenY, radius, element, 'brush')
  }
  
  /**
   * Shorthand for eraser tool
   */
  removeParticles(screenX: number, screenY: number, radius: number): void {
    this.handleInput(screenX, screenY, radius, 'empty', 'eraser')
  }

  /**
   * Flood fill tool (worker only)
   */
  fill(screenX: number, screenY: number, element: ElementType): void {
    const viewport = { width: this._width, height: this._height }
    const world = invertTransform(
      screenX,
      screenY,
      { zoom: this.zoom, panX: this.panX, panY: this.panY },
      viewport
    )
    this.worker?.postMessage({
      type: 'FILL',
      x: Math.floor(world.x),
      y: Math.floor(world.y),
      element
    })
  }
  
  /**
   * Spawn a rigid body at world coordinates
   */
  spawnRigidBody(
    worldX: number, 
    worldY: number, 
    size: number, 
    shape: 'box' | 'circle', 
    element: ElementType
  ): void {
    this.worker?.postMessage({
      type: 'SPAWN_RIGID_BODY',
      x: Math.floor(worldX),
      y: Math.floor(worldY),
      size: Math.floor(size),
      shape,
      element
    })
  }

  /**
   * Pipette tool - returns element under cursor
   */
  pipette(screenX: number, screenY: number): Promise<ElementType | null> {
    const id = this.requestId++
    return new Promise((resolve) => {
      this.pipetteResolvers.set(id, resolve)
      this.worker?.postMessage({
        type: 'PIPETTE',
        id,
        x: screenX,
        y: screenY,
      })
    })
  }

  /**
   * Capture snapshot of world (types only)
   */
  saveSnapshot(): Promise<ArrayBuffer | null> {
    const id = this.requestId++
    return new Promise((resolve) => {
      this.snapshotResolvers.set(id, resolve)
      this.worker?.postMessage({ type: 'SNAPSHOT', id })
    })
  }

  /**
   * Load snapshot buffer (must match world dimensions)
   */
  loadSnapshot(buffer: ArrayBuffer): void {
    this.worker?.postMessage({ type: 'LOAD_SNAPSHOT', buffer }, [buffer])
  }
  
  /**
   * Signal end of stroke (mouseUp) - resets Bresenham interpolation
   * CRITICAL: Must be called on mouseUp to prevent lines between strokes!
   * Uses SAB sentinel when available to prevent race conditions!
   */
  endStroke(): void {
    // Use SAB channel for end stroke (same channel as brush events = no race condition!)
    if (this.useSharedInput && this.inputBuffer) {
      this.inputBuffer.pushEndStroke()
      return
    }
    // Fallback: postMessage
    this.worker?.postMessage({ type: 'INPUT_END' })
  }
  
  // === Camera ===
  
  setTransform(zoom: number, panX: number, panY: number): void {
    this.zoom = zoom
    this.panX = panX
    this.panY = panY
    
    this.worker?.postMessage({
      type: 'TRANSFORM',
      zoom,
      panX,
      panY
    })
  }
  
  getTransform(): { zoom: number; panX: number; panY: number } {
    return { zoom: this.zoom, panX: this.panX, panY: this.panY }
  }
  
  /**
   * Convert screen coordinates to world coordinates
   */
  screenToWorld(screenX: number, screenY: number): { x: number; y: number } {
    const viewport = { width: this._width, height: this._height }
    const world = invertTransform(
      screenX,
      screenY,
      { zoom: this.zoom, panX: this.panX, panY: this.panY },
      viewport
    )
    return {
      x: Math.floor(world.x),
      y: Math.floor(world.y)
    }
  }
  
  // === Settings ===
  
  setSettings(settings: {
    gravity?: { x: number; y: number }
    ambientTemperature?: number
    speed?: number
  }): void {
    this.worker?.postMessage({
      type: 'SETTINGS',
      ...settings
    })
  }
  
  setRenderMode(mode: RenderMode): void {
    this.worker?.postMessage({
      type: 'SET_RENDER_MODE',
      mode
    })
  }
  
  // === Lifecycle ===
  
  resize(width: number, height: number): void {
    this._width = width
    this._height = height
    
    this.worker?.postMessage({
      type: 'RESIZE',
      width,
      height
    })
  }
  
  destroy(): void {
    this.worker?.terminate()
    this.worker = null
    this._isReady = false
  }
}

/**
 * Check if WebWorkers with OffscreenCanvas are supported
 */
export function isWorkerSupported(): boolean {
  return (
    typeof Worker !== 'undefined' &&
    typeof OffscreenCanvas !== 'undefined' &&
    // Check if we can transfer canvas control
    typeof HTMLCanvasElement.prototype.transferControlToOffscreen === 'function'
  )
}

/**
 * Check if SharedArrayBuffer is available (COOP/COEP headers set)
 */
export function isSharedMemorySupported(): boolean {
  return typeof SharedArrayBuffer !== 'undefined'
}

--- End of File: apps/web/src/lib/engine/WorkerBridge.ts ---


--- File: apps/web/src/lib/engine/elements.ts ---

/**
 * Element definitions with all properties
 * Phase 1: Data-Oriented Design with numeric IDs
 * 
 * Elements are stored in a flat array indexed by ElementId
 * This allows O(1) access without hash lookups
 */

import { 
  ElementType, 
  ElementProperties,
  ElementCategory,
  CategoryId,
  ElementId,
  ELEMENT_COUNT,
  ELEMENT_ID_TO_NAME,
  // Element IDs
  EL_EMPTY, EL_STONE, EL_SAND, EL_WOOD, EL_METAL, EL_ICE,
  EL_WATER, EL_OIL, EL_LAVA, EL_ACID,
  EL_STEAM, EL_SMOKE,
  EL_FIRE, EL_SPARK, EL_ELECTRICITY,
  EL_GUNPOWDER, EL_CLONE, EL_VOID,
  EL_DIRT, EL_SEED, EL_PLANT,
  // Category IDs
  CAT_SOLID, CAT_POWDER, CAT_LIQUID, CAT_GAS, CAT_ENERGY, CAT_UTILITY, CAT_BIO
} from './types'

// Color helper - convert hex string to packed RGBA
function rgba(hex: string, alpha = 255): number {
  const num = parseInt(hex.replace('#', ''), 16)
  return (alpha << 24) | num
}

// ============================================
// ELEMENT DATA - Flat array indexed by ElementId
// ============================================
export const ELEMENT_DATA: ElementProperties[] = [
  // 0: Empty
  {
    id: EL_EMPTY,
    name: 'Empty',
    category: CAT_SOLID,
    color: rgba('#0a0a0a'),
    density: 0,
    flammable: false,
    conductive: false,
    lifetime: 0,
    dispersion: 0,
    defaultTemp: 20,
    heatConductivity: 5,
  },
  // 1: Stone
  {
    id: EL_STONE,
    name: 'Stone',
    category: CAT_SOLID,
    color: rgba('#808080'),
    density: 2500,
    flammable: false,
    conductive: false,
    lifetime: 0,
    dispersion: 0,
    defaultTemp: 20,
    heatConductivity: 10,
    phaseChange: { high: { temp: 900, to: EL_LAVA } },
  },
  // 2: Sand
  {
    id: EL_SAND,
    name: 'Sand',
    category: CAT_POWDER,
    color: rgba('#C2B280'),
    density: 1600,
    flammable: false,
    conductive: false,
    lifetime: 0,
    dispersion: 0,
    defaultTemp: 20,
    heatConductivity: 15,
    phaseChange: { high: { temp: 1700, to: EL_LAVA } },
  },
  // 3: Wood
  {
    id: EL_WOOD,
    name: 'Wood',
    category: CAT_SOLID,
    color: rgba('#8B4513'),
    density: 600,
    flammable: true,
    conductive: false,
    lifetime: 0,
    dispersion: 0,
    defaultTemp: 20,
    heatConductivity: 5,
  },
  // 4: Metal
  {
    id: EL_METAL,
    name: 'Metal',
    category: CAT_SOLID,
    color: rgba('#A9A9A9'),
    density: 7800,
    flammable: false,
    conductive: true,
    lifetime: 0,
    dispersion: 0,
    defaultTemp: 20,
    heatConductivity: 90,
    phaseChange: { high: { temp: 1500, to: EL_LAVA } },
  },
  // 5: Ice
  {
    id: EL_ICE,
    name: 'Ice',
    category: CAT_SOLID,
    color: rgba('#A5F2F3'),
    density: 916,
    flammable: false,
    conductive: false,
    lifetime: 0,
    dispersion: 0,
    defaultTemp: -10,
    heatConductivity: 20,
    phaseChange: { high: { temp: 0, to: EL_WATER } },
  },
  // 6: Water
  {
    id: EL_WATER,
    name: 'Water',
    category: CAT_LIQUID,
    color: rgba('#4169E1'),
    density: 1000,
    flammable: false,
    conductive: true,
    lifetime: 0,
    dispersion: 8,
    defaultTemp: 20,
    heatConductivity: 40,
    phaseChange: {
      high: { temp: 100, to: EL_STEAM },
      low: { temp: 0, to: EL_ICE }
    },
  },
  // 7: Oil
  {
    id: EL_OIL,
    name: 'Oil',
    category: CAT_LIQUID,
    color: rgba('#4A4A2A'),
    density: 800,
    flammable: true,
    conductive: false,
    lifetime: 0,
    dispersion: 5,
    defaultTemp: 20,
    heatConductivity: 15,
  },
  // 8: Lava
  {
    id: EL_LAVA,
    name: 'Lava',
    category: CAT_LIQUID,
    color: rgba('#FF4500'),
    density: 2500,
    flammable: false,
    conductive: false,
    lifetime: 0,
    dispersion: 2,
    defaultTemp: 1000,
    heatConductivity: 30,
    phaseChange: { low: { temp: 700, to: EL_STONE } },
  },
  // 9: Acid
  {
    id: EL_ACID,
    name: 'Acid',
    category: CAT_LIQUID,
    color: rgba('#39FF14'),
    density: 1050,
    flammable: false,
    conductive: true,
    lifetime: 0,
    dispersion: 5,
    defaultTemp: 20,
    heatConductivity: 35,
  },
  // 10: Steam
  {
    id: EL_STEAM,
    name: 'Steam',
    category: CAT_GAS,
    color: rgba('#E0E0E0', 180),
    density: 0.6,
    flammable: false,
    conductive: false,
    lifetime: 0,
    dispersion: 6,
    defaultTemp: 100,
    heatConductivity: 10,
    phaseChange: { low: { temp: 90, to: EL_WATER } },
  },
  // 11: Smoke
  {
    id: EL_SMOKE,
    name: 'Smoke',
    category: CAT_GAS,
    color: rgba('#3F3F3F', 200),
    density: 1.1,
    flammable: false,
    conductive: false,
    lifetime: 0,
    dispersion: 4,
    defaultTemp: 50,
    heatConductivity: 5,
  },
  // 12: Fire
  {
    id: EL_FIRE,
    name: 'Fire',
    category: CAT_ENERGY,
    color: rgba('#FF6600'),
    density: 0.3,
    flammable: false,
    conductive: false,
    lifetime: 60,
    dispersion: 0,
    defaultTemp: 800,
    heatConductivity: 50,
  },
  // 13: Spark
  {
    id: EL_SPARK,
    name: 'Spark',
    category: CAT_ENERGY,
    color: rgba('#FFFF00'),
    density: 0.1,
    flammable: false,
    conductive: false,
    lifetime: 10,
    dispersion: 0,
    defaultTemp: 500,
    heatConductivity: 50,
  },
  // 14: Electricity
  {
    id: EL_ELECTRICITY,
    name: 'Electric',
    category: CAT_ENERGY,
    color: rgba('#00FFFF'),
    density: 0,
    flammable: false,
    conductive: false,
    lifetime: 3,
    dispersion: 0,
    defaultTemp: 200,
    heatConductivity: 80,
  },
  // 15: Gunpowder
  {
    id: EL_GUNPOWDER,
    name: 'Gunpowder',
    category: CAT_POWDER,
    color: rgba('#404040'),
    density: 1400,
    flammable: true,
    conductive: false,
    lifetime: 0,
    dispersion: 0,
    defaultTemp: 20,
    heatConductivity: 10,
  },
  // 16: Clone
  {
    id: EL_CLONE,
    name: 'Clone',
    category: CAT_UTILITY,
    color: rgba('#00FF00'),
    density: Infinity,
    flammable: false,
    conductive: false,
    lifetime: 0,
    dispersion: 0,
    defaultTemp: 20,
    heatConductivity: 0,
  },
  // 17: Void
  {
    id: EL_VOID,
    name: 'Void',
    category: CAT_UTILITY,
    color: rgba('#000000'),
    density: Infinity,
    flammable: false,
    conductive: false,
    lifetime: 0,
    dispersion: 0,
    defaultTemp: 20,
    heatConductivity: 0,
  },
  // 18: Dirt
  {
    id: EL_DIRT,
    name: 'Dirt',
    category: CAT_POWDER,
    color: rgba('#5C4033'),
    density: 1200,
    flammable: false,
    conductive: false,
    lifetime: 0,
    dispersion: 0,
    defaultTemp: 20,
    heatConductivity: 10,
  },
  // 19: Seed
  {
    id: EL_SEED,
    name: 'Seed',
    category: CAT_BIO,
    color: rgba('#E2C489'),
    density: 1100,
    flammable: true,
    conductive: false,
    lifetime: 0,
    dispersion: 0,
    defaultTemp: 20,
    heatConductivity: 5,
  },
  // 20: Plant
  {
    id: EL_PLANT,
    name: 'Plant',
    category: CAT_BIO,
    color: rgba('#228B22'),
    density: 900,
    flammable: true,
    conductive: false,
    lifetime: 0,
    dispersion: 0,
    defaultTemp: 20,
    heatConductivity: 10,
  },
]

// ============================================
// LEGACY COMPATIBILITY - Record<ElementType, ElementProperties>
// ============================================
export const ELEMENTS: Record<ElementType, ElementProperties> = {} as Record<ElementType, ElementProperties>

// Build ELEMENTS from ELEMENT_DATA
for (let i = 0; i < ELEMENT_COUNT; i++) {
  const name = ELEMENT_ID_TO_NAME[i]
  if (name) {
    ELEMENTS[name] = ELEMENT_DATA[i]
  }
}

// ============================================
// FAST LOOKUP FUNCTIONS (use numeric IDs)
// ============================================

// Get element properties by numeric ID - O(1), no hash lookup!
export function getElement(id: ElementId): ElementProperties {
  return ELEMENT_DATA[id] || ELEMENT_DATA[EL_EMPTY]
}

// Get category by element ID
export function getCategoryById(id: ElementId): CategoryId {
  return ELEMENT_DATA[id]?.category ?? CAT_SOLID
}

// Get density by element ID
export function getDensityById(id: ElementId): number {
  return ELEMENT_DATA[id]?.density ?? 0
}

// Get dispersion by element ID
export function getDispersionById(id: ElementId): number {
  return ELEMENT_DATA[id]?.dispersion ?? 0
}

// ============================================
// COLOR VARIATIONS (pre-computed per element)
// ============================================
const COLOR_VARIATIONS_BY_ID: Uint32Array[] = new Array(ELEMENT_COUNT)

// Pre-compute all color variations at load time!
for (let elId = 0; elId < ELEMENT_COUNT; elId++) {
  const base = ELEMENT_DATA[elId].color
  const variations = new Uint32Array(32)
  
  for (let i = 0; i < 32; i++) {
    const variation = (i - 16) * 2
    const a = (base >> 24) & 0xFF
    const r = Math.max(0, Math.min(255, ((base >> 16) & 0xFF) + variation))
    const g = Math.max(0, Math.min(255, ((base >> 8) & 0xFF) + variation))
    const b = Math.max(0, Math.min(255, (base & 0xFF) + variation))
    variations[i] = (a << 24) | (r << 16) | (g << 8) | b
  }
  
  COLOR_VARIATIONS_BY_ID[elId] = variations
}

// Get color variation by element ID - super fast!
export function getColorById(id: ElementId, seed: number): number {
  return COLOR_VARIATIONS_BY_ID[id][seed & 31]
}

// ============================================
// LEGACY FUNCTIONS (use string ElementType)
// ============================================
const COLOR_VARIATIONS = new Map<ElementType, Uint32Array>()

export function getColorWithVariation(element: ElementType, seed: number): number {
  let variations = COLOR_VARIATIONS.get(element)
  
  if (!variations) {
    const base = ELEMENTS[element].color
    variations = new Uint32Array(32)
    
    for (let i = 0; i < 32; i++) {
      const variation = (i - 16) * 2
      const a = (base >> 24) & 0xFF
      const r = Math.max(0, Math.min(255, ((base >> 16) & 0xFF) + variation))
      const g = Math.max(0, Math.min(255, ((base >> 8) & 0xFF) + variation))
      const b = Math.max(0, Math.min(255, (base & 0xFF) + variation))
      variations[i] = (a << 24) | (r << 16) | (g << 8) | b
    }
    
    COLOR_VARIATIONS.set(element, variations)
  }
  
  return variations[seed & 31]
}

export function getElementCategory(element: ElementType): ElementCategory {
  const cat = ELEMENTS[element].category
  // Convert numeric category back to string for legacy code
  const names: ElementCategory[] = ['solid', 'powder', 'liquid', 'gas', 'energy', 'utility', 'bio']
  return names[cat] || 'solid'
}

export function getElementColor(element: ElementType): string {
  const color = ELEMENTS[element].color
  const r = (color >> 16) & 0xFF
  const g = (color >> 8) & 0xFF
  const b = color & 0xFF
  return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`
}

--- End of File: apps/web/src/lib/engine/elements.ts ---


--- File: apps/web/src/lib/engine/generated_elements.ts ---

/**
 * Generated Element Definitions - DO NOT EDIT MANUALLY!
 *
 * This file is auto-generated by scripts/generate-elements.js
 * Source: definitions/elements.json
 *
 * To add a new element: edit definitions/elements.json and run 'npm run codegen'
 */

// ============================================================================
// ELEMENT ID CONSTANTS
// ============================================================================

export const EL_EMPTY = 0
export const EL_STONE = 1
export const EL_SAND = 2
export const EL_WOOD = 3
export const EL_METAL = 4
export const EL_ICE = 5
export const EL_WATER = 6
export const EL_OIL = 7
export const EL_LAVA = 8
export const EL_ACID = 9
export const EL_STEAM = 10
export const EL_SMOKE = 11
export const EL_FIRE = 12
export const EL_SPARK = 13
export const EL_ELECTRICITY = 14
export const EL_GUNPOWDER = 15
export const EL_CLONE = 16
export const EL_VOID = 17
export const EL_DIRT = 18
export const EL_SEED = 19
export const EL_PLANT = 20
export const ELEMENT_COUNT = 21

// ============================================================================
// CATEGORY CONSTANTS
// ============================================================================

export const CAT_SOLID = 0
export const CAT_POWDER = 1
export const CAT_LIQUID = 2
export const CAT_GAS = 3
export const CAT_ENERGY = 4
export const CAT_UTILITY = 5
export const CAT_BIO = 6

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================

export type ElementId = number
export type CategoryId = number

export type ElementType = 'empty' | 'stone' | 'sand' | 'wood' | 'metal' | 'ice' | 'water' | 'oil' | 'lava' | 'acid' | 'steam' | 'smoke' | 'fire' | 'spark' | 'electricity' | 'gunpowder' | 'clone' | 'void' | 'dirt' | 'seed' | 'plant'

export type CategoryType = 'solid' | 'powder' | 'liquid' | 'gas' | 'energy' | 'utility' | 'bio'

// ============================================================================
// MAPPINGS
// ============================================================================

export const ELEMENT_NAME_TO_ID: Record<ElementType, ElementId> = {
  empty: EL_EMPTY,
  stone: EL_STONE,
  sand: EL_SAND,
  wood: EL_WOOD,
  metal: EL_METAL,
  ice: EL_ICE,
  water: EL_WATER,
  oil: EL_OIL,
  lava: EL_LAVA,
  acid: EL_ACID,
  steam: EL_STEAM,
  smoke: EL_SMOKE,
  fire: EL_FIRE,
  spark: EL_SPARK,
  electricity: EL_ELECTRICITY,
  gunpowder: EL_GUNPOWDER,
  clone: EL_CLONE,
  void: EL_VOID,
  dirt: EL_DIRT,
  seed: EL_SEED,
  plant: EL_PLANT,
}

export const ELEMENT_ID_TO_NAME: ElementType[] = [
  'empty',
  'stone',
  'sand',
  'wood',
  'metal',
  'ice',
  'water',
  'oil',
  'lava',
  'acid',
  'steam',
  'smoke',
  'fire',
  'spark',
  'electricity',
  'gunpowder',
  'clone',
  'void',
  'dirt',
  'seed',
  'plant',
]

export const CATEGORY_NAME_TO_ID: Record<CategoryType, CategoryId> = {
  solid: CAT_SOLID,
  powder: CAT_POWDER,
  liquid: CAT_LIQUID,
  gas: CAT_GAS,
  energy: CAT_ENERGY,
  utility: CAT_UTILITY,
  bio: CAT_BIO,
}

// ============================================================================
// ELEMENT PROPERTIES
// ============================================================================

// ============================================================================
// ELEMENT FLAGS - Phase 1 Data-Driven
// ============================================================================

export const FLAG_NONE = 0
export const FLAG_FLAMMABLE = 1
export const FLAG_CONDUCTIVE = 2
export const FLAG_LIQUID = 4
export const FLAG_GAS = 8
export const FLAG_POWDER = 16
export const FLAG_SOLID = 32
export const FLAG_ENERGY = 64
export const FLAG_UTILITY = 128
export const FLAG_BIO = 256
export const FLAG_IGNORE_GRAVITY = 512
export const FLAG_CORROSIVE = 1024
export const FLAG_HOT = 2048
export const FLAG_COLD = 4096
export const FLAG_RIGID = 8192

export type ElementFlags = number

export function hasFlag(flags: ElementFlags, flag: ElementFlags): boolean {
  return (flags & flag) !== 0
}

export interface ElementProps {
  id: ElementId
  name: ElementType
  category: CategoryId
  flags: ElementFlags
  color: number
  density: number
  dispersion: number
  lifetime: number
  defaultTemp: number
  heatConductivity: number
  hidden?: boolean
}

export const ELEMENT_DATA: ElementProps[] = [
  {
    id: EL_EMPTY,
    name: 'empty',
    category: CAT_SOLID,
    flags: 32,
    color: 0xFF0A0A0A,
    density: 0,
    dispersion: 0,
    lifetime: 0,
    defaultTemp: 20,
    heatConductivity: 5, hidden: true,
  },
  {
    id: EL_STONE,
    name: 'stone',
    category: CAT_SOLID,
    flags: 32,
    color: 0xFF808080,
    density: 2500,
    dispersion: 0,
    lifetime: 0,
    defaultTemp: 20,
    heatConductivity: 10,
  },
  {
    id: EL_SAND,
    name: 'sand',
    category: CAT_POWDER,
    flags: 16,
    color: 0xFFC2B280,
    density: 1600,
    dispersion: 0,
    lifetime: 0,
    defaultTemp: 20,
    heatConductivity: 15,
  },
  {
    id: EL_WOOD,
    name: 'wood',
    category: CAT_SOLID,
    flags: 33,
    color: 0xFF8B4513,
    density: 600,
    dispersion: 0,
    lifetime: 0,
    defaultTemp: 20,
    heatConductivity: 5,
  },
  {
    id: EL_METAL,
    name: 'metal',
    category: CAT_SOLID,
    flags: 34,
    color: 0xFFA9A9A9,
    density: 7800,
    dispersion: 0,
    lifetime: 0,
    defaultTemp: 20,
    heatConductivity: 90,
  },
  {
    id: EL_ICE,
    name: 'ice',
    category: CAT_SOLID,
    flags: 4128,
    color: 0xFFA5F2F3,
    density: 916,
    dispersion: 0,
    lifetime: 0,
    defaultTemp: -10,
    heatConductivity: 20,
  },
  {
    id: EL_WATER,
    name: 'water',
    category: CAT_LIQUID,
    flags: 6,
    color: 0xFF4169E1,
    density: 1000,
    dispersion: 8,
    lifetime: 0,
    defaultTemp: 20,
    heatConductivity: 40,
  },
  {
    id: EL_OIL,
    name: 'oil',
    category: CAT_LIQUID,
    flags: 5,
    color: 0xFF4A4A2A,
    density: 800,
    dispersion: 5,
    lifetime: 0,
    defaultTemp: 20,
    heatConductivity: 15,
  },
  {
    id: EL_LAVA,
    name: 'lava',
    category: CAT_LIQUID,
    flags: 2052,
    color: 0xFFFF4500,
    density: 2500,
    dispersion: 2,
    lifetime: 0,
    defaultTemp: 1000,
    heatConductivity: 30,
  },
  {
    id: EL_ACID,
    name: 'acid',
    category: CAT_LIQUID,
    flags: 1030,
    color: 0xFF39FF14,
    density: 1050,
    dispersion: 5,
    lifetime: 0,
    defaultTemp: 20,
    heatConductivity: 35,
  },
  {
    id: EL_STEAM,
    name: 'steam',
    category: CAT_GAS,
    flags: 8,
    color: 0xB4E0E0E0,
    density: 0.6,
    dispersion: 6,
    lifetime: 0,
    defaultTemp: 100,
    heatConductivity: 10,
  },
  {
    id: EL_SMOKE,
    name: 'smoke',
    category: CAT_GAS,
    flags: 8,
    color: 0xC83F3F3F,
    density: 1.1,
    dispersion: 4,
    lifetime: 0,
    defaultTemp: 50,
    heatConductivity: 5,
  },
  {
    id: EL_FIRE,
    name: 'fire',
    category: CAT_ENERGY,
    flags: 2112,
    color: 0xFFFF6600,
    density: 0.3,
    dispersion: 0,
    lifetime: 60,
    defaultTemp: 800,
    heatConductivity: 50,
  },
  {
    id: EL_SPARK,
    name: 'spark',
    category: CAT_ENERGY,
    flags: 64,
    color: 0xFFFFFF00,
    density: 0.1,
    dispersion: 0,
    lifetime: 10,
    defaultTemp: 500,
    heatConductivity: 50,
  },
  {
    id: EL_ELECTRICITY,
    name: 'electricity',
    category: CAT_ENERGY,
    flags: 64,
    color: 0xFF00FFFF,
    density: 0,
    dispersion: 0,
    lifetime: 3,
    defaultTemp: 200,
    heatConductivity: 80,
  },
  {
    id: EL_GUNPOWDER,
    name: 'gunpowder',
    category: CAT_POWDER,
    flags: 17,
    color: 0xFF404040,
    density: 1400,
    dispersion: 0,
    lifetime: 0,
    defaultTemp: 20,
    heatConductivity: 10,
  },
  {
    id: EL_CLONE,
    name: 'clone',
    category: CAT_UTILITY,
    flags: 640,
    color: 0xFF00FF00,
    density: Infinity,
    dispersion: 0,
    lifetime: 0,
    defaultTemp: 20,
    heatConductivity: 0,
  },
  {
    id: EL_VOID,
    name: 'void',
    category: CAT_UTILITY,
    flags: 640,
    color: 0xFF000000,
    density: Infinity,
    dispersion: 0,
    lifetime: 0,
    defaultTemp: 20,
    heatConductivity: 0,
  },
  {
    id: EL_DIRT,
    name: 'dirt',
    category: CAT_POWDER,
    flags: 16,
    color: 0xFF5C4033,
    density: 1200,
    dispersion: 0,
    lifetime: 0,
    defaultTemp: 20,
    heatConductivity: 10,
  },
  {
    id: EL_SEED,
    name: 'seed',
    category: CAT_BIO,
    flags: 257,
    color: 0xFFE2C489,
    density: 1100,
    dispersion: 0,
    lifetime: 0,
    defaultTemp: 20,
    heatConductivity: 5,
  },
  {
    id: EL_PLANT,
    name: 'plant',
    category: CAT_BIO,
    flags: 257,
    color: 0xFF228B22,
    density: 900,
    dispersion: 0,
    lifetime: 0,
    defaultTemp: 20,
    heatConductivity: 10,
  },
]

// ============================================================================
// REACTIONS - Phase 1 Data-Driven
// ============================================================================

export interface Reaction {
  aggressor: ElementType
  victim: ElementType
  resultAggressor: ElementType | null
  resultVictim: ElementType | null
  chance: number
  spawn: ElementType | null
}

export const REACTIONS: Reaction[] = [
  { aggressor: 'fire', victim: 'wood', resultAggressor: 'smoke', resultVictim: 'fire', chance: 0.1, spawn: 'smoke' },
  { aggressor: 'fire', victim: 'oil', resultAggressor: 'smoke', resultVictim: 'fire', chance: 0.2, spawn: 'smoke' },
  { aggressor: 'fire', victim: 'water', resultAggressor: 'empty', resultVictim: 'steam', chance: 0.5, spawn: null },
  { aggressor: 'fire', victim: 'ice', resultAggressor: 'empty', resultVictim: 'water', chance: 0.3, spawn: 'steam' },
  { aggressor: 'fire', victim: 'gunpowder', resultAggressor: 'fire', resultVictim: 'fire', chance: 1, spawn: 'smoke' },
  { aggressor: 'fire', victim: 'plant', resultAggressor: 'smoke', resultVictim: 'fire', chance: 0.1, spawn: 'smoke' },
  { aggressor: 'fire', victim: 'seed', resultAggressor: 'smoke', resultVictim: 'fire', chance: 0.2, spawn: null },
  { aggressor: 'lava', victim: 'water', resultAggressor: 'stone', resultVictim: 'steam', chance: 0.15, spawn: 'steam' },
  { aggressor: 'lava', victim: 'wood', resultAggressor: null, resultVictim: 'fire', chance: 0.3, spawn: 'smoke' },
  { aggressor: 'lava', victim: 'oil', resultAggressor: null, resultVictim: 'fire', chance: 0.4, spawn: 'smoke' },
  { aggressor: 'lava', victim: 'ice', resultAggressor: 'stone', resultVictim: 'steam', chance: 0.3, spawn: null },
  { aggressor: 'lava', victim: 'gunpowder', resultAggressor: null, resultVictim: 'fire', chance: 1, spawn: 'smoke' },
  { aggressor: 'lava', victim: 'plant', resultAggressor: null, resultVictim: 'fire', chance: 0.5, spawn: 'smoke' },
  { aggressor: 'lava', victim: 'dirt', resultAggressor: null, resultVictim: 'stone', chance: 0.05, spawn: null },
  { aggressor: 'acid', victim: 'stone', resultAggressor: 'empty', resultVictim: 'empty', chance: 0.1, spawn: 'smoke' },
  { aggressor: 'acid', victim: 'metal', resultAggressor: 'empty', resultVictim: 'empty', chance: 0.05, spawn: null },
  { aggressor: 'acid', victim: 'wood', resultAggressor: 'empty', resultVictim: 'empty', chance: 0.2, spawn: null },
  { aggressor: 'acid', victim: 'ice', resultAggressor: 'empty', resultVictim: 'water', chance: 0.2, spawn: null },
  { aggressor: 'acid', victim: 'plant', resultAggressor: 'empty', resultVictim: 'empty', chance: 0.15, spawn: null },
  { aggressor: 'acid', victim: 'dirt', resultAggressor: 'empty', resultVictim: 'empty', chance: 0.05, spawn: null },
  { aggressor: 'water', victim: 'lava', resultAggressor: 'steam', resultVictim: 'stone', chance: 0.15, spawn: 'steam' },
  { aggressor: 'water', victim: 'fire', resultAggressor: 'steam', resultVictim: 'empty', chance: 0.3, spawn: null },
]

// ============================================================================
// UI HELPERS
// ============================================================================

/** Get elements visible in the UI palette (excludes 'empty') */
export const VISIBLE_ELEMENTS = ELEMENT_DATA.filter(e => !e.hidden)

/** Get elements by category for UI grouping */
export function getElementsByCategory(category: CategoryType): ElementProps[] {
  const catId = CATEGORY_NAME_TO_ID[category]
  return ELEMENT_DATA.filter(e => e.category === catId && !e.hidden)
}

--- End of File: apps/web/src/lib/engine/generated_elements.ts ---


--- File: apps/web/src/lib/engine/index.ts ---

/**
 * Particula Engine - WASM-powered particle simulation
 * 
 * Phase 5: Clean architecture - WASM only!
 * Legacy fallback engines moved to _LEGACY/
 */

// Core exports
export { ELEMENTS, getElementColor } from './elements'
export type { ElementType, WorldSettings } from './types'
export type { RenderMode } from './Renderer'

// Primary engine: Rust WASM
export { WasmParticleEngine, loadWasmEngine, isWasmAvailable } from './WasmParticleEngine'

// Re-export WasmParticleEngine as ParticleEngine for convenience
export { WasmParticleEngine as ParticleEngine } from './WasmParticleEngine'

--- End of File: apps/web/src/lib/engine/index.ts ---


--- File: apps/web/src/lib/engine/transform.ts ---

export interface Dimensions {
  width: number
  height: number
}

export interface CameraTransform {
  zoom: number
  panX: number
  panY: number
}

function screenToClip(
  sx: number,
  sy: number,
  viewport: Dimensions
): { x: number; y: number } {
  return {
    x: (sx / viewport.width) * 2 - 1,
    y: 1 - (sy / viewport.height) * 2
  }
}

function applyAspectCorrection(
  clip: { x: number; y: number },
  world: Dimensions,
  viewport: Dimensions,
  invert: boolean
): { x: number; y: number } {
  const worldAspect = world.width / world.height
  const viewportAspect = viewport.width / viewport.height

  // Shader scales the dominant axis to preserve aspect ratio.
  // When inverting, we need to apply the reciprocal scale.
  if (worldAspect > viewportAspect) {
    const factor = viewportAspect / worldAspect
    return invert ? { x: clip.x, y: clip.y * (worldAspect / viewportAspect) } : { x: clip.x, y: clip.y * factor }
  } else {
    const factor = worldAspect / viewportAspect
    return invert ? { x: clip.x * (viewportAspect / worldAspect), y: clip.y } : { x: clip.x * factor, y: clip.y }
  }
}

export function worldToClip(
  worldX: number,
  worldY: number,
  camera: CameraTransform,
  viewport: Dimensions,
  world?: Dimensions
): { x: number; y: number } {
  const worldSize = world ?? viewport

  let cx = (worldX / worldSize.width) * 2 - 1
  let cy = -((worldY / worldSize.height) * 2 - 1)

  const aspect = applyAspectCorrection({ x: cx, y: cy }, worldSize, viewport, false)
  cx = aspect.x
  cy = aspect.y

  const panClipX = (camera.panX / viewport.width) * 2
  const panClipY = -(camera.panY / viewport.height) * 2

  return {
    x: cx * camera.zoom + panClipX,
    y: cy * camera.zoom + panClipY
  }
}

/**
 * Exact inverse of the shader transform.
 */
export function screenToWorld(
  sx: number,
  sy: number,
  camera: CameraTransform,
  viewport: Dimensions,
  world?: Dimensions
): { x: number; y: number } {
  const worldSize = world ?? viewport

  if (
    viewport.width === 0 ||
    viewport.height === 0 ||
    worldSize.width === 0 ||
    worldSize.height === 0
  ) {
    return { x: 0, y: 0 }
  }

  const clip = screenToClip(sx, sy, viewport)

  const panClipX = (camera.panX / viewport.width) * 2
  const panClipY = -(camera.panY / viewport.height) * 2

  let cx = (clip.x - panClipX) / camera.zoom
  let cy = (clip.y - panClipY) / camera.zoom

  const aspect = applyAspectCorrection({ x: cx, y: cy }, worldSize, viewport, true)
  cx = aspect.x
  cy = aspect.y

  cy = -cy

  return {
    x: ((cx + 1) * 0.5) * worldSize.width,
    y: ((cy + 1) * 0.5) * worldSize.height
  }
}

/**
 * Compute pan needed to keep the world point under the cursor fixed
 * when zooming to `newZoom`.
 */
export function solvePanForZoom(
  pivotScreenX: number,
  pivotScreenY: number,
  newZoom: number,
  camera: CameraTransform,
  viewport: Dimensions,
  world?: Dimensions
): CameraTransform {
  const worldSize = world ?? viewport

  const targetClip = screenToClip(pivotScreenX, pivotScreenY, viewport)
  const worldPoint = screenToWorld(pivotScreenX, pivotScreenY, camera, viewport, worldSize)

  const baseClip = worldToClip(worldPoint.x, worldPoint.y, { zoom: newZoom, panX: 0, panY: 0 }, viewport, worldSize)

  const panClipX = targetClip.x - baseClip.x
  const panClipY = targetClip.y - baseClip.y

  return {
    zoom: newZoom,
    panX: (panClipX / 2) * viewport.width,
    panY: -(panClipY / 2) * viewport.height
  }
}

--- End of File: apps/web/src/lib/engine/transform.ts ---


--- File: apps/web/src/lib/engine/types.ts ---

/**
 * Core types for the particle simulation engine
 * Phase 1: Data-Oriented Design with TypedArrays
 * 
 * Key changes:
 * - ElementId is now a number (Uint8) for TypedArray storage
 * - No more Particle objects - data stored in SoA (Structure of Arrays)
 * - Zero GC pressure during simulation
 */

// ============================================
// ELEMENT IDS - Numeric constants for TypedArrays
// ============================================
export const EL_EMPTY       = 0
export const EL_STONE       = 1
export const EL_SAND        = 2
export const EL_WOOD        = 3
export const EL_METAL       = 4
export const EL_ICE         = 5
export const EL_WATER       = 6
export const EL_OIL         = 7
export const EL_LAVA        = 8
export const EL_ACID        = 9
export const EL_STEAM       = 10
export const EL_SMOKE       = 11
export const EL_FIRE        = 12
export const EL_SPARK       = 13
export const EL_ELECTRICITY = 14
export const EL_GUNPOWDER   = 15
export const EL_CLONE       = 16
export const EL_VOID        = 17
export const EL_DIRT        = 18
export const EL_SEED        = 19
export const EL_PLANT       = 20

export const ELEMENT_COUNT  = 21

// ElementId type - the numeric ID
export type ElementId = number

// Legacy string type for backwards compatibility during transition
export type ElementType = 
  | 'empty'
  | 'stone' | 'sand' | 'wood' | 'metal' | 'ice'
  | 'water' | 'oil' | 'lava' | 'acid'
  | 'steam' | 'smoke'
  | 'fire' | 'spark' | 'electricity'
  | 'gunpowder'
  | 'clone' | 'void'
  | 'dirt' | 'seed' | 'plant'

// String to ID mapping
export const ELEMENT_NAME_TO_ID: Record<ElementType, ElementId> = {
  empty: EL_EMPTY,
  stone: EL_STONE,
  sand: EL_SAND,
  wood: EL_WOOD,
  metal: EL_METAL,
  ice: EL_ICE,
  water: EL_WATER,
  oil: EL_OIL,
  lava: EL_LAVA,
  acid: EL_ACID,
  steam: EL_STEAM,
  smoke: EL_SMOKE,
  fire: EL_FIRE,
  spark: EL_SPARK,
  electricity: EL_ELECTRICITY,
  gunpowder: EL_GUNPOWDER,
  clone: EL_CLONE,
  void: EL_VOID,
  dirt: EL_DIRT,
  seed: EL_SEED,
  plant: EL_PLANT,
}

// ID to string mapping (for debugging/UI)
export const ELEMENT_ID_TO_NAME: ElementType[] = [
  'empty', 'stone', 'sand', 'wood', 'metal', 'ice',
  'water', 'oil', 'lava', 'acid',
  'steam', 'smoke',
  'fire', 'spark', 'electricity',
  'gunpowder',
  'clone', 'void',
  'dirt', 'seed', 'plant'
]

// ============================================
// CATEGORY IDS - Numeric for fast comparison
// ============================================
export const CAT_SOLID   = 0
export const CAT_POWDER  = 1
export const CAT_LIQUID  = 2
export const CAT_GAS     = 3
export const CAT_ENERGY  = 4
export const CAT_UTILITY = 5
export const CAT_BIO     = 6

export type CategoryId = number
export type ElementCategory = 'solid' | 'powder' | 'liquid' | 'gas' | 'energy' | 'utility' | 'bio'

export const CATEGORY_NAME_TO_ID: Record<ElementCategory, CategoryId> = {
  solid: CAT_SOLID,
  powder: CAT_POWDER,
  liquid: CAT_LIQUID,
  gas: CAT_GAS,
  energy: CAT_ENERGY,
  utility: CAT_UTILITY,
  bio: CAT_BIO,
}

// ============================================
// ELEMENT PROPERTIES - Flat arrays for cache efficiency
// ============================================
export interface PhaseChange {
  high?: { temp: number; to: ElementId }
  low?: { temp: number; to: ElementId }
}

export interface ElementProperties {
  id: ElementId
  name: string
  category: CategoryId
  color: number
  density: number
  flammable: boolean
  conductive: boolean
  lifetime: number
  dispersion: number
  defaultTemp: number
  heatConductivity: number
  phaseChange?: PhaseChange
}

// ============================================
// WORLD SETTINGS
// ============================================
export interface WorldSettings {
  gravity: { x: number; y: number }
  ambientTemperature: number
  speed: number
}

// ============================================
// LEGACY INTERFACES (for gradual migration)
// ============================================
export interface Particle {
  element: ElementType
  color: number
  updated: boolean
  lifetime: number
}

export interface IRenderer {
  render(types: Uint8Array, colors: Uint32Array): void
  resize(width: number, height: number): void
}

export interface ISimulation {
  step(): void
  addParticle(x: number, y: number, element: ElementType): boolean
  removeParticle(x: number, y: number): boolean
  clear(): void
  resize(width: number, height: number): void
  readonly particleCount: number
  readonly width: number
  readonly height: number
}

// ============================================
// RENDER & TOOL TYPES
// ============================================
export type RenderMode = 'normal' | 'thermal'
export type ToolType = 'brush' | 'eraser' | 'pipette' | 'fill' | 'move'

--- End of File: apps/web/src/lib/engine/types.ts ---


--- File: apps/web/src/main.tsx ---

import ReactDOM from 'react-dom/client'
import App from './App'
import './styles/globals.css'

ReactDOM.createRoot(document.getElementById('root')!).render(<App />)

--- End of File: apps/web/src/main.tsx ---


--- File: apps/web/src/stores/simulationStore.ts ---

import { create } from 'zustand'
import type { RenderMode } from '@/lib/engine'
import * as SimulationController from '@/lib/engine/SimulationController'

interface SimulationState {
  // State
  isPlaying: boolean
  speed: 0.5 | 1 | 2 | 4
  fps: number
  particleCount: number
  renderMode: RenderMode
  
  // World settings
  gravity: { x: number; y: number }
  ambientTemperature: number
  
  // Actions
  play: () => void
  pause: () => void
  step: () => void
  reset: () => void
  setSpeed: (speed: 0.5 | 1 | 2 | 4) => void
  setGravity: (gravity: { x: number; y: number }) => void
  setAmbientTemperature: (temp: number) => void
  setFps: (fps: number) => void
  setParticleCount: (count: number) => void
  toggleRenderMode: () => void
}

export const useSimulationStore = create<SimulationState>((set, get) => ({
  // Initial state
  isPlaying: false,
  speed: 1,
  fps: 60,
  particleCount: 0,
  renderMode: 'normal' as RenderMode,
  gravity: { x: 0, y: 9.8 },
  ambientTemperature: 20,
  
  // Actions
  play: () => {
    SimulationController.play()
    set({ isPlaying: true })
  },
  pause: () => {
    SimulationController.pause()
    set({ isPlaying: false })
  },
  step: () => {
    SimulationController.step()
  },
  reset: () => {
    SimulationController.reset()
    set({ particleCount: 0, isPlaying: false })
  },
  setSpeed: (speed) => {
    SimulationController.setSpeed(speed)
    set({ speed })
  },
  setGravity: (gravity) => {
    SimulationController.setGravity(gravity)
    set({ gravity })
  },
  setAmbientTemperature: (ambientTemperature) => {
    SimulationController.setAmbientTemperature(ambientTemperature)
    set({ ambientTemperature })
  },
  setFps: (fps) => set({ fps }),
  setParticleCount: (particleCount) => set({ particleCount }),
  toggleRenderMode: () => {
    const currentMode = get().renderMode
    const newMode: RenderMode = currentMode === 'normal' ? 'thermal' : 'normal'
    SimulationController.setRenderMode(newMode)
    set({ renderMode: newMode })
  },
}))

--- End of File: apps/web/src/stores/simulationStore.ts ---


--- File: apps/web/src/stores/toolStore.ts ---

import { create } from 'zustand'
import type { ElementType } from '@/lib/engine'

type ToolType = 'brush' | 'eraser' | 'pipette' | 'fill' | 'move' | 'rigid_body'
type BrushShape = 'circle' | 'square' | 'line'
type RigidBodyShape = 'box' | 'circle'

interface ToolState {
  // Current tool
  selectedTool: ToolType
  brushShape: BrushShape
  brushSize: number
  
  // Selected element
  selectedElement: ElementType
  
  // Rigid body settings
  rigidBodyShape: RigidBodyShape
  rigidBodySize: number
  rigidBodyElement: ElementType
  
  // Actions
  setTool: (tool: ToolType) => void
  setBrushShape: (shape: BrushShape) => void
  setBrushSize: (size: number) => void
  setElement: (element: ElementType) => void
  setRigidBodyShape: (shape: RigidBodyShape) => void
  setRigidBodySize: (size: number) => void
  setRigidBodyElement: (element: ElementType) => void
}

export const useToolStore = create<ToolState>((set) => ({
  // Initial state
  selectedTool: 'brush',
  brushShape: 'circle',
  brushSize: 10,
  selectedElement: 'sand',
  
  // Rigid body defaults
  rigidBodyShape: 'box',
  rigidBodySize: 20,
  rigidBodyElement: 'stone',
  
  // Actions
  setTool: (selectedTool) => set({ selectedTool }),
  setBrushShape: (brushShape) => set({ brushShape }),
  setBrushSize: (brushSize) => set({ brushSize: Math.min(50, Math.max(1, brushSize)) }),
  setElement: (selectedElement) => set({ selectedElement, selectedTool: 'brush' }),
  setRigidBodyShape: (rigidBodyShape) => set({ rigidBodyShape, selectedTool: 'rigid_body' }),
  setRigidBodySize: (rigidBodySize) => set({ rigidBodySize: Math.min(50, Math.max(5, rigidBodySize)) }),
  setRigidBodyElement: (rigidBodyElement) => set({ rigidBodyElement }),
}))

--- End of File: apps/web/src/stores/toolStore.ts ---


--- File: apps/web/src/workers/simulation.worker.ts ---

/**
 * Simulation Worker - Runs WASM physics in separate thread
 * 
 * Phase 1 (WebWorker): UI never blocks, physics runs independently
 * Phase 2 (Zero-Copy): Direct memory access via SharedArrayBuffer views
 * 
 * Message Protocol:
 * - Main â†’ Worker: INIT, PLAY, PAUSE, SET_TOOL, INPUT, TRANSFORM, SETTINGS, CLEAR, RESIZE
 * - Worker â†’ Main: READY, STATS, ERROR
 */

// Worker-side types (can't import from main - workers are isolated)
// MUST match types.ts ElementType exactly!
type ElementType = 
  | 'empty'
  | 'stone' | 'sand' | 'wood' | 'metal' | 'ice'
  | 'water' | 'oil' | 'lava' | 'acid'
  | 'steam' | 'smoke'
  | 'fire' | 'spark' | 'electricity'
  | 'gunpowder'
  | 'clone' | 'void'
  | 'dirt' | 'seed' | 'plant'

type RenderMode = 'normal' | 'thermal'
type ToolType = 'brush' | 'eraser' | 'pipette' | 'move'

// Phase 5: Import SharedInputBuffer for zero-latency input
import { SharedInputBuffer, INPUT_TYPE_ERASE, INPUT_TYPE_END_STROKE, INPUT_TYPE_BRUSH_OFFSET } from '../lib/InputBuffer'
import { screenToWorld as invertTransform } from '../lib/engine/transform'
import { ELEMENT_NAME_TO_ID, ELEMENT_ID_TO_NAME } from '../lib/engine/generated_elements'

// Phase 3: WebGL Renderer for GPU-accelerated rendering
import { WebGLRenderer } from '../lib/engine/WebGLRenderer'

// Phase 3 (Fort Knox): Safe memory management
import { MemoryManager } from '../lib/engine/MemoryManager'

// Message types
interface InitMessage {
  type: 'INIT'
  canvas: OffscreenCanvas
  width: number
  height: number
  inputBuffer?: SharedArrayBuffer // Phase 5: Optional shared input buffer
}

interface InputMessage {
  type: 'INPUT'
  x: number
  y: number
  radius: number
  element: ElementType
  tool: ToolType
  brushShape?: 'circle' | 'square' | 'line'
}

interface TransformMessage {
  type: 'TRANSFORM'
  zoom: number
  panX: number
  panY: number
}

interface SettingsMessage {
  type: 'SETTINGS'
  gravity?: { x: number; y: number }
  ambientTemperature?: number
  speed?: number
}

interface RenderModeMessage {
  type: 'SET_RENDER_MODE'
  mode: RenderMode
}

interface ResizeMessage {
  type: 'RESIZE'
  width: number
  height: number
}

type WorkerMessage = 
  | InitMessage
  | InputMessage
  | TransformMessage
  | SettingsMessage
  | RenderModeMessage
  | ResizeMessage
  | { type: 'PLAY' }
  | { type: 'PAUSE' }
  | { type: 'STEP' }   // Single-step when paused
  | { type: 'CLEAR' }
  | { type: 'FILL'; x: number; y: number; element: ElementType }
  | { type: 'PIPETTE'; id: number; x: number; y: number }
  | { type: 'SNAPSHOT'; id: number }
  | { type: 'LOAD_SNAPSHOT'; buffer: ArrayBuffer }
  | { type: 'INPUT_END' }  // Phase 5: Reset Bresenham tracking
  | { type: 'SPAWN_RIGID_BODY'; x: number; y: number; size: number; shape: 'box' | 'circle'; element: ElementType }

// Worker state
let engine: any = null
let wasmModule: any = null
let wasmMemory: WebAssembly.Memory | null = null
let canvas: OffscreenCanvas | null = null

// Phase 3: WebGL Renderer (replaces Canvas2D)
let renderer: WebGLRenderer | null = null
let useWebGL = true // Feature flag for fallback

// Phase 5: Shared input buffer for zero-latency input
let sharedInputBuffer: SharedInputBuffer | null = null

// Canvas2D for thermal mode (and fallback)
let thermalCanvas: OffscreenCanvas | null = null
let ctx: OffscreenCanvasRenderingContext2D | null = null
let imageData: ImageData | null = null
let pixels: Uint8ClampedArray | null = null
let pixels32: Uint32Array | null = null

// Phase 3 (Fort Knox): Safe memory manager
let memoryManager: MemoryManager | null = null

// Simulation state
let isPlaying = false
let speed = 1
let renderMode: RenderMode = 'normal'

// Camera state
let zoom = 1
let panX = 0
let panY = 0

// Animation
// Note: animationFrameId stored but only used for potential future cancellation
let lastTime = 0

// FPS tracking (zero-allocation ring buffer)
const FPS_SAMPLES = 20
const fpsBuffer = new Float32Array(FPS_SAMPLES)
let fpsIndex = 0
let fpsCount = 0

// Stats update throttling
let lastStatsUpdate = 0
const STATS_INTERVAL = 200 // ms

// Constants
const BG_COLOR_32 = 0xFF0A0A0A
const EL_EMPTY = 0

// === DEBUG: Dirty chunk logging ===
const DEBUG_DIRTY =
  (
    typeof process !== 'undefined' &&
    process.env?.NODE_ENV === 'development' &&
    process.env?.VITE_DEBUG_DIRTY !== 'false'
  ) ||
  (
    typeof import.meta !== 'undefined' &&
    (import.meta as any).env?.MODE === 'development' &&
    (import.meta as any).env?.VITE_DEBUG_DIRTY !== 'false'
  )
let debugLogInterval = 0
const DEBUG_LOG_EVERY = 60  // Log every N frames

// Element mapping from generated definitions
const ELEMENT_MAP: Record<ElementType, number> = ELEMENT_NAME_TO_ID

// ============================================================================
// INITIALIZATION
// ============================================================================

async function initEngine(initCanvas: OffscreenCanvas, width: number, height: number, inputBuffer?: SharedArrayBuffer) {
  try {
    canvas = initCanvas
    
    // CRITICAL: Set canvas size! OffscreenCanvas doesn't inherit from HTMLCanvasElement
    canvas.width = width
    canvas.height = height
    
    // Phase 5: Setup shared input buffer if provided
    if (inputBuffer) {
      sharedInputBuffer = new SharedInputBuffer(inputBuffer)
      console.log('ðŸš€ Worker: Using SharedArrayBuffer for input (zero-latency)')
    }
    
    // Import WASM module dynamically
    // @ts-ignore - Dynamic import in worker
    const wasm = await import('@particula/engine-wasm')
    const wasmExports = await wasm.default()
    
    wasmModule = wasm
    // CRITICAL: memory is returned from default(), not wasm.memory!
    wasmMemory = wasmExports.memory
    
    if (!wasmMemory) {
      console.error('WASM memory not found! Exports:', Object.keys(wasmExports))
      throw new Error('WASM memory not available')
    }
    
    console.log(`ðŸš€ Worker: WASM memory size: ${wasmMemory.buffer.byteLength} bytes`)
    
    // Create world
    engine = new wasm.World(width, height)
    
    // Phase 3: Try WebGL first (GPU-accelerated)
    try {
      renderer = new WebGLRenderer(canvas, width, height)
      useWebGL = true
      console.log('ðŸŽ® Worker: WebGL 2.0 Renderer active!')
    } catch (e) {
      console.warn('WebGL not available, falling back to Canvas2D:', e)
      useWebGL = false
    }
    
    // ALWAYS create Canvas2D resources for thermal mode fallback
    // Create a separate OffscreenCanvas for thermal rendering
    thermalCanvas = new OffscreenCanvas(width, height)
    ctx = thermalCanvas.getContext('2d', { 
      alpha: false,
      desynchronized: true
    }) as OffscreenCanvasRenderingContext2D
    
    if (ctx) {
      ctx.imageSmoothingEnabled = false
      imageData = new ImageData(width, height)
      pixels = imageData.data
      pixels32 = new Uint32Array(pixels.buffer)
      console.log('ðŸŒ¡ï¸ Worker: Thermal mode canvas ready')
    }
    
    console.log(`ðŸš€ Worker: Canvas ${width}x${height}, Mode: ${useWebGL ? 'WebGL' : 'Canvas2D'}`)
    
    // Setup zero-copy memory views
    updateMemoryViews()
    
    console.log('ðŸš€ Worker: Engine initialized!')
    
    // Notify main thread
    self.postMessage({ type: 'READY', width, height })
    
    // Start render loop
    requestAnimationFrame(renderLoop)
    
  } catch (error) {
    console.error('Worker init error:', error)
    self.postMessage({ type: 'ERROR', message: String(error) })
  }
}

function updateMemoryViews() {
  // Phase 3 (Fort Knox): Use MemoryManager for safe view access
  if (!engine || !wasmMemory) return
  
  if (!memoryManager) {
    memoryManager = new MemoryManager(wasmMemory, engine)
  } else {
    // Refresh views if memory grew
    memoryManager.refresh()
  }
}

// ============================================================================
// RENDER LOOP
// ============================================================================

function renderLoop(time: number) {
  // Check if we have everything needed for rendering
  const hasWebGL = useWebGL && renderer && engine && canvas && wasmMemory
  const hasCanvas2D = !useWebGL && ctx && engine && canvas
  
  if (!hasWebGL && !hasCanvas2D) {
    requestAnimationFrame(renderLoop)
    return
  }
  
  // FPS calculation (zero-allocation)
  const delta = time - lastTime
  if (delta > 0) {
    fpsBuffer[fpsIndex] = 1000 / delta
    fpsIndex = (fpsIndex + 1) % FPS_SAMPLES
    if (fpsCount < FPS_SAMPLES) fpsCount++
  }
  lastTime = time
  const dtSeconds = Math.min(Math.max(delta / 1000, 0), 0.25)
  
  // Phase 5: Process shared input buffer (zero-latency!)
  processSharedInput()
  
  // Physics step (Phase 5: wrapped in try-catch for crash recovery)
  if (isPlaying) {
    try {
      const simDt = dtSeconds * speed
      engine.step_with_dt(simDt)
      // Memory might have grown
      updateMemoryViews()
    } catch (e) {
      // Phase 5: WASM crashed - notify UI and stop simulation
      console.error('ðŸ’¥ WASM simulation crashed:', e)
      isPlaying = false
      self.postMessage({
        type: 'CRASH',
        message: String(e),
        canRecover: true
      })
    }
  }
  
  // Render
  renderFrame()
  
  // Send stats (throttled)
  if (time - lastStatsUpdate > STATS_INTERVAL) {
    sendStats()
    lastStatsUpdate = time
  }
  
  requestAnimationFrame(renderLoop)
}

function renderFrame() {
  if (!engine || !canvas) return
  
  const transform = { zoom, panX, panY }
  
  // Thermal mode path (uses Canvas2D to render, then uploads to WebGL)
  if (renderMode === 'thermal') {
    if (!ctx || !pixels || !imageData || !memoryManager) return
    
    // Render thermal to ImageData
    renderThermal()
    ctx.putImageData(imageData, 0, 0)
    
    // Use WebGL to display with transform (if available)
    if (useWebGL && renderer) {
      renderer.renderThermal(imageData, transform)
    }
    // If no WebGL, thermalCanvas already has the image (but no transform)
    return
  }
  
  // Phase 3: WebGL Path (GPU-accelerated)
  if (useWebGL && renderer && wasmMemory) {
    // === DEBUG: Log dirty chunks info ===
    if (DEBUG_DIRTY) {
      debugLogInterval++
      if (debugLogInterval >= DEBUG_LOG_EVERY) {
        debugLogInterval = 0
        
        // Get dirty count BEFORE render (without consuming!)
        const dirtyCount = engine.count_dirty_chunks ? engine.count_dirty_chunks() : 0
        
        // Sample some chunk states
        const chunksX = engine.chunks_x()
        const chunksY = engine.chunks_y()
        const totalChunks = chunksX * chunksY
        
        // Count ALL water and ice particles in the world
        let waterCount = 0
        let iceCount = 0
        let sampleTemp = 0
        let sampleCount = 0
        
        if (memoryManager) {
          const types = memoryManager.types
          const temps = memoryManager.temperature
          const len = types.length
          
          // Scan entire world
          for (let i = 0; i < len; i++) {
            const type = types[i]
            if (type === 6) { // EL_WATER
              waterCount++
              sampleTemp += temps[i]
              sampleCount++
            } else if (type === 5) { // EL_ICE
              iceCount++
              sampleTemp += temps[i]
              sampleCount++
            }
          }
        }
        
        const avgTemp = sampleCount > 0 ? (sampleTemp / sampleCount).toFixed(1) : 'N/A'
        const ambientTemp = engine.get_ambient_temperature ? engine.get_ambient_temperature() : 'N/A'
        
        console.log(`ðŸ” DEBUG [Frame]: dirty=${dirtyCount}/${totalChunks}, water=${waterCount}, ice=${iceCount}, avgTemp=${avgTemp}Â°C, ambient=${ambientTemp}Â°C`)
      }
    }
    
    // Use dirty rectangles for optimal GPU upload
    renderer.renderWithDirtyRects(engine, wasmMemory, transform)
    return
  }
  
  // Fallback: Canvas2D Path (when WebGL not available)
  if (!ctx || !pixels32 || !imageData || !memoryManager) return
  
  const width = canvas.width
  const height = canvas.height
  
  // 1. Render to ImageData
  renderNormal()
  
  // 2. Put pixels to context
  ctx.putImageData(imageData, 0, 0)
  
  // 3. Draw to screen with camera transform (if we had a separate screen canvas)
  // For OffscreenCanvas in worker, this IS the screen
  // We need to handle zoom/pan differently - draw to a buffer first
  
  // Clear and apply transform for world border
  // (The main render is already done via putImageData)
  drawWorldBorder(width, height)
}

function renderNormal() {
  if (!pixels32 || !memoryManager) return
  
  const typesView = memoryManager.types
  const colorsView = memoryManager.colors
  const len = Math.min(typesView.length, pixels32.length)
  
  // Direct copy (WASM provides ABGR format)
  pixels32.set(colorsView.subarray(0, len))
  
  // Fix empty cells to background
  for (let i = 0; i < len; i++) {
    if (typesView[i] === EL_EMPTY) {
      pixels32[i] = BG_COLOR_32
    }
  }
}

function renderThermal() {
  if (!pixels || !memoryManager) return
  
  const temperatureView = memoryManager.temperature
  const len = Math.min(temperatureView.length, pixels.length / 4)
  
  for (let i = 0; i < len; i++) {
    const temp = temperatureView[i]
    const base = i << 2
    
    const [r, g, b] = getThermalColor(temp)
    
    pixels[base] = r
    pixels[base + 1] = g
    pixels[base + 2] = b
    pixels[base + 3] = 255
  }
}

function getThermalColor(t: number): [number, number, number] {
  if (t < 0) {
    const intensity = Math.min(1, Math.abs(t) / 30)
    return [0, 0, Math.floor(128 + 127 * intensity)]
  }
  if (t < 20) {
    const ratio = t / 20
    return [0, Math.floor(ratio * 255), 255]
  }
  if (t < 50) {
    const ratio = (t - 20) / 30
    return [0, 255, Math.floor(255 * (1 - ratio))]
  }
  if (t < 100) {
    const ratio = (t - 50) / 50
    return [Math.floor(255 * ratio), 255, 0]
  }
  if (t < 500) {
    const ratio = (t - 100) / 400
    return [255, Math.floor(255 * (1 - ratio)), 0]
  }
  const ratio = Math.min(1, (t - 500) / 500)
  return [255, Math.floor(255 * ratio), Math.floor(255 * ratio)]
}

function drawWorldBorder(width: number, height: number) {
  if (!ctx) return
  
  // Outer glow
  ctx.strokeStyle = 'rgba(59, 130, 246, 0.3)'
  ctx.lineWidth = 6
  ctx.strokeRect(-3, -3, width + 6, height + 6)
  
  // Middle glow
  ctx.strokeStyle = 'rgba(59, 130, 246, 0.5)'
  ctx.lineWidth = 3
  ctx.strokeRect(-1.5, -1.5, width + 3, height + 3)
  
  // Inner sharp border
  ctx.strokeStyle = 'rgba(59, 130, 246, 0.8)'
  ctx.lineWidth = 1
  ctx.strokeRect(0, 0, width, height)
}

// ============================================================================
// INPUT HANDLING
// ============================================================================

function handleInput(
  x: number,
  y: number,
  radius: number,
  element: ElementType,
  tool: ToolType,
  brushShape: 'circle' | 'square' | 'line' = 'circle'
) {
  if (!engine) return
  
  // Apply camera transform to convert screen coords to world coords
  const viewport = canvas ? { width: canvas.width, height: canvas.height } : { width: 0, height: 0 }
  const world = invertTransform(
    x,
    y,
    { zoom, panX, panY },
    viewport
  )
  const worldX = Math.floor(world.x)
  const worldY = Math.floor(world.y)
  
  const wasmElement = ELEMENT_MAP[element] ?? 0
  
  const applyBrush = (wx: number, wy: number) => {
    if (tool === 'eraser') {
      engine.remove_particles_in_radius(wx, wy, radius)
    } else if (tool === 'brush') {
      if (wasmElement !== 0) {
        engine.add_particles_in_radius(wx, wy, radius, wasmElement)
      }
    }
  }

  if (brushShape === 'square') {
    const half = Math.max(1, radius)
    for (let dy = -half; dy <= half; dy++) {
      for (let dx = -half; dx <= half; dx++) {
        applyBrush(worldX + dx, worldY + dy)
      }
    }
  } else if (brushShape === 'line') {
    drawLine(worldX - radius, worldY, worldX + radius, worldY, radius, wasmElement, tool === 'eraser')
  } else {
    applyBrush(worldX, worldY)
  }
  // pipette and move are handled on main thread (UI concerns)
}

// Phase 5: State for Bresenham line interpolation
let lastInputX: number | null = null
let lastInputY: number | null = null
const FILL_LIMIT = 200_000 // safety guard to prevent freezes

/**
 * Bresenham's Line Algorithm for smooth drawing
 * Draws a line of particles between (x0, y0) and (x1, y1)
 */
function drawLine(x0: number, y0: number, x1: number, y1: number, radius: number, elementType: number, isErase: boolean) {
  if (!engine) return
  
  const dx = Math.abs(x1 - x0)
  const dy = Math.abs(y1 - y0)
  const sx = (x0 < x1) ? 1 : -1
  const sy = (y0 < y1) ? 1 : -1
  let err = dx - dy

  while (true) {
    // Apply brush at current point
    if (isErase) {
      engine.remove_particles_in_radius(x0, y0, radius)
    } else {
      engine.add_particles_in_radius(x0, y0, radius, elementType)
    }

    if (x0 === x1 && y0 === y1) break
    
    const e2 = 2 * err
    if (e2 > -dy) { err -= dy; x0 += sx }
    if (e2 < dx) { err += dx; y0 += sy }
  }
}

/**
 * Phase 5: Process all pending input from shared buffer
 * Called every frame before physics step
 * Uses Bresenham interpolation for smooth lines!
 * 
 * Phase 3 (Fort Knox): Handles overflow - resets Bresenham to prevent artifacts
 */
function processSharedInput() {
  if (!sharedInputBuffer || !engine) return
  
  // Phase 3 (Fort Knox): Check for buffer overflow
  // If overflow occurred, reset Bresenham state to prevent line artifacts
  // (e.g., line drawn from last known point to current point across the screen)
  if (sharedInputBuffer.checkAndClearOverflow()) {
    console.warn('ðŸ”’ Input buffer overflow detected - resetting Bresenham state')
    lastInputX = null
    lastInputY = null
  }
  
  // Read all events accumulated since last frame (zero-allocation!)
  sharedInputBuffer.processAll((x, y, type, val) => {
    // CRITICAL: Handle end-stroke sentinel FIRST - resets Bresenham state
    // This goes through the same SAB channel as brush events, so no race conditions!
    if (type === INPUT_TYPE_END_STROKE) {
      lastInputX = null
      lastInputY = null
      return
    }
    
    const currentX = Math.floor(x)
    const currentY = Math.floor(y)
    
    const isErase = (type === INPUT_TYPE_ERASE)
    const elementType = isErase ? 0 : (type - INPUT_TYPE_BRUSH_OFFSET)

    // Guard against malformed element ids
    if (!isErase && elementType <= 0) {
      return
    }

    // If this is a new stroke or we lost tracking, start here
    if (lastInputX === null || lastInputY === null) {
      lastInputX = currentX
      lastInputY = currentY
      // Draw single point
      if (isErase) {
        engine.remove_particles_in_radius(currentX, currentY, val)
      } else if (elementType !== 0) {
        engine.add_particles_in_radius(currentX, currentY, val, elementType)
      }
      return
    }

    // Interpolate line from last known position to current
    if (elementType !== 0 || isErase) {
      drawLine(lastInputX, lastInputY, currentX, currentY, val, elementType, isErase)
    }

    // Update tracking
    lastInputX = currentX
    lastInputY = currentY
  })
}

/**
 * Reset input tracking (called on mouse up)
 */
function resetInputTracking() {
  lastInputX = null
  lastInputY = null
}

function captureSnapshot(): ArrayBuffer | null {
  if (!memoryManager || !engine) return null
  const types = memoryManager.types
  // Copy into new ArrayBuffer to transfer
  return new Uint8Array(types).buffer
}

function loadSnapshotBuffer(buffer: ArrayBuffer) {
  if (!engine || !wasmModule) return
  const types = new Uint8Array(buffer)
  const width = engine.width as number
  const height = engine.height as number
  const expected = width * height
  if (types.length !== expected) {
    console.warn('Snapshot size mismatch, skipping load')
    return
  }
  // Reset world
  engine = new wasmModule.World(width, height)
  updateMemoryViews()
  // Re-apply particles
  for (let i = 0; i < types.length; i++) {
    const elId = types[i]
    if (elId === 0) continue
    const x = i % width
    const y = Math.floor(i / width)
    engine.add_particle(x, y, elId)
  }
  // Force full upload on renderer next frame
  if (renderer) renderer.requestFullUpload()
}

/**
 * Read element at world coordinate
 */
function readElementAt(x: number, y: number): ElementType | null {
  if (!memoryManager || !engine) return null
  const width = engine.width as number
  const height = engine.height as number
  if (x < 0 || y < 0 || x >= width || y >= height) return null
  const types = memoryManager.types
  const idx = y * width + x
  const elId = types[idx] ?? 0
  return ELEMENT_ID_TO_NAME[elId] ?? null
}

/**
 * Flood fill contiguous area of the same element id
 */
function floodFill(startX: number, startY: number, targetElementId: number) {
  if (!memoryManager || !engine) return
  const width = engine.width as number
  const height = engine.height as number
  if (startX < 0 || startY < 0 || startX >= width || startY >= height) return

  const types = memoryManager.types
  const startIdx = startY * width + startX
  const sourceId = types[startIdx] ?? 0

  // nothing to do
  if (sourceId === targetElementId) return

  const visited = new Uint8Array(width * height)
  const stack: Array<{ x: number; y: number }> = [{ x: startX, y: startY }]
  let processed = 0

  while (stack.length > 0) {
    const { x, y } = stack.pop() as { x: number; y: number }
    if (x < 0 || y < 0 || x >= width || y >= height) continue
    const idx = y * width + x
    if (visited[idx]) continue
    if (types[idx] !== sourceId) continue

    visited[idx] = 1
    processed++
    if (processed > FILL_LIMIT) break

    // Replace
    if (targetElementId === 0) {
      engine.remove_particle(x, y)
    } else {
      // If there is something else, remove then add to ensure overwrite
      engine.remove_particle(x, y)
      engine.add_particle(x, y, targetElementId)
    }

    stack.push({ x: x + 1, y })
    stack.push({ x: x - 1, y })
    stack.push({ x, y: y + 1 })
    stack.push({ x, y: y - 1 })
  }
}

// ============================================================================
// STATS
// ============================================================================

function sendStats() {
  // Calculate average FPS (zero allocation)
  let sum = 0
  for (let i = 0; i < fpsCount; i++) {
    sum += fpsBuffer[i]
  }
  const avgFps = fpsCount > 0 ? sum / fpsCount : 0
  
  const particleCount = engine?.particle_count ?? 0
  
  self.postMessage({
    type: 'STATS',
    fps: Math.round(avgFps),
    particleCount
  })
}

// ============================================================================
// MESSAGE HANDLER
// ============================================================================

self.onmessage = (e: MessageEvent<WorkerMessage>) => {
  const msg = e.data
  
  switch (msg.type) {
    case 'INIT':
      initEngine(msg.canvas, msg.width, msg.height, msg.inputBuffer)
      break
      
    case 'PLAY':
      isPlaying = true
      break
      
    case 'PAUSE':
      isPlaying = false
      break
      
    case 'STEP':
      if (engine) {
        engine.step()
        updateMemoryViews()
      }
      break
    
    case 'FILL': {
      if (!engine || !memoryManager) break
      const elementId = ELEMENT_MAP[msg.element] ?? 0
      floodFill(msg.x, msg.y, elementId)
      break
    }
    
    case 'SPAWN_RIGID_BODY': {
      if (!engine) break
      const elementId = ELEMENT_MAP[msg.element] ?? 1 // Default to stone
      if (msg.shape === 'circle') {
        engine.spawn_rigid_circle(msg.x, msg.y, Math.floor(msg.size / 2), elementId)
      } else {
        engine.spawn_rigid_body(msg.x, msg.y, msg.size, msg.size, elementId)
      }
      break
    }
    
    case 'PIPETTE': {
      const viewport = canvas ? { width: canvas.width, height: canvas.height } : { width: 0, height: 0 }
      const world = invertTransform(
        msg.x,
        msg.y,
        { zoom, panX, panY },
        viewport
      )
      const worldX = Math.floor(world.x)
      const worldY = Math.floor(world.y)
      const element = readElementAt(worldX, worldY)
      self.postMessage({ type: 'PIPETTE_RESULT', id: msg.id, element })
      break
    }
    
    case 'SNAPSHOT': {
      const buffer = captureSnapshot()
      if (buffer) {
        self.postMessage({ type: 'SNAPSHOT_RESULT', id: msg.id, buffer }, { transfer: [buffer] })
      } else {
        self.postMessage({ type: 'SNAPSHOT_RESULT', id: msg.id, buffer: null })
      }
      break
    }
    
    case 'LOAD_SNAPSHOT': {
      loadSnapshotBuffer(msg.buffer)
      break
    }
      
    case 'INPUT':
      handleInput(msg.x, msg.y, msg.radius, msg.element, msg.tool, msg.brushShape ?? 'circle')
      break
      
    case 'INPUT_END':
      // Phase 5: Reset Bresenham line tracking on mouse up
      resetInputTracking()
      break
      
    case 'TRANSFORM':
      zoom = msg.zoom
      panX = msg.panX
      panY = msg.panY
      break
      
    case 'SETTINGS':
      if (msg.gravity && engine) {
        engine.set_gravity(msg.gravity.x, msg.gravity.y)
      }
      if (msg.ambientTemperature !== undefined && engine) {
        engine.set_ambient_temperature(msg.ambientTemperature)
      }
      if (msg.speed !== undefined) {
        speed = msg.speed
      }
      break
      
    case 'SET_RENDER_MODE':
      renderMode = msg.mode
      // Force full texture upload when returning to normal mode
      if (renderMode === 'normal' && useWebGL && renderer) {
        renderer.requestFullUpload()
      }
      break
      
    case 'CLEAR':
      if (engine) {
        engine.clear()
      }
      break
      
    case 'RESIZE':
      if (engine && canvas) {
        // CRITICAL: Force integer sizes to prevent "falling through" bug
        const w = Math.floor(msg.width)
        const h = Math.floor(msg.height)
        
        // Check if size actually changed
        if (w === canvas.width && h === canvas.height) break
        
        // Recreate world with new size
        engine = new wasmModule.World(w, h)
        canvas.width = w
        canvas.height = h
        
        // Phase 3: Resize WebGL renderer
        if (useWebGL && renderer) {
          renderer.resize(w, h)
        } else if (ctx) {
          // Canvas2D fallback
          imageData = new ImageData(w, h)
          pixels = imageData.data
          pixels32 = new Uint32Array(pixels.buffer)
        }
        
        updateMemoryViews()
        console.log(`âš¡ Resized World to: ${w}x${h}`)
      }
      break
  }
}

// Export empty to make it a module
export {}

--- End of File: apps/web/src/workers/simulation.worker.ts ---


--- File: apps/web/tsconfig.json ---

{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "types": ["node"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src", "src/lib/engine/WebGLRenderer.ts"],
  "exclude": [
    "src/lib/engine/_LEGACY",
    "src/lib/engine/__tests__"
  ]
}

--- End of File: apps/web/tsconfig.json ---


--- File: apps/web/tsconfig.node.json ---

{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}

--- End of File: apps/web/tsconfig.node.json ---


--- File: definitions/elements.json ---

{
  "$schema": "./elements.schema.json",
  "version": "3.0.0",
  "description": "Single Source of Truth for all element definitions in Particula - Phase 2 Newtonian Physics",
  
  "flags": {
    "FLAG_NONE":           0,
    "FLAG_FLAMMABLE":      1,
    "FLAG_CONDUCTIVE":     2,
    "FLAG_LIQUID":         4,
    "FLAG_GAS":            8,
    "FLAG_POWDER":        16,
    "FLAG_SOLID":         32,
    "FLAG_ENERGY":        64,
    "FLAG_UTILITY":      128,
    "FLAG_BIO":          256,
    "FLAG_IGNORE_GRAVITY": 512,
    "FLAG_CORROSIVE":   1024,
    "FLAG_HOT":         2048,
    "FLAG_COLD":        4096,
    "FLAG_RIGID":       8192
  },
  
  "physics": {
    "gravity": 0.5,
    "airFriction": 0.98,
    "maxVelocity": 10.0
  },
  
  "categories": [
    { "id": 0, "name": "solid",   "rustName": "CAT_SOLID" },
    { "id": 1, "name": "powder",  "rustName": "CAT_POWDER" },
    { "id": 2, "name": "liquid",  "rustName": "CAT_LIQUID" },
    { "id": 3, "name": "gas",     "rustName": "CAT_GAS" },
    { "id": 4, "name": "energy",  "rustName": "CAT_ENERGY" },
    { "id": 5, "name": "utility", "rustName": "CAT_UTILITY" },
    { "id": 6, "name": "bio",     "rustName": "CAT_BIO" }
  ],
  
  "elements": [
    {
      "id": 0,
      "name": "empty",
      "rustName": "EL_EMPTY",
      "category": "solid",
      "color": "0xFF0A0A0A",
      "density": 0.0,
      "dispersion": 0,
      "lifetime": 0,
      "defaultTemp": 20.0,
      "heatConductivity": 5,
      "flammable": false,
      "conductive": false,
      "hidden": true
    },
    {
      "id": 1,
      "name": "stone",
      "rustName": "EL_STONE",
      "category": "solid",
      "color": "0xFF808080",
      "density": 2500.0,
      "dispersion": 0,
      "lifetime": 0,
      "defaultTemp": 20.0,
      "heatConductivity": 10,
      "flammable": false,
      "conductive": false,
      "phaseChange": { "high": { "temp": 900.0, "to": "lava" } }
    },
    {
      "id": 2,
      "name": "sand",
      "rustName": "EL_SAND",
      "category": "powder",
      "color": "0xFFC2B280",
      "density": 1600.0,
      "dispersion": 0,
      "lifetime": 0,
      "defaultTemp": 20.0,
      "heatConductivity": 15,
      "flammable": false,
      "conductive": false,
      "phaseChange": { "high": { "temp": 1700.0, "to": "lava" } }
    },
    {
      "id": 3,
      "name": "wood",
      "rustName": "EL_WOOD",
      "category": "solid",
      "color": "0xFF8B4513",
      "density": 600.0,
      "dispersion": 0,
      "lifetime": 0,
      "defaultTemp": 20.0,
      "heatConductivity": 5,
      "flammable": true,
      "conductive": false
    },
    {
      "id": 4,
      "name": "metal",
      "rustName": "EL_METAL",
      "category": "solid",
      "color": "0xFFA9A9A9",
      "density": 7800.0,
      "dispersion": 0,
      "lifetime": 0,
      "defaultTemp": 20.0,
      "heatConductivity": 90,
      "flammable": false,
      "conductive": true,
      "phaseChange": { "high": { "temp": 1500.0, "to": "lava" } }
    },
    {
      "id": 5,
      "name": "ice",
      "rustName": "EL_ICE",
      "category": "solid",
      "color": "0xFFA5F2F3",
      "density": 916.0,
      "dispersion": 0,
      "lifetime": 0,
      "defaultTemp": -10.0,
      "heatConductivity": 20,
      "flammable": false,
      "conductive": false,
      "phaseChange": { "high": { "temp": 0.0, "to": "water" } }
    },
    {
      "id": 6,
      "name": "water",
      "rustName": "EL_WATER",
      "category": "liquid",
      "color": "0xFF4169E1",
      "density": 1000.0,
      "dispersion": 8,
      "lifetime": 0,
      "defaultTemp": 20.0,
      "heatConductivity": 40,
      "flammable": false,
      "conductive": true,
      "phaseChange": {
        "high": { "temp": 100.0, "to": "steam" },
        "low": { "temp": 0.0, "to": "ice" }
      }
    },
    {
      "id": 7,
      "name": "oil",
      "rustName": "EL_OIL",
      "category": "liquid",
      "color": "0xFF4A4A2A",
      "density": 800.0,
      "dispersion": 5,
      "lifetime": 0,
      "defaultTemp": 20.0,
      "heatConductivity": 15,
      "flammable": true,
      "conductive": false
    },
    {
      "id": 8,
      "name": "lava",
      "rustName": "EL_LAVA",
      "category": "liquid",
      "color": "0xFFFF4500",
      "density": 2500.0,
      "dispersion": 2,
      "lifetime": 0,
      "defaultTemp": 1000.0,
      "heatConductivity": 30,
      "flammable": false,
      "conductive": false,
      "phaseChange": { "low": { "temp": 700.0, "to": "stone" } }
    },
    {
      "id": 9,
      "name": "acid",
      "rustName": "EL_ACID",
      "category": "liquid",
      "color": "0xFF39FF14",
      "density": 1050.0,
      "dispersion": 5,
      "lifetime": 0,
      "defaultTemp": 20.0,
      "heatConductivity": 35,
      "flammable": false,
      "conductive": true
    },
    {
      "id": 10,
      "name": "steam",
      "rustName": "EL_STEAM",
      "category": "gas",
      "color": "0xB4E0E0E0",
      "density": 0.6,
      "dispersion": 6,
      "lifetime": 0,
      "defaultTemp": 100.0,
      "heatConductivity": 10,
      "flammable": false,
      "conductive": false,
      "phaseChange": { "low": { "temp": 90.0, "to": "water" } }
    },
    {
      "id": 11,
      "name": "smoke",
      "rustName": "EL_SMOKE",
      "category": "gas",
      "color": "0xC83F3F3F",
      "density": 1.1,
      "dispersion": 4,
      "lifetime": 0,
      "defaultTemp": 50.0,
      "heatConductivity": 5,
      "flammable": false,
      "conductive": false
    },
    {
      "id": 12,
      "name": "fire",
      "rustName": "EL_FIRE",
      "category": "energy",
      "color": "0xFFFF6600",
      "density": 0.3,
      "dispersion": 0,
      "lifetime": 60,
      "defaultTemp": 800.0,
      "heatConductivity": 50,
      "flammable": false,
      "conductive": false
    },
    {
      "id": 13,
      "name": "spark",
      "rustName": "EL_SPARK",
      "category": "energy",
      "color": "0xFFFFFF00",
      "density": 0.1,
      "dispersion": 0,
      "lifetime": 10,
      "defaultTemp": 500.0,
      "heatConductivity": 50,
      "flammable": false,
      "conductive": false
    },
    {
      "id": 14,
      "name": "electricity",
      "rustName": "EL_ELECTRICITY",
      "category": "energy",
      "color": "0xFF00FFFF",
      "density": 0.0,
      "dispersion": 0,
      "lifetime": 3,
      "defaultTemp": 200.0,
      "heatConductivity": 80,
      "flammable": false,
      "conductive": false
    },
    {
      "id": 15,
      "name": "gunpowder",
      "rustName": "EL_GUNPOWDER",
      "category": "powder",
      "color": "0xFF404040",
      "density": 1400.0,
      "dispersion": 0,
      "lifetime": 0,
      "defaultTemp": 20.0,
      "heatConductivity": 10,
      "flammable": true,
      "conductive": false
    },
    {
      "id": 16,
      "name": "clone",
      "rustName": "EL_CLONE",
      "category": "utility",
      "color": "0xFF00FF00",
      "density": "Infinity",
      "dispersion": 0,
      "lifetime": 0,
      "defaultTemp": 20.0,
      "heatConductivity": 0,
      "flammable": false,
      "conductive": false
    },
    {
      "id": 17,
      "name": "void",
      "rustName": "EL_VOID",
      "category": "utility",
      "color": "0xFF000000",
      "density": "Infinity",
      "dispersion": 0,
      "lifetime": 0,
      "defaultTemp": 20.0,
      "heatConductivity": 0,
      "flammable": false,
      "conductive": false
    },
    {
      "id": 18,
      "name": "dirt",
      "rustName": "EL_DIRT",
      "category": "powder",
      "color": "0xFF5C4033",
      "density": 1200.0,
      "dispersion": 0,
      "lifetime": 0,
      "defaultTemp": 20.0,
      "heatConductivity": 10,
      "flammable": false,
      "conductive": false
    },
    {
      "id": 19,
      "name": "seed",
      "rustName": "EL_SEED",
      "category": "bio",
      "color": "0xFFE2C489",
      "density": 1100.0,
      "dispersion": 0,
      "lifetime": 0,
      "defaultTemp": 20.0,
      "heatConductivity": 5,
      "flammable": true,
      "conductive": false
    },
    {
      "id": 20,
      "name": "plant",
      "rustName": "EL_PLANT",
      "category": "bio",
      "color": "0xFF228B22",
      "density": 900.0,
      "dispersion": 0,
      "lifetime": 0,
      "defaultTemp": 20.0,
      "heatConductivity": 10,
      "flammable": true,
      "conductive": false
    }
  ]
}

--- End of File: definitions/elements.json ---


--- File: definitions/reactions.json ---

{
  "$schema": "./reactions.schema.json",
  "version": "1.0.0",
  "description": "Chemical reactions between elements - Data-driven bilateral system",
  
  "reactions": [
    {
      "id": "fire_wood",
      "aggressor": "fire",
      "victim": "wood",
      "result_aggressor": "smoke",
      "result_victim": "fire",
      "chance": 0.10,
      "spawn": "smoke",
      "comment": "Fire spreads to wood, producing smoke"
    },
    {
      "id": "fire_oil",
      "aggressor": "fire",
      "victim": "oil",
      "result_aggressor": "smoke",
      "result_victim": "fire",
      "chance": 0.20,
      "spawn": "smoke",
      "comment": "Oil catches fire easily"
    },
    {
      "id": "fire_water",
      "aggressor": "fire",
      "victim": "water",
      "result_aggressor": "empty",
      "result_victim": "steam",
      "chance": 0.50,
      "spawn": null,
      "comment": "Water extinguishes fire, becomes steam"
    },
    {
      "id": "fire_ice",
      "aggressor": "fire",
      "victim": "ice",
      "result_aggressor": "empty",
      "result_victim": "water",
      "chance": 0.30,
      "spawn": "steam",
      "comment": "Fire melts ice"
    },
    {
      "id": "fire_gunpowder",
      "aggressor": "fire",
      "victim": "gunpowder",
      "result_aggressor": "fire",
      "result_victim": "fire",
      "chance": 1.00,
      "spawn": "smoke",
      "comment": "Gunpowder explodes instantly"
    },
    {
      "id": "fire_plant",
      "aggressor": "fire",
      "victim": "plant",
      "result_aggressor": "smoke",
      "result_victim": "fire",
      "chance": 0.10,
      "spawn": "smoke",
      "comment": "Plants burn like wood"
    },
    {
      "id": "fire_seed",
      "aggressor": "fire",
      "victim": "seed",
      "result_aggressor": "smoke",
      "result_victim": "fire",
      "chance": 0.20,
      "spawn": null,
      "comment": "Seeds burn quickly"
    },
    {
      "id": "lava_water",
      "aggressor": "lava",
      "victim": "water",
      "result_aggressor": "stone",
      "result_victim": "steam",
      "chance": 0.15,
      "spawn": "steam",
      "comment": "Lava cools to stone, water becomes steam"
    },
    {
      "id": "lava_wood",
      "aggressor": "lava",
      "victim": "wood",
      "result_aggressor": null,
      "result_victim": "fire",
      "chance": 0.30,
      "spawn": "smoke",
      "comment": "Lava ignites wood"
    },
    {
      "id": "lava_oil",
      "aggressor": "lava",
      "victim": "oil",
      "result_aggressor": null,
      "result_victim": "fire",
      "chance": 0.40,
      "spawn": "smoke",
      "comment": "Lava ignites oil"
    },
    {
      "id": "lava_ice",
      "aggressor": "lava",
      "victim": "ice",
      "result_aggressor": "stone",
      "result_victim": "steam",
      "chance": 0.30,
      "spawn": null,
      "comment": "Lava melts ice completely"
    },
    {
      "id": "lava_gunpowder",
      "aggressor": "lava",
      "victim": "gunpowder",
      "result_aggressor": null,
      "result_victim": "fire",
      "chance": 1.00,
      "spawn": "smoke",
      "comment": "Gunpowder explodes from lava heat"
    },
    {
      "id": "lava_plant",
      "aggressor": "lava",
      "victim": "plant",
      "result_aggressor": null,
      "result_victim": "fire",
      "chance": 0.50,
      "spawn": "smoke",
      "comment": "Lava burns plants"
    },
    {
      "id": "lava_dirt",
      "aggressor": "lava",
      "victim": "dirt",
      "result_aggressor": null,
      "result_victim": "stone",
      "chance": 0.05,
      "spawn": null,
      "comment": "Lava slowly hardens dirt to stone"
    },
    {
      "id": "acid_stone",
      "aggressor": "acid",
      "victim": "stone",
      "result_aggressor": "empty",
      "result_victim": "empty",
      "chance": 0.10,
      "spawn": "smoke",
      "comment": "Acid dissolves stone"
    },
    {
      "id": "acid_metal",
      "aggressor": "acid",
      "victim": "metal",
      "result_aggressor": "empty",
      "result_victim": "empty",
      "chance": 0.05,
      "spawn": null,
      "comment": "Acid slowly dissolves metal"
    },
    {
      "id": "acid_wood",
      "aggressor": "acid",
      "victim": "wood",
      "result_aggressor": "empty",
      "result_victim": "empty",
      "chance": 0.20,
      "spawn": null,
      "comment": "Acid dissolves wood"
    },
    {
      "id": "acid_ice",
      "aggressor": "acid",
      "victim": "ice",
      "result_aggressor": "empty",
      "result_victim": "water",
      "chance": 0.20,
      "spawn": null,
      "comment": "Acid melts ice to water"
    },
    {
      "id": "acid_plant",
      "aggressor": "acid",
      "victim": "plant",
      "result_aggressor": "empty",
      "result_victim": "empty",
      "chance": 0.15,
      "spawn": null,
      "comment": "Acid dissolves plants"
    },
    {
      "id": "acid_dirt",
      "aggressor": "acid",
      "victim": "dirt",
      "result_aggressor": "empty",
      "result_victim": "empty",
      "chance": 0.05,
      "spawn": null,
      "comment": "Acid dissolves dirt slowly"
    },
    {
      "id": "water_lava",
      "aggressor": "water",
      "victim": "lava",
      "result_aggressor": "steam",
      "result_victim": "stone",
      "chance": 0.15,
      "spawn": "steam",
      "comment": "Water cools lava to stone"
    },
    {
      "id": "water_fire",
      "aggressor": "water",
      "victim": "fire",
      "result_aggressor": "steam",
      "result_victim": "empty",
      "chance": 0.30,
      "spawn": null,
      "comment": "Water extinguishes fire"
    }
  ]
}

--- End of File: definitions/reactions.json ---


--- File: package.json ---

{
  "name": "particula",
  "version": "0.1.0",
  "private": true,
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "scripts": {
    "dev": "turbo run dev",
    "build": "turbo run build",
    "codegen": "node scripts/generate-elements.js",
    "build:wasm": "npm run codegen && cd packages/engine && wasm-pack build --target web --out-dir ../engine-wasm",
    "lint": "turbo run lint",
    "clean": "turbo run clean && rm -rf node_modules"
  },
  "devDependencies": {
    "turbo": "latest",
    "typescript": "latest"
  },
  "packageManager": "npm@10.8.0",
  "engines": {
    "node": ">=20.0.0"
  }
}

--- End of File: package.json ---


--- File: packages/engine/src/behaviors/energy.rs ---

//! EnergyBehavior - Physics for energy particles (fire, spark, electricity)
//! 
//! Port from: apps/web/src/lib/engine/behaviors/EnergyBehavior.ts
//! PHASE 1: Optimized with unsafe access after bounds check
//! 
//! Fire rises erratically, spark/electricity move through conductors

use super::{Behavior, UpdateContext, xorshift32};
use crate::elements::{EL_EMPTY, EL_FIRE, EL_SPARK, EL_ELECTRICITY};

pub struct EnergyBehavior;

impl EnergyBehavior {
    pub fn new() -> Self {
        Self
    }
    
    /// Fire rises erratically (mirrors TypeScript updateFire)
    /// PHASE 1: Uses unsafe after bounds check
    #[inline]
    fn update_fire(&self, ctx: &mut UpdateContext) {
        let x = ctx.x;
        let y = ctx.y;
        let xi = x as i32;
        let yi = y as i32;
        
        // Fire drifts mostly upward but can spread sideways a bit.
        let rand = xorshift32(ctx.rng);
        let lateral = if rand & 1 == 0 { -1 } else { 1 };
        
        // Randomize attempt order to avoid straight pillars
        let attempts = match rand & 3 {
            0 => [(0, -1), (lateral, -1), (lateral, 0), (-lateral, 0)],
            1 => [(lateral, -1), (0, -1), (-lateral, -1), (lateral, 0)],
            2 => [(0, -1), (-lateral, -1), (lateral, 0), (-lateral, 0)],
            _ => [(lateral, 0), (0, -1), (lateral, -1), (-lateral, -1)],
        };
        
        for (dx, dy) in attempts {
            let tx = xi + dx;
            let ty = yi + dy;
            if !ctx.grid.in_bounds(tx, ty) { continue; }
            
            // SAFETY: bounds checked above
            let target = unsafe { ctx.grid.get_type_unchecked(tx as u32, ty as u32) };
            if target == EL_EMPTY {
                unsafe { ctx.grid.swap_unchecked(x, y, tx as u32, ty as u32); }
                break;
            }
        }
    }
    
    /// Spark is handled by lifetime, no movement (mirrors TypeScript)
    #[inline]
    fn update_spark(&self, _ctx: &mut UpdateContext) {
        // Spark is handled by lifetime, no movement needed
    }
    
    /// Electricity is handled by lifetime (mirrors TypeScript)
    #[inline]
    fn update_electricity(&self, _ctx: &mut UpdateContext) {
        // Electricity is handled by lifetime
    }
}

impl Behavior for EnergyBehavior {
    fn update(&self, ctx: &mut UpdateContext) {
        // SAFETY: x,y come from update_particle_chunked which guarantees valid coords
        let element = unsafe { ctx.grid.get_type_unchecked(ctx.x, ctx.y) };
        if element == EL_EMPTY { return; }
        
        match element {
            EL_FIRE => self.update_fire(ctx),
            EL_SPARK => self.update_spark(ctx),
            EL_ELECTRICITY => self.update_electricity(ctx),
            _ => {}
        }
    }
}

--- End of File: packages/engine/src/behaviors/energy.rs ---


--- File: packages/engine/src/behaviors/gas.rs ---

//! GasBehavior - Pure dispersion-based gas physics
//! 
//! Port from: apps/web/src/lib/engine/behaviors/GasBehavior.ts
//! PHASE 1: Optimized with unsafe access after bounds check
//! 
//! Philosophy:
//! - Gases are "inverted liquids" - they rise instead of fall
//! - Scan & teleport horizontally to find "chimneys" (openings above)
//! - Can bubble up through liquids and powders (density-based)

use super::{Behavior, UpdateContext, get_random_dir, xorshift32};
use crate::elements::{ELEMENT_DATA, EL_EMPTY, CAT_SOLID};

/// Result of scanning ceiling for chimneys
struct ScanResult {
    found: bool,
    x: i32,
    has_chimney: bool,
}

pub struct GasBehavior;

impl GasBehavior {
    pub fn new() -> Self {
        Self
    }
    
    /// Try to rise to target cell (mirrors TypeScript tryRise)
    /// PHASE 1: Uses unsafe after bounds check
    #[inline]
    fn try_rise(&self, ctx: &mut UpdateContext, from_x: u32, from_y: u32, to_x: i32, to_y: i32, my_density: f32) -> bool {
        if !ctx.grid.in_bounds(to_x, to_y) { return false; }
        
        // SAFETY: We just checked in_bounds above
        let target_type = unsafe { ctx.grid.get_type_unchecked(to_x as u32, to_y as u32) };
        
        // Empty cell - just rise
        if target_type == EL_EMPTY {
            unsafe { ctx.grid.swap_unchecked(from_x, from_y, to_x as u32, to_y as u32); }
            return true;
        }
        
        // Bounds check
        if (target_type as usize) >= ELEMENT_DATA.len() { return false; }
        
        // Can we bubble through? (target must be heavier and not solid)
        let t_cat = ELEMENT_DATA[target_type as usize].category;
        
        if t_cat != CAT_SOLID {
            let t_density = ELEMENT_DATA[target_type as usize].density;
            if t_density > my_density {
                unsafe { ctx.grid.swap_unchecked(from_x, from_y, to_x as u32, to_y as u32); }
                return true;
            }
        }
        
        false
    }
    
    /// Scan ceiling for chimneys (mirrors TypeScript scanCeiling)
    /// PHASE 1: Uses unsafe after bounds check
    #[inline]
    fn scan_ceiling(&self, ctx: &UpdateContext, start_x: i32, y: i32, dir: i32, range: i32, my_density: f32) -> ScanResult {
        let mut best_x = start_x;
        let mut found = false;
        let mut has_chimney = false;
        
        for i in 1..=range {
            let tx = start_x + (dir * i);
            
            if !ctx.grid.in_bounds(tx, y) { break; }
            
            // SAFETY: We just checked in_bounds above
            let target_type = unsafe { ctx.grid.get_type_unchecked(tx as u32, y as u32) };
            
            // CASE 1: Empty cell
            if target_type == EL_EMPTY {
                best_x = tx;
                found = true;
                
                // Check for chimney above
                let above_y = y - 1;
                if ctx.grid.in_bounds(tx, above_y) {
                    // SAFETY: We just checked in_bounds above
                    let above_type = unsafe { ctx.grid.get_type_unchecked(tx as u32, above_y as u32) };
                    if above_type == EL_EMPTY {
                        has_chimney = true;
                        break;
                    }
                    if (above_type as usize) < ELEMENT_DATA.len() {
                        if ELEMENT_DATA[above_type as usize].density > my_density {
                            has_chimney = true;
                            break;
                        }
                    }
                }
                continue;
            }
            
            // Bounds check
            if (target_type as usize) >= ELEMENT_DATA.len() { break; }
            
            // CASE 2: Occupied - can we displace it?
            let t_cat = ELEMENT_DATA[target_type as usize].category;
            
            if t_cat != CAT_SOLID {
                let t_density = ELEMENT_DATA[target_type as usize].density;
                if t_density > my_density {
                    best_x = tx;
                    found = true;
                    break;
                }
            }
            
            // CASE 3: Wall or lighter/same gas - stop
            break;
        }
        
        ScanResult { found, x: best_x, has_chimney }
    }
}

impl Behavior for GasBehavior {
    fn update(&self, ctx: &mut UpdateContext) {
        let x = ctx.x;
        let y = ctx.y;
        let xi = x as i32;
        let yi = y as i32;
        
        // SAFETY: x,y come from update_particle_chunked which guarantees valid coords
        let element = unsafe { ctx.grid.get_type_unchecked(x, y) };
        if element == EL_EMPTY { return; }
        if (element as usize) >= ELEMENT_DATA.len() { return; }
        
        let props = &ELEMENT_DATA[element as usize];
        let density = props.density;
        // Match TypeScript: props.dispersion || 5 (fallback to 5 if 0)
        let range = if props.dispersion > 0 { props.dispersion as i32 } else { 5 };
        
        let (dx1, dx2) = get_random_dir(ctx.frame, x);
        
        // --- 1. Rise UP (against gravity) ---
        if self.try_rise(ctx, x, y, xi, yi - 1, density) { return; }
        
        // --- 2. Rise DIAGONALLY ---
        if self.try_rise(ctx, x, y, xi + dx1, yi - 1, density) { return; }
        if self.try_rise(ctx, x, y, xi + dx2, yi - 1, density) { return; }
        
        // --- 3. Dispersion: Scan ceiling for chimneys (EXACT TypeScript) ---
        let left_target = self.scan_ceiling(ctx, xi, yi, -1, range, density);
        let right_target = self.scan_ceiling(ctx, xi, yi, 1, range, density);
        
        let target_x = if left_target.found && right_target.found {
            if left_target.has_chimney && !right_target.has_chimney {
                left_target.x
            } else if !left_target.has_chimney && right_target.has_chimney {
                right_target.x
            } else {
                // Random choice
                let rand = xorshift32(ctx.rng);
                if rand & 1 == 0 { left_target.x } else { right_target.x }
            }
        } else if left_target.found {
            left_target.x
        } else if right_target.found {
            right_target.x
        } else {
            xi
        };
        
        if target_x != xi {
            // SAFETY: target_x comes from scan_ceiling which verified bounds
            unsafe { ctx.grid.swap_unchecked(x, y, target_x as u32, y); }
        }
    }
}

--- End of File: packages/engine/src/behaviors/gas.rs ---


--- File: packages/engine/src/behaviors/liquid.rs ---

//! LiquidBehavior - Horizontal dispersion only
//! 
//! Phase 2: Vertical movement handled by physics.rs
//! 
//! Philosophy:
//! - No mass, no pressure formulas - just discrete particle movement
//! - Liquids "scan & teleport" up to N cells horizontally (dispersion rate)
//! - Prioritizes falling into holes/cliffs for waterfall effect
//! - Heavier liquids can push lighter ones horizontally for level equalization
//! 
//! Phase 2: Vertical falling is now done by velocity-based physics

use super::{Behavior, UpdateContext, xorshift32};
use crate::elements::{ELEMENT_DATA, EL_EMPTY, CAT_LIQUID, CAT_GAS};

/// Result of scanning a horizontal line
struct ScanResult {
    found: bool,
    x: i32,
    has_cliff: bool,
}

pub struct LiquidBehavior;

impl LiquidBehavior {
    pub fn new() -> Self {
        Self
    }
    
    /// Try to move liquid to target cell (mirrors TypeScript tryMove)
    /// PHASE 1: Uses unsafe after bounds check
    #[inline]
    fn try_move(&self, ctx: &mut UpdateContext, from_x: u32, from_y: u32, to_x: i32, to_y: i32, my_density: f32) -> bool {
        if !ctx.grid.in_bounds(to_x, to_y) { return false; }
        
        // SAFETY: We just checked in_bounds above
        let target_type = unsafe { ctx.grid.get_type_unchecked(to_x as u32, to_y as u32) };
        
        // Empty cell - just move
        if target_type == EL_EMPTY {
            // SAFETY: Both coords verified (from_x/from_y from caller, to_x/to_y from in_bounds)
            unsafe { ctx.grid.swap_unchecked(from_x, from_y, to_x as u32, to_y as u32); }
            return true;
        }
        
        // Bounds check
        if (target_type as usize) >= ELEMENT_DATA.len() { return false; }
        
        // Check if we can displace (heavier sinks into lighter)
        let t_cat = ELEMENT_DATA[target_type as usize].category;
        if t_cat == CAT_LIQUID || t_cat == CAT_GAS {
            if my_density > ELEMENT_DATA[target_type as usize].density {
                unsafe { ctx.grid.swap_unchecked(from_x, from_y, to_x as u32, to_y as u32); }
                return true;
            }
        }
        
        false
    }
    
    /// Scan horizontally for empty cells or cliffs (mirrors TypeScript scanLine)
    /// PHASE 1: Uses unsafe after bounds check
    #[inline]
    fn scan_line(&self, ctx: &UpdateContext, start_x: i32, y: i32, dir: i32, range: i32, my_density: f32) -> ScanResult {
        let mut best_x = start_x;
        let mut found = false;
        let mut has_cliff = false;

        let gy = if ctx.gravity_y > 0.0 { 1 } else if ctx.gravity_y < 0.0 { -1 } else { 0 };
        let gravity_y = if gy == 0 { 1 } else { gy }; // default downward when zero
        
        for i in 1..=range {
            let tx = start_x + (dir * i);
            
            if !ctx.grid.in_bounds(tx, y) { break; }
            
            // SAFETY: We just checked in_bounds above
            let target_type = unsafe { ctx.grid.get_type_unchecked(tx as u32, y as u32) };
            
            // CASE 1: Empty cell
            if target_type == EL_EMPTY {
                best_x = tx;
                found = true;
                
                // Check for cliff below (waterfall effect)
                let below_y = y + gravity_y;
                if ctx.grid.in_bounds(tx, below_y) {
                    // SAFETY: We just checked in_bounds above
                    let below_type = unsafe { ctx.grid.get_type_unchecked(tx as u32, below_y as u32) };
                    if below_type == EL_EMPTY {
                        has_cliff = true;
                        break;
                    }
                }
                continue;
            }
            
            // Bounds check
            if (target_type as usize) >= ELEMENT_DATA.len() { break; }
            
            // CASE 2: Occupied cell - check if we can displace
            let t_cat = ELEMENT_DATA[target_type as usize].category;
            
            if t_cat == CAT_LIQUID || t_cat == CAT_GAS {
                let t_density = ELEMENT_DATA[target_type as usize].density;
                
                if my_density > t_density {
                    best_x = tx;
                    found = true;
                    break;
                }
            }
            
            // CASE 3: Wall or same/heavier liquid - stop scanning
            break;
        }
        
        ScanResult { found, x: best_x, has_cliff }
    }
}

impl Behavior for LiquidBehavior {
    fn update(&self, ctx: &mut UpdateContext) {
        let x = ctx.x;
        let y = ctx.y;
        let xi = x as i32;
        let yi = y as i32;
        
        let element = unsafe { ctx.grid.get_type_unchecked(x, y) };
        if element == EL_EMPTY { return; }
        if (element as usize) >= ELEMENT_DATA.len() { return; }
        
        let props = &ELEMENT_DATA[element as usize];
        let density = props.density;
        let range = if props.dispersion > 0 { props.dispersion as i32 } else { 5 };

        // Gravity direction (sign)
        let gy = if ctx.gravity_y > 0.0 { 1 } else if ctx.gravity_y < 0.0 { -1 } else { 0 };
        let gravity_y = if gy == 0 { 1 } else { gy }; // fallback to downwards when gravity is zero
        
        // Phase 2: Check if we should do dispersion
        // We disperse when:
        // 1. At boundary in gravity direction
        // 2. Blocked by solid/heavy particle in gravity direction
        // 3. Has very low velocity (settled/resting state)
        let adj_y = yi + gravity_y;
        
        // Check velocity - if we have significant velocity in gravity direction, let physics handle it
        let idx = ctx.grid.index(x, y);
        let vy = ctx.grid.vy[idx];
        let moving_in_gravity_dir = if gy > 0 { vy > 0.3 } else if gy < 0 { vy < -0.3 } else { false };
        
        // If actively moving in gravity direction with velocity, skip dispersion - physics will handle it
        if moving_in_gravity_dir {
            return;
        }
        
        let blocked_in_gravity_dir = if !ctx.grid.in_bounds(xi, adj_y) {
            true // boundary is blocking
        } else {
            let adj_type = unsafe { ctx.grid.get_type_unchecked(x, adj_y as u32) };
            // Blocked if cell in gravity direction is occupied (not empty)
            adj_type != EL_EMPTY
        };
        
        // If not blocked and not moving, still try dispersion (particle might be settling)
        // This fixes the issue where particles wait for physics when they should spread
        if !blocked_in_gravity_dir {
            // Check if there's a "cliff" nearby - empty space in gravity direction at neighboring X
            // If so, we should still try to spread towards it
            let has_nearby_cliff = {
                let left_cliff = if ctx.grid.in_bounds(xi - 1, adj_y) {
                    unsafe { ctx.grid.get_type_unchecked((x - 1) as u32, adj_y as u32) == EL_EMPTY }
                } else { false };
                let right_cliff = if ctx.grid.in_bounds(xi + 1, adj_y) {
                    unsafe { ctx.grid.get_type_unchecked((x + 1) as u32, adj_y as u32) == EL_EMPTY }
                } else { false };
                left_cliff || right_cliff
            };
            
            if !has_nearby_cliff {
                return;
            }
        }
        
        // --- Dispersion: Scan & Teleport (EXACT TypeScript algorithm) ---
        let left_target = self.scan_line(ctx, xi, yi, -1, range, density);
        let right_target = self.scan_line(ctx, xi, yi, 1, range, density);
        
        // Choose best target (mirrors TypeScript logic exactly)
        let target_x = if left_target.found && right_target.found {
            if left_target.has_cliff && !right_target.has_cliff {
                left_target.x
            } else if !left_target.has_cliff && right_target.has_cliff {
                right_target.x
            } else {
                let rand = xorshift32(ctx.rng);
                if rand & 1 == 0 { left_target.x } else { right_target.x }
            }
        } else if left_target.found {
            left_target.x
        } else if right_target.found {
            right_target.x
        } else {
            xi
        };
        
        if target_x != xi {
            unsafe { ctx.grid.swap_unchecked(x, y, target_x as u32, y); }
        }
    }
}

--- End of File: packages/engine/src/behaviors/liquid.rs ---


--- File: packages/engine/src/behaviors/mod.rs ---

//! Behaviors - Particle physics implementations
//! 
//! SOLID: Single Responsibility - each behavior handles one particle category
//! SOLID: Open/Closed - new behaviors can be added without modifying existing code
//! 
//! Port from TypeScript: apps/web/src/lib/engine/behaviors/

mod powder;
mod liquid;
mod gas;
mod energy;
mod utility;
mod plant;

pub use powder::PowderBehavior;
pub use liquid::LiquidBehavior;
pub use gas::GasBehavior;
pub use energy::EnergyBehavior;
pub use utility::UtilityBehavior;
pub use plant::PlantBehavior;

use crate::grid::Grid;
use crate::chunks::ChunkGrid;
use crate::elements::{CategoryId, ElementId, CAT_POWDER, CAT_LIQUID, CAT_GAS, CAT_ENERGY, CAT_UTILITY, CAT_BIO};

/// Update context passed to behaviors (mirrors TypeScript UpdateContext)
pub struct UpdateContext<'a> {
    pub grid: &'a mut Grid,
    pub chunks: &'a mut ChunkGrid,
    pub x: u32,
    pub y: u32,
    pub frame: u64,
    pub gravity_x: f32,
    pub gravity_y: f32,
    pub ambient_temp: f32,
    pub rng: &'a mut u32,
}

impl<'a> UpdateContext<'a> {
    #[inline]
    pub fn mark_dirty(&mut self, x: u32, y: u32) {
        self.chunks.mark_dirty(x, y);
    }

    #[inline]
    pub fn set_particle_dirty(&mut self, x: u32, y: u32, element: ElementId, color: u32, life: u16, temp: f32) {
        self.grid.set_particle(x, y, element, color, life, temp);
        self.chunks.mark_dirty(x, y);
    }

    #[inline]
    pub fn clear_cell_dirty(&mut self, x: u32, y: u32) {
        self.grid.clear_cell(x, y);
        self.chunks.mark_dirty(x, y);
    }
}

/// Behavior trait - each category implements this
pub trait Behavior {
    fn update(&self, ctx: &mut UpdateContext);
}

/// Random direction helper (mirrors TypeScript getRandomDirection EXACTLY)
/// TS: const goLeft = (frame + x) & 1; dx1 = goLeft ? -1 : 1
#[inline]
pub fn get_random_dir(frame: u64, x: u32) -> (i32, i32) {
    // TypeScript: goLeft = (frame + x) & 1 -> if truthy (1) then left first
    let go_left = ((frame as u32 + x) & 1) == 1;
    if go_left { (-1, 1) } else { (1, -1) }
}

/// Xorshift32 random number generator
#[inline]
pub fn xorshift32(state: &mut u32) -> u32 {
    let mut x = *state;
    x ^= x << 13;
    x ^= x >> 17;
    x ^= x << 5;
    *state = x;
    x
}

/// Behavior registry - dispatch by category
pub struct BehaviorRegistry {
    powder: PowderBehavior,
    liquid: LiquidBehavior,
    gas: GasBehavior,
    energy: EnergyBehavior,
    utility: UtilityBehavior,
    plant: PlantBehavior,
}

impl BehaviorRegistry {
    pub fn new() -> Self {
        Self {
            powder: PowderBehavior::new(),
            liquid: LiquidBehavior::new(),
            gas: GasBehavior::new(),
            energy: EnergyBehavior::new(),
            utility: UtilityBehavior::new(),
            plant: PlantBehavior::new(),
        }
    }
    
    /// Dispatch update to appropriate behavior based on category
    pub fn update(&self, category: CategoryId, ctx: &mut UpdateContext) {
        match category {
            CAT_POWDER => self.powder.update(ctx),
            CAT_LIQUID => self.liquid.update(ctx),
            CAT_GAS => self.gas.update(ctx),
            CAT_ENERGY => self.energy.update(ctx),
            CAT_UTILITY => self.utility.update(ctx),
            CAT_BIO => self.plant.update(ctx),
            _ => {} // Solid - no behavior
        }
    }
}

impl Default for BehaviorRegistry {
    fn default() -> Self {
        Self::new()
    }
}

--- End of File: packages/engine/src/behaviors/mod.rs ---


--- File: packages/engine/src/behaviors/plant.rs ---

//! PlantBehavior - Agent-based plant growth system
//! 
//! Port from: apps/web/src/lib/engine/behaviors/PlantBehavior.ts
//! EXACT 1:1 port of the TypeScript algorithm
//! 
//! Seed: Falls like powder, germinates when touching dirt + water
//! Plant: Grows upward consuming water, affected by temperature

use super::{Behavior, UpdateContext, get_random_dir, xorshift32};
use crate::elements::{
    ELEMENT_DATA, EL_EMPTY, EL_SEED, EL_PLANT, EL_WATER, EL_DIRT, EL_SAND,
    CAT_LIQUID, get_color_with_variation
};

const SEED_DENSITY: f32 = 1100.0;

/// Grow options with weights (mirrors TypeScript exactly)
const GROW_OPTIONS: [(i32, i32, f32); 3] = [
    (0, -1, 0.6),   // Up - 60%
    (-1, -1, 0.2),  // Up-left - 20%
    (1, -1, 0.2),   // Up-right - 20%
];

pub struct PlantBehavior;

impl PlantBehavior {
    pub fn new() -> Self {
        Self
    }
    
    /// Check if seed can displace target (mirrors TypeScript canSeedDisplace)
    fn can_seed_displace(&self, ctx: &UpdateContext, x: i32, y: i32) -> bool {
        if !ctx.grid.in_bounds(x, y) { return false; }
        
        let target_type = ctx.grid.get_type(x, y);
        if target_type == EL_EMPTY { return true; }
        
        // Bounds check
        if (target_type as usize) >= ELEMENT_DATA.len() { return false; }
        
        let target_cat = ELEMENT_DATA[target_type as usize].category;
        if target_cat == CAT_LIQUID {
            return SEED_DENSITY > ELEMENT_DATA[target_type as usize].density;
        }
        
        false
    }
    
    /// Check if there's water nearby (mirrors TypeScript hasWaterNeighbor)
    fn has_water_neighbor(&self, ctx: &UpdateContext, x: i32, y: i32) -> bool {
        self.find_water(ctx, x, y, 1).is_some()
    }
    
    /// Find water within radius (mirrors TypeScript findWater)
    fn find_water(&self, ctx: &UpdateContext, cx: i32, cy: i32, radius: i32) -> Option<(i32, i32)> {
        for dy in -radius..=radius {
            for dx in -radius..=radius {
                let nx = cx + dx;
                let ny = cy + dy;
                if ctx.grid.in_bounds(nx, ny) {
                    if ctx.grid.get_type(nx, ny) == EL_WATER {
                        return Some((nx, ny));
                    }
                }
            }
        }
        None
    }
    
    /// Transform cell to plant (mirrors TypeScript transformToPlant)
    fn transform_to_plant(&self, ctx: &mut UpdateContext, x: i32, y: i32) {
        let seed = ((x as u32 * 11 + y as u32 * 17 + ctx.frame as u32) & 31) as u8;
        let props = &ELEMENT_DATA[EL_PLANT as usize];
        
        ctx.set_particle_dirty(
            x as u32, y as u32,
            EL_PLANT,
            get_color_with_variation(EL_PLANT, seed),
            props.lifetime,
            20.0  // Room temperature
        );
    }
    
    /// Process seed behavior (mirrors TypeScript processSeed)
    fn process_seed(&self, ctx: &mut UpdateContext) {
        let x = ctx.x;
        let y = ctx.y;
        let xi = x as i32;
        let yi = y as i32;
        
        // 1. Gravity - fall down
        if self.can_seed_displace(ctx, xi, yi + 1) {
            ctx.grid.swap(x, y, x, y + 1);
            return;
        }
        
        // 2. Diagonal falling
        let (dx1, dx2) = get_random_dir(ctx.frame, x);
        if self.can_seed_displace(ctx, xi + dx1, yi + 1) {
            ctx.grid.swap(x, y, (xi + dx1) as u32, y + 1);
            return;
        }
        if self.can_seed_displace(ctx, xi + dx2, yi + 1) {
            ctx.grid.swap(x, y, (xi + dx2) as u32, y + 1);
            return;
        }
        
        // 3. Germination check (EXACT TypeScript logic)
        let below_type = ctx.grid.get_type(xi, yi + 1);
        if below_type == EL_DIRT || below_type == EL_SAND {
            if self.has_water_neighbor(ctx, xi, yi) {
                self.transform_to_plant(ctx, xi, yi);
            }
        }
    }
    
    /// Process plant behavior (mirrors TypeScript processPlant)
    fn process_plant(&self, ctx: &mut UpdateContext) {
        let x = ctx.x;
        let y = ctx.y;
        let xi = x as i32;
        let yi = y as i32;
        
        // Temperature affects growth
        let temp = ctx.grid.get_temp(xi, yi);
        
        // Too cold - no growth
        if temp < 0.0 { return; }
        
        // Too hot - burns
        if temp > 150.0 {
            ctx.clear_cell_dirty(x, y);
            return;
        }
        
        // 5% chance to try growing each frame (EXACT TypeScript: Math.random() > 0.05)
        // PHASE 1 OPT: fast-range reduction instead of % 100
        let rand = ((xorshift32(ctx.rng) as u64 * 100) >> 32) as u32;
        if rand > 5 { return; }
        
        // Check if can grow up
        let can_grow_up = ctx.grid.in_bounds(xi, yi - 1) && ctx.grid.is_empty(xi, yi - 1);
        
        if !can_grow_up {
            // 20% chance to try growing sideways (EXACT TypeScript: Math.random() > 0.2)
            // PHASE 1 OPT: fast-range reduction instead of % 100
            let rand2 = ((xorshift32(ctx.rng) as u64 * 100) >> 32) as u32;
            if rand2 > 20 { return; }
        }
        
        // Find water within radius 3
            if let Some((wx, wy)) = self.find_water(ctx, xi, yi, 3) {
                // Consume water
                ctx.clear_cell_dirty(wx as u32, wy as u32);
            
            // Choose grow direction using weighted random (EXACT TypeScript)
            // PHASE 1 OPT: fast-range reduction instead of % 1000
            let rand3 = ((xorshift32(ctx.rng) as u64 * 1000) >> 32) as u32;
            let rand_f = rand3 as f32 / 1000.0;
            
            let mut cumulative = 0.0;
            let mut chosen = GROW_OPTIONS[0];
            
            for opt in GROW_OPTIONS.iter() {
                cumulative += opt.2;
                if rand_f < cumulative {
                    chosen = *opt;
                    break;
                }
            }
            
            let gx = xi + chosen.0;
            let gy = yi + chosen.1;
            
            if ctx.grid.in_bounds(gx, gy) && ctx.grid.is_empty(gx, gy) {
                self.transform_to_plant(ctx, gx, gy);
            }
        }
    }
}

impl Behavior for PlantBehavior {
    fn update(&self, ctx: &mut UpdateContext) {
        let xi = ctx.x as i32;
        let yi = ctx.y as i32;
        
        let element = ctx.grid.get_type(xi, yi);
        if element == EL_EMPTY { return; }
        
        if element == EL_SEED {
            self.process_seed(ctx);
        } else if element == EL_PLANT {
            self.process_plant(ctx);
        }
    }
}

--- End of File: packages/engine/src/behaviors/plant.rs ---


--- File: packages/engine/src/behaviors/powder.rs ---

//! PowderBehavior - Physics for powder particles (sand, dirt, gunpowder)
//! 
//! Phase 2: Dispersion only - vertical movement handled by physics.rs
//! 
//! Only handles diagonal "rolling" when blocked below.
//! Vertical falling is now done by velocity-based physics.

use super::{Behavior, UpdateContext, get_random_dir};
use crate::elements::{ELEMENT_DATA, EL_EMPTY, CAT_LIQUID};

pub struct PowderBehavior;

impl PowderBehavior {
    pub fn new() -> Self {
        Self
    }
    
    /// Check if powder can move to target cell (for dispersion only)
    #[inline]
    fn can_displace(&self, ctx: &UpdateContext, x: i32, y: i32, my_density: f32) -> bool {
        if !ctx.grid.in_bounds(x, y) { return false; }
        
        let target_type = unsafe { ctx.grid.get_type_unchecked(x as u32, y as u32) };
        
        // Empty = can move
        if target_type == EL_EMPTY { return true; }
        
        if (target_type as usize) >= ELEMENT_DATA.len() { return false; }
        
        let target_cat = ELEMENT_DATA[target_type as usize].category;
        
        // Can only displace liquids, not solids
        if target_cat != CAT_LIQUID { return false; }
        
        // Heavier sinks into lighter
        my_density > ELEMENT_DATA[target_type as usize].density
    }
    
    /// Check if blocked below (for dispersion trigger)
    #[inline]
    fn is_blocked_below(&self, ctx: &UpdateContext, xi: i32, yi: i32, gy: i32) -> bool {
        let ty = yi + gy;
        if !ctx.grid.in_bounds(xi, ty) { return true; }
        
        let below_type = unsafe { ctx.grid.get_type_unchecked(xi as u32, ty as u32) };
        below_type != EL_EMPTY
    }
}

impl Behavior for PowderBehavior {
    fn update(&self, ctx: &mut UpdateContext) {
        let x = ctx.x;
        let y = ctx.y;
        let xi = x as i32;
        let yi = y as i32;
        
        let element = unsafe { ctx.grid.get_type_unchecked(x, y) };
        if element == EL_EMPTY { return; }
        if (element as usize) >= ELEMENT_DATA.len() { return; }
        
        let my_density = ELEMENT_DATA[element as usize].density;
        
        // Get gravity direction
        let gx = if ctx.gravity_x > 0.0 { 1 } else if ctx.gravity_x < 0.0 { -1 } else { 0 };
        let gy = if ctx.gravity_y > 0.0 { 1 } else if ctx.gravity_y < 0.0 { -1 } else { 0 };
        
        if gy == 0 && gx == 0 { return; }
        
        // Phase 2: NO vertical falling here - physics.rs handles that!
        // Only do diagonal dispersion when blocked below
        
        if !self.is_blocked_below(ctx, xi, yi, gy) {
            // Not blocked - physics will handle the fall
            return;
        }
        
        // Blocked below - try to roll diagonally
        let ty = yi + gy;
        let (dx1, dx2) = get_random_dir(ctx.frame, x);
        
        let tx1 = xi + dx1;
        if self.can_displace(ctx, tx1, ty, my_density) {
            unsafe { ctx.grid.swap_unchecked(x, y, tx1 as u32, ty as u32); }
            return;
        }
        
        let tx2 = xi + dx2;
        if self.can_displace(ctx, tx2, ty, my_density) {
            unsafe { ctx.grid.swap_unchecked(x, y, tx2 as u32, ty as u32); }
        }
    }
}

--- End of File: packages/engine/src/behaviors/powder.rs ---


--- File: packages/engine/src/behaviors/utility.rs ---

//! UtilityBehavior - Handles Clone and Void elements
//! 
//! Port from: apps/web/src/lib/engine/behaviors/UtilityBehavior.ts
//! EXACT 1:1 port of the TypeScript algorithm
//! 
//! Clone: Duplicates touching elements into empty neighbors
//! Void: Destroys all touching elements

use super::{Behavior, UpdateContext};
use crate::elements::{
    ELEMENT_DATA, ElementId, EL_EMPTY, EL_CLONE, EL_VOID, CAT_UTILITY,
    get_color_with_variation
};

/// Neighbor directions
const DIRECTIONS: [(i32, i32); 4] = [
    (0, -1),  // Up
    (0, 1),   // Down
    (-1, 0),  // Left
    (1, 0),   // Right
];

pub struct UtilityBehavior;

impl UtilityBehavior {
    pub fn new() -> Self {
        Self
    }
    
    /// VOID: Destroys all adjacent particles (except other utilities)
    /// Mirrors TypeScript processVoid exactly
    fn process_void(&self, ctx: &mut UpdateContext) {
        let x = ctx.x as i32;
        let y = ctx.y as i32;
        
        for (dx, dy) in DIRECTIONS.iter() {
            let nx = x + dx;
            let ny = y + dy;
            
            if !ctx.grid.in_bounds(nx, ny) { continue; }
            
            let neighbor_type = ctx.grid.get_type(nx, ny);
            
            // Don't destroy empty, void, or clone
            if neighbor_type != EL_EMPTY && neighbor_type != EL_VOID && neighbor_type != EL_CLONE {
                ctx.clear_cell_dirty(nx as u32, ny as u32);
            }
        }
    }
    
    /// CLONE: Finds a donor element and copies it to empty adjacent cells
    /// Mirrors TypeScript processClone exactly
    fn process_clone(&self, ctx: &mut UpdateContext) {
        let x = ctx.x as i32;
        let y = ctx.y as i32;
        let frame = ctx.frame;
        
        // 1. Find a donor element (first non-utility neighbor)
        let mut source_type: ElementId = EL_EMPTY;
        
        for (dx, dy) in DIRECTIONS.iter() {
            let nx = x + dx;
            let ny = y + dy;
            
            if !ctx.grid.in_bounds(nx, ny) { continue; }
            
            let neighbor_type = ctx.grid.get_type(nx, ny);
            
            if neighbor_type != EL_EMPTY {
                // Bounds check
                if (neighbor_type as usize) >= ELEMENT_DATA.len() { continue; }
                
                let cat = ELEMENT_DATA[neighbor_type as usize].category;
                if cat != CAT_UTILITY {
                    source_type = neighbor_type;
                    break;
                }
            }
        }
        
        // No donor found
        if source_type == EL_EMPTY { return; }
        
        // 2. Clone into ONE empty adjacent cell (EXACT TypeScript: rotate start direction by frame)
        let start_dir = (frame % 4) as usize;
        
        for i in 0..4 {
            let dir_idx = (start_dir + i) % 4;
            let (dx, dy) = DIRECTIONS[dir_idx];
            let nx = x + dx;
            let ny = y + dy;
            
            if !ctx.grid.in_bounds(nx, ny) { continue; }
            if !ctx.grid.is_empty(nx, ny) { continue; }
            
            // Create cloned particle (mirrors TypeScript exactly)
            let seed = ((nx as u32 * 7 + ny as u32 * 13 + frame as u32) & 31) as u8;
            let props = &ELEMENT_DATA[source_type as usize];
            
            ctx.set_particle_dirty(
                nx as u32, ny as u32,
                source_type,
                get_color_with_variation(source_type, seed),
                props.lifetime,
                props.default_temp
            );
            
            return; // Only clone ONE per frame!
        }
    }
}

impl Behavior for UtilityBehavior {
    fn update(&self, ctx: &mut UpdateContext) {
        let xi = ctx.x as i32;
        let yi = ctx.y as i32;
        
        let element = ctx.grid.get_type(xi, yi);
        if element == EL_EMPTY { return; }
        
        if element == EL_VOID {
            self.process_void(ctx);
        } else if element == EL_CLONE {
            self.process_clone(ctx);
        }
    }
}

--- End of File: packages/engine/src/behaviors/utility.rs ---


--- File: packages/engine/src/chunks.rs ---

//! Chunk System - Phase 5: BitSet Optimization
//! 
//! Optimization:
//! - Vec<bool> (1 byte per chunk) -> Vec<u64> (1 bit per chunk)
//! - 64x memory reduction for dirty flags
//! - L1 Cache friendly iteration

/// Chunk size in pixels (32x32 is cache-friendly)
pub const CHUNK_SIZE: u32 = 32;

/// Number of frames before a chunk goes to sleep
const SLEEP_THRESHOLD: u32 = 60;

/// Chunk state
#[derive(Clone, Copy, PartialEq, Eq)]
pub enum ChunkState {
    Active,
    Sleeping,
}

/// Manages chunk-based spatial optimization
pub struct ChunkGrid {
    chunks_x: u32,
    chunks_y: u32,
    chunk_count: usize,
    
    /// Number of u64 words needed for BitSet
    u64_count: usize,
    
    state: Vec<ChunkState>,
    
    // === BITSET OPTIMIZATION (Phase 5) ===
    // 1 bit = 1 chunk. u64 stores 64 chunks.
    dirty_bits: Vec<u64>,
    visual_dirty_bits: Vec<u64>,
    
    idle_frames: Vec<u32>,
    particle_count: Vec<u32>,
    
    // Lazy Hydration
    pub virtual_temp: Vec<f32>,
    pub just_woke_up: Vec<bool>,
    
    // Legacy compatibility (world.rs uses visual_dirty[idx])
    pub visual_dirty: Vec<bool>,
}

impl ChunkGrid {
    /// Create chunk grid for given world dimensions
    pub fn new(world_width: u32, world_height: u32) -> Self {
        let chunks_x = (world_width + CHUNK_SIZE - 1) / CHUNK_SIZE;
        let chunks_y = (world_height + CHUNK_SIZE - 1) / CHUNK_SIZE;
        let chunk_count = (chunks_x * chunks_y) as usize;
        
        // How many u64 needed to store chunk_count bits?
        let u64_count = (chunk_count + 63) / 64;
        
        Self {
            chunks_x,
            chunks_y,
            chunk_count,
            u64_count,
            state: vec![ChunkState::Active; chunk_count],
            // BitSet: all bits set = all dirty initially
            dirty_bits: vec![!0u64; u64_count],
            visual_dirty_bits: vec![!0u64; u64_count],
            idle_frames: vec![0; chunk_count],
            particle_count: vec![0; chunk_count],
            virtual_temp: vec![20.0; chunk_count],
            just_woke_up: vec![false; chunk_count],
            // Legacy compatibility
            visual_dirty: vec![true; chunk_count],
        }
    }
    
    // === BitSet Helpers ===
    
    #[inline(always)]
    fn set_bit(bits: &mut [u64], idx: usize) {
        let word = idx >> 6;  // idx / 64
        let bit = idx & 63;   // idx % 64
        if word < bits.len() {
            bits[word] |= 1u64 << bit;
        }
    }

    #[inline(always)]
    fn clear_bit(bits: &mut [u64], idx: usize) {
        let word = idx >> 6;
        let bit = idx & 63;
        if word < bits.len() {
            bits[word] &= !(1u64 << bit);
        }
    }

    #[inline(always)]
    fn check_bit(bits: &[u64], idx: usize) -> bool {
        let word = idx >> 6;
        let bit = idx & 63;
        word < bits.len() && (bits[word] & (1u64 << bit)) != 0
    }
    
    // === Chunk indexing ===
    
    /// Get chunk index from world coordinates
    #[inline]
    pub fn chunk_index(&self, x: u32, y: u32) -> usize {
        let cx = x / CHUNK_SIZE;
        let cy = y / CHUNK_SIZE;
        (cy * self.chunks_x + cx) as usize
    }
    
    /// Get chunk coordinates from world coordinates
    #[inline]
    pub fn chunk_coords(&self, x: u32, y: u32) -> (u32, u32) {
        (x / CHUNK_SIZE, y / CHUNK_SIZE)
    }
    
    /// Get chunk index from chunk coordinates
    #[inline]
    pub fn chunk_idx_from_coords(&self, cx: u32, cy: u32) -> usize {
        (cy * self.chunks_x + cx) as usize
    }
    
    /// Check if chunk coordinates are valid
    #[inline]
    pub fn chunk_in_bounds(&self, cx: i32, cy: i32) -> bool {
        cx >= 0 && cx < self.chunks_x as i32 && cy >= 0 && cy < self.chunks_y as i32
    }
    
    // === Dirty flag management (BitSet) ===
    
    /// Mark chunk as dirty (needs processing)
    #[inline]
    pub fn mark_dirty(&mut self, x: u32, y: u32) {
        let idx = self.chunk_index(x, y);
        self.mark_dirty_idx(idx);
    }
    
    /// Mark chunk as dirty by chunk index (BitSet version)
    #[inline]
    pub fn mark_dirty_idx(&mut self, idx: usize) {
        if idx >= self.chunk_count { return; }
        
        if self.state[idx] == ChunkState::Sleeping {
            self.just_woke_up[idx] = true;
        }
        
        Self::set_bit(&mut self.dirty_bits, idx);
        Self::set_bit(&mut self.visual_dirty_bits, idx);
        self.visual_dirty[idx] = true; // Legacy compatibility
        
        self.idle_frames[idx] = 0;
        self.state[idx] = ChunkState::Active;
    }
    
    /// Check if chunk needs processing (BitSet)
    #[inline]
    pub fn is_dirty(&self, cx: u32, cy: u32) -> bool {
        let idx = self.chunk_idx_from_coords(cx, cy);
        Self::check_bit(&self.dirty_bits, idx)
    }
    
    /// Check if chunk is sleeping
    #[inline]
    pub fn is_sleeping(&self, cx: u32, cy: u32) -> bool {
        let idx = self.chunk_idx_from_coords(cx, cy);
        self.state[idx] == ChunkState::Sleeping
    }
    
    /// Should we process this chunk? (BitSet version)
    #[inline]
    pub fn should_process(&self, cx: u32, cy: u32) -> bool {
        let idx = self.chunk_idx_from_coords(cx, cy);
        Self::check_bit(&self.dirty_bits, idx) || self.particle_count[idx] > 0
    }
    
    // === Wake neighbors ===
    
    /// PHASE 1 OPT: Branchless neighbor wake with lookup table
    /// 
    /// Instead of 8 if-statements (branch misprediction nightmare),
    /// we compute a bitmask from local position and iterate over set bits.
    /// 
    /// Lookup table indexed by: (near_left | near_right<<1 | near_top<<2 | near_bottom<<3)
    /// Each entry is a bitmask of neighbors to wake:
    ///   Bit 0: Left, Bit 1: Right, Bit 2: Top, Bit 3: Bottom
    ///   Bit 4: Top-Left, Bit 5: Top-Right, Bit 6: Bottom-Left, Bit 7: Bottom-Right
    /// 
    /// Precomputed offsets for each bit: (dx, dy)
    const NEIGHBOR_OFFSETS: [(i32, i32); 8] = [
        (-1, 0),   // 0: Left
        (1, 0),    // 1: Right
        (0, -1),   // 2: Top
        (0, 1),    // 3: Bottom
        (-1, -1),  // 4: Top-Left
        (1, -1),   // 5: Top-Right
        (-1, 1),   // 6: Bottom-Left
        (1, 1),    // 7: Bottom-Right
    ];
    
    /// Lookup table: index = (near_left | near_right<<1 | near_top<<2 | near_bottom<<3)
    /// Value = bitmask of neighbors to wake
    const WAKE_MASK_LUT: [u8; 16] = [
        0b0000_0000, // 0: not near any edge
        0b0000_0001, // 1: near left only -> wake left
        0b0000_0010, // 2: near right only -> wake right
        0b0000_0011, // 3: near left+right (impossible for 32px chunk, but handle it)
        0b0000_0100, // 4: near top only -> wake top
        0b0001_0101, // 5: near left+top -> wake left, top, top-left
        0b0010_0110, // 6: near right+top -> wake right, top, top-right
        0b0011_0111, // 7: near left+right+top
        0b0000_1000, // 8: near bottom only -> wake bottom
        0b0100_1001, // 9: near left+bottom -> wake left, bottom, bottom-left
        0b1000_1010, // 10: near right+bottom -> wake right, bottom, bottom-right
        0b1100_1011, // 11: near left+right+bottom
        0b0000_1100, // 12: near top+bottom (impossible, but handle)
        0b0101_1101, // 13: near left+top+bottom
        0b1010_1110, // 14: near right+top+bottom
        0b1111_1111, // 15: all edges (impossible)
    ];
    
    /// Wake chunk and its neighbors (called when particle moves near boundary)
    /// PHASE 1 OPT: Branchless implementation using lookup table
    pub fn wake_neighbors(&mut self, x: u32, y: u32) {
        let (cx, cy) = self.chunk_coords(x, y);
        
        // PHASE 1 OPT: Use & instead of % for local coords (CHUNK_SIZE is power of 2)
        let local_x = x & (CHUNK_SIZE - 1);
        let local_y = y & (CHUNK_SIZE - 1);
        
        // Compute edge flags as 0 or 1 (branchless)
        let near_left = (local_x < 2) as usize;
        let near_right = (local_x >= CHUNK_SIZE - 2) as usize;
        let near_top = (local_y < 2) as usize;
        let near_bottom = (local_y >= CHUNK_SIZE - 2) as usize;
        
        // Build lookup index
        let lut_idx = near_left | (near_right << 1) | (near_top << 2) | (near_bottom << 3);
        let wake_mask = Self::WAKE_MASK_LUT[lut_idx];
        
        // Early exit if not near any edge (most common case)
        if wake_mask == 0 { return; }
        
        let cxi = cx as i32;
        let cyi = cy as i32;
        
        // Iterate over set bits in wake_mask
        let mut mask = wake_mask;
        while mask != 0 {
            let bit = mask.trailing_zeros() as usize;
            mask &= mask - 1; // Clear lowest set bit
            
            let (dx, dy) = Self::NEIGHBOR_OFFSETS[bit];
            let ncx = cxi + dx;
            let ncy = cyi + dy;
            
            // Bounds check (still needed, but predictable branch)
            if ncx >= 0 && ncx < self.chunks_x as i32 && ncy >= 0 && ncy < self.chunks_y as i32 {
                self.mark_dirty_idx(self.chunk_idx_from_coords(ncx as u32, ncy as u32));
            }
        }
    }
    
    // === Particle count tracking ===
    
    /// Increment particle count in chunk
    #[inline]
    pub fn add_particle(&mut self, x: u32, y: u32) {
        let idx = self.chunk_index(x, y);
        self.particle_count[idx] += 1;
        self.mark_dirty_idx(idx);
    }
    
    /// Decrement particle count in chunk
    #[inline]
    pub fn remove_particle(&mut self, x: u32, y: u32) {
        let idx = self.chunk_index(x, y);
        if self.particle_count[idx] > 0 {
            self.particle_count[idx] -= 1;
        }
    }
    
    /// Move particle between chunks (if crossing boundary)
    #[inline]
    pub fn move_particle(&mut self, from_x: u32, from_y: u32, to_x: u32, to_y: u32) {
        let from_idx = self.chunk_index(from_x, from_y);
        let to_idx = self.chunk_index(to_x, to_y);
        
        if from_idx != to_idx {
            // Crossed chunk boundary
            if self.particle_count[from_idx] > 0 {
                self.particle_count[from_idx] -= 1;
            }
            self.particle_count[to_idx] += 1;
            self.mark_dirty_idx(to_idx);
        }
        
        // Wake neighbors at destination
        self.wake_neighbors(to_x, to_y);
    }
    
    // === Frame update ===
    
    /// Called at start of each frame - prepare for processing
    pub fn begin_frame(&mut self) {
        // Dirty flags are preserved from previous frame
        // They get cleared as chunks are processed
    }
    
    /// Called after processing a chunk (BitSet version)
    pub fn end_chunk_update(&mut self, cx: u32, cy: u32, had_movement: bool) {
        let idx = self.chunk_idx_from_coords(cx, cy);
        
        if had_movement {
            self.idle_frames[idx] = 0;
            self.state[idx] = ChunkState::Active;
            Self::set_bit(&mut self.visual_dirty_bits, idx);
            self.visual_dirty[idx] = true; // Legacy
            
            // Wake chunk below (particles fall)
            if cy + 1 < self.chunks_y {
                let below_idx = self.chunk_idx_from_coords(cx, cy + 1);
                Self::set_bit(&mut self.dirty_bits, below_idx);
                Self::set_bit(&mut self.visual_dirty_bits, below_idx);
                self.visual_dirty[below_idx] = true;
                self.state[below_idx] = ChunkState::Active;
                self.idle_frames[below_idx] = 0;
            }
        } else {
            self.idle_frames[idx] += 1;
            if self.idle_frames[idx] >= SLEEP_THRESHOLD && self.particle_count[idx] == 0 {
                self.state[idx] = ChunkState::Sleeping;
            }
        }
        
        // Clear physics dirty bit
        Self::clear_bit(&mut self.dirty_bits, idx);
    }
    
    /// Clear visual dirty flag
    #[inline]
    pub fn clear_visual_dirty(&mut self, idx: usize) {
        if idx < self.chunk_count {
            Self::clear_bit(&mut self.visual_dirty_bits, idx);
            self.visual_dirty[idx] = false;
        }
    }
    
    /// Reset all chunks (BitSet version)
    pub fn reset(&mut self) {
        self.state.fill(ChunkState::Active);
        self.dirty_bits.fill(!0u64);  // All dirty
        self.visual_dirty_bits.fill(!0u64);
        self.visual_dirty.fill(true);
        self.idle_frames.fill(0);
        self.particle_count.fill(0);
        self.virtual_temp.fill(20.0);
        self.just_woke_up.fill(false);
    }
    
    // === Lazy Hydration Methods ===
    
    /// Get virtual temperature for chunk
    #[inline]
    pub fn get_virtual_temp(&self, cx: u32, cy: u32) -> f32 {
        let idx = self.chunk_idx_from_coords(cx, cy);
        self.virtual_temp[idx]
    }
    
    /// Update virtual temperature smoothly (lerp towards target)
    #[inline]
    pub fn update_virtual_temp(&mut self, cx: u32, cy: u32, target_temp: f32, speed: f32) {
        let idx = self.chunk_idx_from_coords(cx, cy);
        let current = self.virtual_temp[idx];
        let diff = target_temp - current;
        if diff.abs() > 0.01 {
            self.virtual_temp[idx] += diff * speed;
        } else {
            self.virtual_temp[idx] = target_temp;
        }
    }
    
    /// Set virtual temperature directly (for sync after active processing)
    #[inline]
    pub fn set_virtual_temp(&mut self, cx: u32, cy: u32, temp: f32) {
        let idx = self.chunk_idx_from_coords(cx, cy);
        self.virtual_temp[idx] = temp;
    }
    
    /// Clear wake-up flags after processing hydration
    pub fn clear_wake_flags(&mut self) {
        self.just_woke_up.fill(false);
    }
    
    // === Statistics ===
    
    /// Get number of active (non-sleeping) chunks
    pub fn active_chunk_count(&self) -> usize {
        self.state.iter().filter(|&&s| s == ChunkState::Active).count()
    }
    
    /// Get number of dirty chunks (BitSet version)
    pub fn dirty_chunk_count(&self) -> usize {
        // Count set bits across all words
        self.dirty_bits.iter().map(|w| w.count_ones() as usize).sum()
    }
    
    /// Get total chunk count
    pub fn total_chunks(&self) -> usize {
        self.chunk_count
    }
    
    /// Get chunks dimensions
    pub fn dimensions(&self) -> (u32, u32) {
        (self.chunks_x, self.chunks_y)
    }
}

impl ChunkGrid {
    /// Get iterator over chunks that should be processed (BitSet version)
    pub fn active_chunks(&self) -> impl Iterator<Item = (u32, u32)> + '_ {
        let chunks_x = self.chunks_x;
        (0..self.chunk_count).filter_map(move |idx| {
            if Self::check_bit(&self.dirty_bits, idx) || (self.particle_count[idx] > 0 && self.state[idx] == ChunkState::Active) {
                let cx = (idx as u32) % chunks_x;
                let cy = (idx as u32) / chunks_x;
                Some((cx, cy))
            } else {
                None
            }
        })
    }
}

// ============================================================================
// PHASE 2: MERGED DIRTY RECTANGLES FOR GPU BATCHING
// ============================================================================
// 
// Instead of uploading each dirty chunk separately (N calls to texSubImage2D),
// we merge adjacent dirty chunks into larger rectangles.
// 
// Example: 6 dirty chunks in a row â†’ 1 rectangle upload
// 
// Algorithm: Row-based run-length encoding
// 1. For each row of chunks, find runs of consecutive dirty chunks
// 2. Output (x, y, width, height) in CHUNK units

/// Represents a merged rectangle of dirty chunks (in CHUNK coordinates)
#[derive(Clone, Copy, Debug)]
pub struct DirtyRect {
    pub cx: u32,      // Chunk X
    pub cy: u32,      // Chunk Y
    pub cw: u32,      // Width in chunks
    pub ch: u32,      // Height in chunks (always 1 for row-based RLE)
}

/// Buffer for storing merged dirty rectangles (reused across frames)
pub struct MergedDirtyRects {
    rects: Vec<DirtyRect>,
    count: usize,
}

impl MergedDirtyRects {
    pub fn new(capacity: usize) -> Self {
        Self {
            rects: vec![DirtyRect { cx: 0, cy: 0, cw: 0, ch: 0 }; capacity],
            count: 0,
        }
    }
    
    #[inline]
    pub fn clear(&mut self) {
        self.count = 0;
    }
    
    #[inline]
    pub fn push(&mut self, rect: DirtyRect) {
        if self.count < self.rects.len() {
            self.rects[self.count] = rect;
            self.count += 1;
        }
    }
    
    #[inline]
    pub fn count(&self) -> usize {
        self.count
    }
    
    #[inline]
    pub fn get(&self, idx: usize) -> Option<&DirtyRect> {
        if idx < self.count {
            Some(&self.rects[idx])
        } else {
            None
        }
    }
    
    /// Get raw pointer for JS interop
    pub fn as_ptr(&self) -> *const DirtyRect {
        self.rects.as_ptr()
    }
}

impl ChunkGrid {
    /// PHASE 2: Collect dirty chunks and merge into rectangles
    /// 
    /// Uses row-based run-length encoding to merge horizontal runs.
    /// Returns number of rectangles generated.
    /// 
    /// Call get_merged_rect(idx) to retrieve each rectangle.
    pub fn collect_merged_dirty_rects(&self, output: &mut MergedDirtyRects) -> usize {
        output.clear();
        
        // Row-based RLE: scan each row and find runs of consecutive dirty chunks
        for cy in 0..self.chunks_y {
            let mut run_start: Option<u32> = None;
            
            for cx in 0..self.chunks_x {
                let idx = self.chunk_idx_from_coords(cx, cy);
                let is_dirty = Self::check_bit(&self.visual_dirty_bits, idx);
                
                if is_dirty {
                    // Start or continue a run
                    if run_start.is_none() {
                        run_start = Some(cx);
                    }
                } else {
                    // End of run (if any)
                    if let Some(start) = run_start {
                        output.push(DirtyRect {
                            cx: start,
                            cy,
                            cw: cx - start,
                            ch: 1,
                        });
                        run_start = None;
                    }
                }
            }
            
            // End of row - close any open run
            if let Some(start) = run_start {
                output.push(DirtyRect {
                    cx: start,
                    cy,
                    cw: self.chunks_x - start,
                    ch: 1,
                });
            }
        }
        
        output.count()
    }
    
    /// PHASE 2: Try to merge vertically adjacent rectangles
    /// 
    /// After row-based RLE, we can merge rectangles that have the same
    /// X start and width across consecutive rows.
    /// 
    /// This further reduces the number of GPU uploads.
    pub fn merge_vertical(&self, rects: &mut MergedDirtyRects) {
        if rects.count() < 2 { return; }
        
        // Simple O(nÂ²) merge - fine for small numbers of rectangles
        let mut i = 0;
        while i < rects.count {
            let rect_i = rects.rects[i];
            let mut j = i + 1;
            
            while j < rects.count {
                let rect_j = rects.rects[j];
                
                // Can merge if same X, same width, and adjacent rows
                if rect_j.cx == rect_i.cx 
                    && rect_j.cw == rect_i.cw 
                    && rect_j.cy == rect_i.cy + rect_i.ch 
                {
                    // Extend rect_i downward
                    rects.rects[i].ch += rect_j.ch;
                    
                    // Remove rect_j by swapping with last
                    rects.count -= 1;
                    if j < rects.count {
                        rects.rects[j] = rects.rects[rects.count];
                    }
                    // Don't increment j - check the swapped element
                } else {
                    j += 1;
                }
            }
            
            i += 1;
        }
    }
}

--- End of File: packages/engine/src/chunks.rs ---


--- File: packages/engine/src/elements.rs ---

//! Element Definitions - Re-exports from generated code
//! 
//! Phase 4: Single Source of Truth
//! 
//! All element definitions are now generated from definitions/elements.json
//! To add a new element:
//!   1. Edit definitions/elements.json
//!   2. Run: npm run codegen
//!   3. Done!

// Re-export everything from generated_elements
pub use crate::generated_elements::*;

--- End of File: packages/engine/src/elements.rs ---


--- File: packages/engine/src/generated_elements.rs ---

//! Generated Element Definitions - DO NOT EDIT MANUALLY!
//!
//! Phase 1: Data-Driven Core
//! This file is auto-generated by scripts/generate-elements.js
//! Sources: definitions/elements.json, definitions/reactions.json
//!
//! To add a new element or reaction: edit JSON files and run 'npm run codegen'

use wasm_bindgen::prelude::*;

/// Element ID as u8 for compact storage
pub type ElementId = u8;

// ============================================================================
// ELEMENT CONSTANTS
// ============================================================================

pub const EL_EMPTY: ElementId = 0;
pub const EL_STONE: ElementId = 1;
pub const EL_SAND: ElementId = 2;
pub const EL_WOOD: ElementId = 3;
pub const EL_METAL: ElementId = 4;
pub const EL_ICE: ElementId = 5;
pub const EL_WATER: ElementId = 6;
pub const EL_OIL: ElementId = 7;
pub const EL_LAVA: ElementId = 8;
pub const EL_ACID: ElementId = 9;
pub const EL_STEAM: ElementId = 10;
pub const EL_SMOKE: ElementId = 11;
pub const EL_FIRE: ElementId = 12;
pub const EL_SPARK: ElementId = 13;
pub const EL_ELECTRICITY: ElementId = 14;
pub const EL_GUNPOWDER: ElementId = 15;
pub const EL_CLONE: ElementId = 16;
pub const EL_VOID: ElementId = 17;
pub const EL_DIRT: ElementId = 18;
pub const EL_SEED: ElementId = 19;
pub const EL_PLANT: ElementId = 20;
pub const ELEMENT_COUNT: usize = 21;

// ============================================================================
// CATEGORY CONSTANTS
// ============================================================================

pub type CategoryId = u8;
pub const CAT_SOLID: CategoryId = 0;
pub const CAT_POWDER: CategoryId = 1;
pub const CAT_LIQUID: CategoryId = 2;
pub const CAT_GAS: CategoryId = 3;
pub const CAT_ENERGY: CategoryId = 4;
pub const CAT_UTILITY: CategoryId = 5;
pub const CAT_BIO: CategoryId = 6;

// ============================================================================
// ELEMENT FLAGS (BitMask) - Phase 1 Data-Driven
// ============================================================================

pub type ElementFlags = u32;

pub const FLAG_NONE: ElementFlags = 0;
pub const FLAG_FLAMMABLE: ElementFlags = 1;
pub const FLAG_CONDUCTIVE: ElementFlags = 2;
pub const FLAG_LIQUID: ElementFlags = 4;
pub const FLAG_GAS: ElementFlags = 8;
pub const FLAG_POWDER: ElementFlags = 16;
pub const FLAG_SOLID: ElementFlags = 32;
pub const FLAG_ENERGY: ElementFlags = 64;
pub const FLAG_UTILITY: ElementFlags = 128;
pub const FLAG_BIO: ElementFlags = 256;
pub const FLAG_IGNORE_GRAVITY: ElementFlags = 512;
pub const FLAG_CORROSIVE: ElementFlags = 1024;
pub const FLAG_HOT: ElementFlags = 2048;
pub const FLAG_COLD: ElementFlags = 4096;
pub const FLAG_RIGID: ElementFlags = 8192;

// ============================================================================
// PHYSICS CONSTANTS - Phase 2 Newtonian Physics
// ============================================================================

pub const GRAVITY: f32 = 0.5;
pub const AIR_FRICTION: f32 = 0.98;
pub const MAX_VELOCITY: f32 = 10.0;

/// Check if element has flag (branchless)
#[inline(always)]
pub fn has_flag(flags: ElementFlags, flag: ElementFlags) -> bool {
    (flags & flag) != 0
}

// ============================================================================
// ELEMENT PROPERTIES
// ============================================================================

/// Element properties struct - Phase 2: includes physics (bounce, friction)
#[derive(Clone, Copy)]
pub struct ElementProps {
    pub color: u32,
    pub density: f32,
    pub category: CategoryId,
    pub flags: ElementFlags,
    pub dispersion: u8,
    pub lifetime: u16,
    pub default_temp: f32,
    pub heat_conductivity: u8,
    // Phase 2: Newtonian Physics
    pub bounce: f32,      // Collision bounce factor (0.0 = no bounce, 1.0 = full bounce)
    pub friction: f32,    // Velocity decay per frame (1.0 = no decay, 0.0 = instant stop)
}

impl ElementProps {
    #[inline(always)]
    pub fn flammable(&self) -> bool { has_flag(self.flags, FLAG_FLAMMABLE) }
    #[inline(always)]
    pub fn conductive(&self) -> bool { has_flag(self.flags, FLAG_CONDUCTIVE) }
    #[inline(always)]
    pub fn is_liquid(&self) -> bool { has_flag(self.flags, FLAG_LIQUID) }
    #[inline(always)]
    pub fn is_gas(&self) -> bool { has_flag(self.flags, FLAG_GAS) }
    #[inline(always)]
    pub fn is_solid(&self) -> bool { has_flag(self.flags, FLAG_SOLID) }
    #[inline(always)]
    pub fn is_powder(&self) -> bool { has_flag(self.flags, FLAG_POWDER) }
    #[inline(always)]
    pub fn ignores_gravity(&self) -> bool { has_flag(self.flags, FLAG_IGNORE_GRAVITY) }
}

/// Static element data - indexed by ElementId
pub static ELEMENT_DATA: [ElementProps; ELEMENT_COUNT] = [
    // 0: Empty
    ElementProps {
        color: 0xFF0A0A0A,
        density: 0.0,
        category: CAT_SOLID,
        flags: 32, // 0x0020
        dispersion: 0,
        lifetime: 0,
        default_temp: 20.0,
        heat_conductivity: 5,
        bounce: 0.0,
        friction: 0.0,
    },
    // 1: Stone
    ElementProps {
        color: 0xFF808080,
        density: 2500.0,
        category: CAT_SOLID,
        flags: 32, // 0x0020
        dispersion: 0,
        lifetime: 0,
        default_temp: 20.0,
        heat_conductivity: 10,
        bounce: 0.0,
        friction: 0.0,
    },
    // 2: Sand
    ElementProps {
        color: 0xFFC2B280,
        density: 1600.0,
        category: CAT_POWDER,
        flags: 16, // 0x0010
        dispersion: 0,
        lifetime: 0,
        default_temp: 20.0,
        heat_conductivity: 15,
        bounce: 0.2,
        friction: 0.9,
    },
    // 3: Wood
    ElementProps {
        color: 0xFF8B4513,
        density: 600.0,
        category: CAT_SOLID,
        flags: 33, // 0x0021
        dispersion: 0,
        lifetime: 0,
        default_temp: 20.0,
        heat_conductivity: 5,
        bounce: 0.0,
        friction: 0.0,
    },
    // 4: Metal
    ElementProps {
        color: 0xFFA9A9A9,
        density: 7800.0,
        category: CAT_SOLID,
        flags: 34, // 0x0022
        dispersion: 0,
        lifetime: 0,
        default_temp: 20.0,
        heat_conductivity: 90,
        bounce: 0.0,
        friction: 0.0,
    },
    // 5: Ice
    ElementProps {
        color: 0xFFA5F2F3,
        density: 916.0,
        category: CAT_SOLID,
        flags: 4128, // 0x1020
        dispersion: 0,
        lifetime: 0,
        default_temp: -10.0,
        heat_conductivity: 20,
        bounce: 0.0,
        friction: 0.0,
    },
    // 6: Water
    ElementProps {
        color: 0xFF4169E1,
        density: 1000.0,
        category: CAT_LIQUID,
        flags: 6, // 0x0006
        dispersion: 8,
        lifetime: 0,
        default_temp: 20.0,
        heat_conductivity: 40,
        bounce: 0.0,
        friction: 0.95,
    },
    // 7: Oil
    ElementProps {
        color: 0xFF4A4A2A,
        density: 800.0,
        category: CAT_LIQUID,
        flags: 5, // 0x0005
        dispersion: 5,
        lifetime: 0,
        default_temp: 20.0,
        heat_conductivity: 15,
        bounce: 0.0,
        friction: 0.95,
    },
    // 8: Lava
    ElementProps {
        color: 0xFFFF4500,
        density: 2500.0,
        category: CAT_LIQUID,
        flags: 2052, // 0x0804
        dispersion: 2,
        lifetime: 0,
        default_temp: 1000.0,
        heat_conductivity: 30,
        bounce: 0.0,
        friction: 0.95,
    },
    // 9: Acid
    ElementProps {
        color: 0xFF39FF14,
        density: 1050.0,
        category: CAT_LIQUID,
        flags: 1030, // 0x0406
        dispersion: 5,
        lifetime: 0,
        default_temp: 20.0,
        heat_conductivity: 35,
        bounce: 0.0,
        friction: 0.95,
    },
    // 10: Steam
    ElementProps {
        color: 0xB4E0E0E0,
        density: 0.6,
        category: CAT_GAS,
        flags: 8, // 0x0008
        dispersion: 6,
        lifetime: 0,
        default_temp: 100.0,
        heat_conductivity: 10,
        bounce: 0.0,
        friction: 0.99,
    },
    // 11: Smoke
    ElementProps {
        color: 0xC83F3F3F,
        density: 1.1,
        category: CAT_GAS,
        flags: 8, // 0x0008
        dispersion: 4,
        lifetime: 0,
        default_temp: 50.0,
        heat_conductivity: 5,
        bounce: 0.0,
        friction: 0.99,
    },
    // 12: Fire
    ElementProps {
        color: 0xFFFF6600,
        density: 0.3,
        category: CAT_ENERGY,
        flags: 2112, // 0x0840
        dispersion: 0,
        lifetime: 60,
        default_temp: 800.0,
        heat_conductivity: 50,
        bounce: 0.0,
        friction: 1.0,
    },
    // 13: Spark
    ElementProps {
        color: 0xFFFFFF00,
        density: 0.1,
        category: CAT_ENERGY,
        flags: 64, // 0x0040
        dispersion: 0,
        lifetime: 10,
        default_temp: 500.0,
        heat_conductivity: 50,
        bounce: 0.0,
        friction: 1.0,
    },
    // 14: Electricity
    ElementProps {
        color: 0xFF00FFFF,
        density: 0.0,
        category: CAT_ENERGY,
        flags: 64, // 0x0040
        dispersion: 0,
        lifetime: 3,
        default_temp: 200.0,
        heat_conductivity: 80,
        bounce: 0.0,
        friction: 1.0,
    },
    // 15: Gunpowder
    ElementProps {
        color: 0xFF404040,
        density: 1400.0,
        category: CAT_POWDER,
        flags: 17, // 0x0011
        dispersion: 0,
        lifetime: 0,
        default_temp: 20.0,
        heat_conductivity: 10,
        bounce: 0.2,
        friction: 0.9,
    },
    // 16: Clone
    ElementProps {
        color: 0xFF00FF00,
        density: f32::INFINITY,
        category: CAT_UTILITY,
        flags: 640, // 0x0280
        dispersion: 0,
        lifetime: 0,
        default_temp: 20.0,
        heat_conductivity: 0,
        bounce: 0.0,
        friction: 1.0,
    },
    // 17: Void
    ElementProps {
        color: 0xFF000000,
        density: f32::INFINITY,
        category: CAT_UTILITY,
        flags: 640, // 0x0280
        dispersion: 0,
        lifetime: 0,
        default_temp: 20.0,
        heat_conductivity: 0,
        bounce: 0.0,
        friction: 1.0,
    },
    // 18: Dirt
    ElementProps {
        color: 0xFF5C4033,
        density: 1200.0,
        category: CAT_POWDER,
        flags: 16, // 0x0010
        dispersion: 0,
        lifetime: 0,
        default_temp: 20.0,
        heat_conductivity: 10,
        bounce: 0.2,
        friction: 0.9,
    },
    // 19: Seed
    ElementProps {
        color: 0xFFE2C489,
        density: 1100.0,
        category: CAT_BIO,
        flags: 257, // 0x0101
        dispersion: 0,
        lifetime: 0,
        default_temp: 20.0,
        heat_conductivity: 5,
        bounce: 0.1,
        friction: 0.85,
    },
    // 20: Plant
    ElementProps {
        color: 0xFF228B22,
        density: 900.0,
        category: CAT_BIO,
        flags: 257, // 0x0101
        dispersion: 0,
        lifetime: 0,
        default_temp: 20.0,
        heat_conductivity: 10,
        bounce: 0.1,
        friction: 0.85,
    },
];

// ============================================================================
// REACTION LOOKUP TABLE (LUT) - O(1) Access
// ============================================================================

/// Reaction result from LUT
#[derive(Clone, Copy, Debug)]
pub struct Reaction {
    /// What victim becomes (EL_EMPTY = destroyed)
    pub target_becomes: ElementId,
    /// What aggressor becomes (255 = unchanged, EL_EMPTY = destroyed)
    pub source_becomes: u8,
    /// Probability 0-255 (255 = 100%)
    pub chance: u8,
    /// Spawn byproduct (EL_EMPTY = none)
    pub spawn: ElementId,
}

impl Reaction {
    pub const NO_CHANGE: u8 = 255;
}

/// Reaction LUT size: 256 * 256 = 65536 entries
pub const REACTION_LUT_SIZE: usize = 65536;

/// Reaction LUT initialization data (sparse): (index, reaction)
pub static REACTION_INIT_DATA: [(usize, Reaction); 22] = [
    (1544, Reaction { target_becomes: 1, source_becomes: 10, chance: 38, spawn: 10 }), // water_lava
    (1548, Reaction { target_becomes: 0, source_becomes: 10, chance: 77, spawn: 0 }), // water_fire
    (2051, Reaction { target_becomes: 12, source_becomes: 255, chance: 77, spawn: 11 }), // lava_wood
    (2053, Reaction { target_becomes: 10, source_becomes: 1, chance: 77, spawn: 0 }), // lava_ice
    (2054, Reaction { target_becomes: 10, source_becomes: 1, chance: 38, spawn: 10 }), // lava_water
    (2055, Reaction { target_becomes: 12, source_becomes: 255, chance: 102, spawn: 11 }), // lava_oil
    (2063, Reaction { target_becomes: 12, source_becomes: 255, chance: 255, spawn: 11 }), // lava_gunpowder
    (2066, Reaction { target_becomes: 1, source_becomes: 255, chance: 13, spawn: 0 }), // lava_dirt
    (2068, Reaction { target_becomes: 12, source_becomes: 255, chance: 128, spawn: 11 }), // lava_plant
    (2305, Reaction { target_becomes: 0, source_becomes: 0, chance: 26, spawn: 11 }), // acid_stone
    (2307, Reaction { target_becomes: 0, source_becomes: 0, chance: 51, spawn: 0 }), // acid_wood
    (2308, Reaction { target_becomes: 0, source_becomes: 0, chance: 13, spawn: 0 }), // acid_metal
    (2309, Reaction { target_becomes: 6, source_becomes: 0, chance: 51, spawn: 0 }), // acid_ice
    (2322, Reaction { target_becomes: 0, source_becomes: 0, chance: 13, spawn: 0 }), // acid_dirt
    (2324, Reaction { target_becomes: 0, source_becomes: 0, chance: 38, spawn: 0 }), // acid_plant
    (3075, Reaction { target_becomes: 12, source_becomes: 11, chance: 26, spawn: 11 }), // fire_wood
    (3077, Reaction { target_becomes: 6, source_becomes: 0, chance: 77, spawn: 10 }), // fire_ice
    (3078, Reaction { target_becomes: 10, source_becomes: 0, chance: 128, spawn: 0 }), // fire_water
    (3079, Reaction { target_becomes: 12, source_becomes: 11, chance: 51, spawn: 11 }), // fire_oil
    (3087, Reaction { target_becomes: 12, source_becomes: 12, chance: 255, spawn: 11 }), // fire_gunpowder
    (3091, Reaction { target_becomes: 12, source_becomes: 11, chance: 51, spawn: 0 }), // fire_seed
    (3092, Reaction { target_becomes: 12, source_becomes: 11, chance: 26, spawn: 11 }), // fire_plant
];

/// Reaction System with O(1) lookup
pub struct ReactionSystem {
    lut: [Option<Reaction>; REACTION_LUT_SIZE],
}

impl ReactionSystem {
    /// Create new reaction system from init data
    pub fn new() -> Self {
        // Initialize with None
        let mut lut = [None; REACTION_LUT_SIZE];
        
        // Populate from generated data
        for (idx, reaction) in REACTION_INIT_DATA.iter() {
            lut[*idx] = Some(*reaction);
        }
        
        Self { lut }
    }
    
    /// O(1) reaction lookup - FAST!
    #[inline(always)]
    pub fn get(&self, aggressor: ElementId, victim: ElementId) -> Option<&Reaction> {
        let idx = ((aggressor as usize) << 8) | (victim as usize);
        // SAFETY: idx is always < 65536 since both IDs are u8
        #[cfg(not(debug_assertions))]
        unsafe { self.lut.get_unchecked(idx).as_ref() }
        #[cfg(debug_assertions)]
        self.lut[idx].as_ref()
    }
}

impl Default for ReactionSystem {
    fn default() -> Self {
        Self::new()
    }
}

/// Get element properties by ID
#[inline]
pub fn get_props(id: ElementId) -> &'static ElementProps {
    &ELEMENT_DATA[id as usize]
}

/// Get color with variation - EXACT TypeScript algorithm
/// Returns ABGR format for direct copy to Canvas ImageData
pub fn get_color_with_variation(id: ElementId, seed: u8) -> u32 {
    let base = ELEMENT_DATA[id as usize].color;
    let i = (seed & 31) as i32;
    let variation = (i - 16) * 2;
    
    let a = (base >> 24) & 0xFF;
    let r = (((base >> 16) & 0xFF) as i32 + variation).clamp(0, 255) as u32;
    let g = (((base >> 8) & 0xFF) as i32 + variation).clamp(0, 255) as u32;
    let b = ((base & 0xFF) as i32 + variation).clamp(0, 255) as u32;
    
    (a << 24) | (b << 16) | (g << 8) | r
}

// ============================================================================
// ELEMENT TYPE ENUM (for JS compatibility)
// ============================================================================

#[wasm_bindgen]
#[repr(u8)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum ElementType {
    Empty = 0,
    Stone = 1,
    Sand = 2,
    Wood = 3,
    Metal = 4,
    Ice = 5,
    Water = 6,
    Oil = 7,
    Lava = 8,
    Acid = 9,
    Steam = 10,
    Smoke = 11,
    Fire = 12,
    Spark = 13,
    Electricity = 14,
    Gunpowder = 15,
    Clone = 16,
    Void = 17,
    Dirt = 18,
    Seed = 19,
    Plant = 20,
}

impl ElementType {
    pub fn to_id(self) -> ElementId {
        self as ElementId
    }
    
    pub fn props(self) -> &'static ElementProps {
        get_props(self as ElementId)
    }
}

--- End of File: packages/engine/src/generated_elements.rs ---


--- File: packages/engine/src/grid.rs ---

//! Grid - Structure of Arrays (SoA) for cache-friendly particle storage
//! 
//! Phase 5: ABGR color format for direct Canvas copy
//! 
//! Instead of: Vec<Option<Particle>>  // Bad: many allocations, poor cache
//! We have:    types[], colors[], temps[]  // Good: linear memory, SIMD-friendly

use crate::elements::{ElementId, EL_EMPTY};
use crate::chunks::CHUNK_SIZE;

// Background color in ABGR format (little-endian: 0xAABBGGRR -> bytes [RR,GG,BB,AA])
// RGB(10,10,10) with alpha=255 -> 0xFF0A0A0A in ABGR
const BG_COLOR: u32 = 0xFF0A0A0A; // Same value since R=G=B

/// Recorded particle movement (from_x, from_y, to_x, to_y)
pub type ParticleMove = (u32, u32, u32, u32);

// === PHASE 4: ZERO-ALLOCATION MOVE BUFFER ===
// Fixed-size buffer that never reallocates. GC killer!

/// Fixed-capacity move buffer - allocated once, reused forever
pub struct MoveBuffer {
    data: Vec<ParticleMove>,
    pub count: usize,
    capacity: usize,
}

impl MoveBuffer {
    pub fn new(capacity: usize) -> Self {
        Self {
            data: vec![(0, 0, 0, 0); capacity], // Single allocation at startup
            count: 0,
            capacity,
        }
    }
    
    /// Push move - drops silently if buffer full (1 frame desync is invisible)
    #[inline(always)]
    pub fn push(&mut self, m: ParticleMove) {
        if self.count < self.capacity {
            // SAFETY: We just checked bounds above
            unsafe {
                *self.data.get_unchecked_mut(self.count) = m;
            }
            self.count += 1;
        }
        // If full, silently drop. Better than GC stutter!
    }
    
    /// Reset counter - memory stays allocated
    #[inline(always)]
    pub fn clear(&mut self) {
        self.count = 0;
    }
    
    /// Get raw pointer to data for unsafe iteration
    #[inline(always)]
    pub fn as_ptr(&self) -> *const ParticleMove {
        self.data.as_ptr()
    }
}

/// SoA Grid - all particle data in separate arrays
pub struct Grid {
    width: u32,
    height: u32,
    size: usize,
    
    // Structure of Arrays - each property in its own contiguous array
    pub types: Vec<ElementId>,      // Element type (0 = empty)
    pub colors: Vec<u32>,           // ABGR packed color
    pub life: Vec<u16>,             // Remaining lifetime (0 = infinite)
    pub updated: Vec<u8>,           // 0 = not updated, 1 = updated this frame
    pub temperature: Vec<f32>,      // Temperature in Â°C
    
    // Phase 2: Newtonian Physics - Velocity arrays
    pub vx: Vec<f32>,               // Horizontal velocity (pixels/frame)
    pub vy: Vec<f32>,               // Vertical velocity (pixels/frame)
    
    // Phase 4: Zero-allocation move buffer
    pub pending_moves: MoveBuffer,
}

impl Grid {
    pub fn new(width: u32, height: u32) -> Self {
        let size = (width * height) as usize;
        
        Self {
            width,
            height,
            size,
            types: vec![EL_EMPTY; size],
            colors: vec![BG_COLOR; size],
            life: vec![0; size],
            updated: vec![0; size],
            temperature: vec![20.0; size],
            // Phase 2: Velocity arrays (start at 0)
            vx: vec![0.0; size],
            vy: vec![0.0; size],
            // Phase 4: Fixed buffer for ~100k moves (~1.6MB RAM)
            // Enough for nuclear explosions, never reallocates!
            pending_moves: MoveBuffer::new(100_000),
        }
    }
    
    // === Dimensions ===
    #[inline]
    pub fn width(&self) -> u32 { self.width }
    
    #[inline]
    pub fn height(&self) -> u32 { self.height }
    
    #[inline]
    pub fn size(&self) -> usize { self.size }
    
    // === Index conversion ===
    #[inline]
    pub fn index(&self, x: u32, y: u32) -> usize {
        (y * self.width + x) as usize
    }
    
    #[inline]
    pub fn coords(&self, idx: usize) -> (u32, u32) {
        let x = (idx as u32) % self.width;
        let y = (idx as u32) / self.width;
        (x, y)
    }
    
    // === Bounds checking ===
    #[inline]
    pub fn in_bounds(&self, x: i32, y: i32) -> bool {
        x >= 0 && x < self.width as i32 && y >= 0 && y < self.height as i32
    }
    
    #[inline]
    pub fn is_empty(&self, x: i32, y: i32) -> bool {
        if !self.in_bounds(x, y) { return false; }
        self.types[self.index(x as u32, y as u32)] == EL_EMPTY
    }
    
    #[inline]
    pub fn is_empty_idx(&self, idx: usize) -> bool {
        self.types[idx] == EL_EMPTY
    }
    
    // === Type access ===
    #[inline]
    pub fn get_type(&self, x: i32, y: i32) -> ElementId {
        if !self.in_bounds(x, y) { return EL_EMPTY; }
        self.types[self.index(x as u32, y as u32)]
    }
    
    #[inline]
    pub fn get_type_idx(&self, idx: usize) -> ElementId {
        self.types[idx]
    }
    
    #[inline]
    pub fn set_type(&mut self, x: u32, y: u32, t: ElementId) {
        let idx = self.index(x, y);
        self.types[idx] = t;
    }
    
    // === Color access ===
    #[inline]
    pub fn get_color(&self, x: u32, y: u32) -> u32 {
        self.colors[self.index(x, y)]
    }
    
    #[inline]
    pub fn set_color(&mut self, x: u32, y: u32, c: u32) {
        let idx = self.index(x, y);
        self.colors[idx] = c;
    }
    
    // === Life access ===
    #[inline]
    pub fn get_life(&self, x: u32, y: u32) -> u16 {
        self.life[self.index(x, y)]
    }
    
    #[inline]
    pub fn set_life(&mut self, x: u32, y: u32, l: u16) {
        let idx = self.index(x, y);
        self.life[idx] = l;
    }
    
    // === Updated flag ===
    #[inline]
    pub fn is_updated(&self, x: u32, y: u32) -> bool {
        self.updated[self.index(x, y)] == 1
    }
    
    #[inline]
    pub fn is_updated_idx(&self, idx: usize) -> bool {
        self.updated[idx] == 1
    }
    
    #[inline]
    pub fn set_updated(&mut self, x: u32, y: u32, u: bool) {
        let idx = self.index(x, y);
        self.updated[idx] = if u { 1 } else { 0 };
    }
    
    #[inline]
    pub fn reset_updated(&mut self) {
        self.updated.fill(0);
    }
    
    // === Temperature access ===
    #[inline]
    pub fn get_temp(&self, x: i32, y: i32) -> f32 {
        if !self.in_bounds(x, y) { return 20.0; }
        self.temperature[self.index(x as u32, y as u32)]
    }
    
    #[inline]
    pub fn set_temp(&mut self, x: u32, y: u32, t: f32) {
        let idx = self.index(x, y);
        self.temperature[idx] = t;
    }
    
    // === Phase 2: Velocity access ===
    #[inline]
    pub fn get_vx(&self, x: u32, y: u32) -> f32 {
        self.vx[self.index(x, y)]
    }
    
    #[inline]
    pub fn get_vy(&self, x: u32, y: u32) -> f32 {
        self.vy[self.index(x, y)]
    }
    
    #[inline]
    pub fn set_vx(&mut self, x: u32, y: u32, v: f32) {
        let idx = self.index(x, y);
        self.vx[idx] = v;
    }
    
    #[inline]
    pub fn set_vy(&mut self, x: u32, y: u32, v: f32) {
        let idx = self.index(x, y);
        self.vy[idx] = v;
    }
    
    #[inline]
    pub fn add_velocity(&mut self, x: u32, y: u32, dvx: f32, dvy: f32) {
        let idx = self.index(x, y);
        self.vx[idx] += dvx;
        self.vy[idx] += dvy;
    }
    
    // === Swap two cells (all data) ===
    // Phase 4: Records the move for chunk tracking
    pub fn swap(&mut self, x1: u32, y1: u32, x2: u32, y2: u32) {
        let idx1 = self.index(x1, y1);
        let idx2 = self.index(x2, y2);
        
        // Record move if there's a particle moving (idx1 has particle, going to idx2)
        // This tracks where particles go for chunk system
        if self.types[idx1] != EL_EMPTY {
            self.pending_moves.push((x1, y1, x2, y2));
        }
        
        self.swap_idx(idx1, idx2);
    }
    
    #[inline]
    pub fn swap_idx(&mut self, idx1: usize, idx2: usize) {
        self.types.swap(idx1, idx2);
        self.colors.swap(idx1, idx2);
        self.life.swap(idx1, idx2);
        self.updated.swap(idx1, idx2);
        self.temperature.swap(idx1, idx2);
        // Phase 2: Swap velocity too
        self.vx.swap(idx1, idx2);
        self.vy.swap(idx1, idx2);
    }
    
    // === Phase 4: Move tracking for chunks (Zero-Allocation) ===
    
    /// Clear pending moves (call at frame start)
    /// Memory stays allocated - just resets counter
    pub fn clear_moves(&mut self) {
        self.pending_moves.clear();
    }
    
    // === Set particle with all data ===
    // Match TypeScript: new particles are NOT updated, so they can move this frame
    pub fn set_particle(&mut self, x: u32, y: u32, element: ElementId, color: u32, life: u16, temp: f32) {
        let idx = self.index(x, y);
        self.types[idx] = element;
        self.colors[idx] = color;
        self.life[idx] = life;
        self.updated[idx] = 0;  // NOT updated - can move this frame!
        self.temperature[idx] = temp;
        // Phase 2: New particles start with zero velocity
        self.vx[idx] = 0.0;
        self.vy[idx] = 0.0;
    }
    
    // === Clear single cell ===
    pub fn clear_cell(&mut self, x: u32, y: u32) {
        let idx = self.index(x, y);
        self.types[idx] = EL_EMPTY;
        self.colors[idx] = BG_COLOR;
        self.life[idx] = 0;
        self.temperature[idx] = 20.0;
        // Phase 2: Clear velocity
        self.vx[idx] = 0.0;
        self.vy[idx] = 0.0;
    }
    
    // === Clear entire grid ===
    pub fn clear(&mut self) {
        self.types.fill(EL_EMPTY);
        self.colors.fill(BG_COLOR);
        self.life.fill(0);
        self.updated.fill(0);
        self.temperature.fill(20.0);
        // Phase 2: Clear velocity
        self.vx.fill(0.0);
        self.vy.fill(0.0);
    }
    
    // === Get raw pointers for JS interop ===
    pub fn types_ptr(&self) -> *const ElementId {
        self.types.as_ptr()
    }
    
    pub fn colors_ptr(&self) -> *const u32 {
        self.colors.as_ptr()
    }
    
    pub fn temperature_ptr(&self) -> *const f32 {
        self.temperature.as_ptr()
    }
    
    // === PHASE 1: UNSAFE ACCESS (ZERO OVERHEAD) ===
    // These methods skip bounds checks for maximum performance.
    // ONLY use when coordinates are mathematically guaranteed valid!
    
    /// Get index without bounds check
    #[inline(always)]
    pub fn index_unchecked(&self, x: u32, y: u32) -> usize {
        (y * self.width + x) as usize
    }
    
    /// Fast type read - UNSAFE: caller must ensure x,y are valid
    #[inline(always)]
    pub unsafe fn get_type_unchecked(&self, x: u32, y: u32) -> ElementId {
        let idx = self.index_unchecked(x, y);
        *self.types.get_unchecked(idx)
    }
    
    /// Fast updated check - UNSAFE: caller must ensure idx is valid  
    #[inline(always)]
    pub unsafe fn is_updated_unchecked(&self, idx: usize) -> bool {
        *self.updated.get_unchecked(idx) == 1
    }
    
    /// Fast set updated - UNSAFE: caller must ensure idx is valid
    #[inline(always)]
    pub unsafe fn set_updated_unchecked(&mut self, idx: usize, u: bool) {
        *self.updated.get_unchecked_mut(idx) = if u { 1 } else { 0 };
    }
    
    /// Fast life read - UNSAFE: caller must ensure idx is valid
    #[inline(always)]
    pub unsafe fn get_life_unchecked(&self, idx: usize) -> u16 {
        *self.life.get_unchecked(idx)
    }
    
    /// Fast life write - UNSAFE: caller must ensure idx is valid
    #[inline(always)]
    pub unsafe fn set_life_unchecked(&mut self, idx: usize, l: u16) {
        *self.life.get_unchecked_mut(idx) = l;
    }
    
    /// Fast particle write - UNSAFE: caller must ensure x,y are valid
    #[inline(always)]
    pub unsafe fn set_particle_unchecked(&mut self, x: u32, y: u32, element: ElementId, color: u32, life: u16, temp: f32) {
        let idx = self.index_unchecked(x, y);
        *self.types.get_unchecked_mut(idx) = element;
        *self.colors.get_unchecked_mut(idx) = color;
        *self.life.get_unchecked_mut(idx) = life;
        *self.updated.get_unchecked_mut(idx) = 0;
        *self.temperature.get_unchecked_mut(idx) = temp;
    }
    
    /// Fast swap using raw pointers - UNSAFE: caller must ensure both coords are valid
    /// This is the hottest path in the simulation!
    /// 
    /// PHASE 4 OPTIMIZATION: Only record moves that cross chunk boundaries!
    /// Before: Every swap was recorded â†’ millions of writes per second
    /// After: Only cross-chunk swaps â†’ 10-100x fewer writes
    #[inline(always)]
    pub unsafe fn swap_unchecked(&mut self, x1: u32, y1: u32, x2: u32, y2: u32) {
        let idx1 = self.index_unchecked(x1, y1);
        let idx2 = self.index_unchecked(x2, y2);
        
        // === PHASE 4: SMART MOVE RECORDING ===
        // Only record moves that cross chunk boundaries!
        // CHUNK_SIZE = 32 = 2^5, so >> 5 is fast division by 32
        if *self.types.get_unchecked(idx1) != EL_EMPTY {
            let c1_x = x1 >> 5;  // x1 / 32
            let c1_y = y1 >> 5;  // y1 / 32
            let c2_x = x2 >> 5;
            let c2_y = y2 >> 5;
            
            // Only record if particle crossed chunk boundary
            if c1_x != c2_x || c1_y != c2_y {
                self.pending_moves.push((x1, y1, x2, y2));
            }
            // Intra-chunk moves don't need recording - chunk is already active
        }
        
        // Raw pointer swap - no bounds checks!
        let ptr_types = self.types.as_mut_ptr();
        let ptr_colors = self.colors.as_mut_ptr();
        let ptr_life = self.life.as_mut_ptr();
        let ptr_updated = self.updated.as_mut_ptr();
        let ptr_temp = self.temperature.as_mut_ptr();
        let ptr_vx = self.vx.as_mut_ptr();
        let ptr_vy = self.vy.as_mut_ptr();
        
        std::ptr::swap(ptr_types.add(idx1), ptr_types.add(idx2));
        std::ptr::swap(ptr_colors.add(idx1), ptr_colors.add(idx2));
        std::ptr::swap(ptr_life.add(idx1), ptr_life.add(idx2));
        std::ptr::swap(ptr_updated.add(idx1), ptr_updated.add(idx2));
        std::ptr::swap(ptr_temp.add(idx1), ptr_temp.add(idx2));
        // Swap velocity vectors as well so momentum moves with the particle
        std::ptr::swap(ptr_vx.add(idx1), ptr_vx.add(idx2));
        std::ptr::swap(ptr_vy.add(idx1), ptr_vy.add(idx2));
    }
    
    /// Fast clear cell - UNSAFE: caller must ensure x,y are valid
    #[inline(always)]
    pub unsafe fn clear_cell_unchecked(&mut self, x: u32, y: u32) {
        let idx = self.index_unchecked(x, y);
        *self.types.get_unchecked_mut(idx) = EL_EMPTY;
        *self.colors.get_unchecked_mut(idx) = BG_COLOR;
        *self.life.get_unchecked_mut(idx) = 0;
        *self.temperature.get_unchecked_mut(idx) = 20.0;
    }
    
    // === Lazy Hydration: Chunk temperature methods ===
    
    /// Hydrate chunk - fill air cells with virtual temperature
    /// Called when chunk wakes up from sleep
    /// PHASE 1 OPT: Uses SIMD for contiguous empty cell runs
    pub fn hydrate_chunk(&mut self, cx: u32, cy: u32, temp: f32) {
        let start_x = cx * CHUNK_SIZE;
        let start_y = cy * CHUNK_SIZE;
        let end_x = (start_x + CHUNK_SIZE).min(self.width);
        let end_y = (start_y + CHUNK_SIZE).min(self.height);
        
        // Use raw pointers for speed (chunk bounds are guaranteed valid)
        let types_ptr = self.types.as_ptr();
        let temps_ptr = self.temperature.as_mut_ptr();
        let width = self.width as usize;
        
        unsafe {
            for y in start_y..end_y {
                let row_offset = (y as usize) * width;
                let mut x = start_x;
                
                while x < end_x {
                    let idx = row_offset + (x as usize);
                    
                    // Skip non-empty cells
                    if *types_ptr.add(idx) != EL_EMPTY {
                        x += 1;
                        continue;
                    }
                    
                    // Found empty cell - count consecutive empties
                    let run_start = x;
                    while x < end_x && *types_ptr.add(row_offset + (x as usize)) == EL_EMPTY {
                        x += 1;
                    }
                    let run_len = (x - run_start) as usize;
                    
                    // PHASE 1 OPT: Use SIMD for runs of 4+ cells
                    #[cfg(target_arch = "wasm32")]
                    {
                        use std::arch::wasm32::*;
                        
                        let run_ptr = temps_ptr.add(row_offset + (run_start as usize));
                        let mut i = 0usize;
                        
                        // Process 4 cells at a time with SIMD
                        let v_temp = f32x4_splat(temp);
                        while i + 4 <= run_len {
                            v128_store(run_ptr.add(i) as *mut v128, v_temp);
                            i += 4;
                        }
                        
                        // Scalar remainder
                        while i < run_len {
                            *run_ptr.add(i) = temp;
                            i += 1;
                        }
                    }
                    
                    #[cfg(not(target_arch = "wasm32"))]
                    {
                        // Scalar fallback for non-WASM
                        let run_ptr = temps_ptr.add(row_offset + (run_start as usize));
                        for i in 0..run_len {
                            *run_ptr.add(i) = temp;
                        }
                    }
                }
            }
        }
    }
    
    /// Get average air temperature in chunk (for sync when going to sleep)
    /// PHASE 1 OPT: Uses SIMD horizontal sum for accumulation
    pub fn get_average_air_temp(&self, cx: u32, cy: u32) -> f32 {
        let start_x = cx * CHUNK_SIZE;
        let start_y = cy * CHUNK_SIZE;
        let end_x = (start_x + CHUNK_SIZE).min(self.width);
        let end_y = (start_y + CHUNK_SIZE).min(self.height);
        
        let types_ptr = self.types.as_ptr();
        let temps_ptr = self.temperature.as_ptr();
        let width = self.width as usize;
        
        let mut sum = 0.0f32;
        let mut count = 0u32;
        
        unsafe {
            for y in start_y..end_y {
                let row_offset = (y as usize) * width;
                for x in start_x..end_x {
                    let idx = row_offset + (x as usize);
                    if *types_ptr.add(idx) == EL_EMPTY {
                        sum += *temps_ptr.add(idx);
                        count += 1;
                    }
                }
            }
        }
        
        if count > 0 {
            sum / (count as f32)
        } else {
            // No air in chunk (fully occupied) - return room temp
            20.0
        }
    }
    
    // === PHASE 1: SIMD-optimized batch operations ===
    
    /// Batch lerp air temperatures towards target (for active chunks)
    /// Processes contiguous empty cell runs with SIMD
    /// Returns number of cells processed
    #[cfg(target_arch = "wasm32")]
    pub unsafe fn batch_lerp_air_temps(&mut self, cx: u32, cy: u32, target_temp: f32, lerp_speed: f32) -> u32 {
        use std::arch::wasm32::*;
        
        let start_x = cx * CHUNK_SIZE;
        let start_y = cy * CHUNK_SIZE;
        let end_x = (start_x + CHUNK_SIZE).min(self.width);
        let end_y = (start_y + CHUNK_SIZE).min(self.height);
        
        let types_ptr = self.types.as_ptr();
        let temps_ptr = self.temperature.as_mut_ptr();
        let width = self.width as usize;
        
        // SIMD constants
        let v_target = f32x4_splat(target_temp);
        let v_lerp = f32x4_splat(lerp_speed);
        let v_one_minus_lerp = f32x4_splat(1.0 - lerp_speed);
        
        let mut processed = 0u32;
        
        for y in start_y..end_y {
            let row_offset = (y as usize) * width;
            let mut x = start_x;
            
            while x < end_x {
                let idx = row_offset + (x as usize);
                
                // Skip non-empty cells
                if *types_ptr.add(idx) != EL_EMPTY {
                    x += 1;
                    continue;
                }
                
                // Count consecutive empty cells
                let run_start = x;
                while x < end_x && *types_ptr.add(row_offset + (x as usize)) == EL_EMPTY {
                    x += 1;
                }
                let run_len = (x - run_start) as usize;
                processed += run_len as u32;
                
                // Process with SIMD
                let run_ptr = temps_ptr.add(row_offset + (run_start as usize));
                let mut i = 0usize;
                
                // SIMD: 4 cells at a time
                // new_temp = current * (1 - lerp) + target * lerp
                while i + 4 <= run_len {
                    let ptr = run_ptr.add(i);
                    let v_current = v128_load(ptr as *const v128);
                    let v_new = f32x4_add(
                        f32x4_mul(v_current, v_one_minus_lerp),
                        f32x4_mul(v_target, v_lerp)
                    );
                    v128_store(ptr as *mut v128, v_new);
                    i += 4;
                }
                
                // Scalar remainder
                while i < run_len {
                    let ptr = run_ptr.add(i);
                    let current = *ptr;
                    *ptr = current + (target_temp - current) * lerp_speed;
                    i += 1;
                }
            }
        }
        
        processed
    }
    
    /// Non-WASM fallback for batch_lerp_air_temps
    #[cfg(not(target_arch = "wasm32"))]
    pub unsafe fn batch_lerp_air_temps(&mut self, cx: u32, cy: u32, target_temp: f32, lerp_speed: f32) -> u32 {
        let start_x = cx * CHUNK_SIZE;
        let start_y = cy * CHUNK_SIZE;
        let end_x = (start_x + CHUNK_SIZE).min(self.width);
        let end_y = (start_y + CHUNK_SIZE).min(self.height);
        
        let types_ptr = self.types.as_ptr();
        let temps_ptr = self.temperature.as_mut_ptr();
        let width = self.width as usize;
        
        let mut processed = 0u32;
        
        for y in start_y..end_y {
            let row_offset = (y as usize) * width;
            for x in start_x..end_x {
                let idx = row_offset + (x as usize);
                if *types_ptr.add(idx) == EL_EMPTY {
                    let ptr = temps_ptr.add(idx);
                    let current = *ptr;
                    *ptr = current + (target_temp - current) * lerp_speed;
                    processed += 1;
                }
            }
        }
        
        processed
    }
}

--- End of File: packages/engine/src/grid.rs ---


--- File: packages/engine/src/lib.rs ---

//! Particula Engine - High-performance particle simulation in WASM
//! 
//! Phase 4: Spatial Optimization with Chunks
//! 
//! Architecture (SOLID):
//! - elements.rs    - Element definitions and properties
//! - grid.rs        - SoA data storage
//! - chunks.rs      - Spatial optimization (32x32 chunks)
//! - behaviors/     - Particle physics (one file per category)
//! - reactions.rs   - Chemical reactions
//! - temperature.rs - Thermodynamics and phase changes
//! - world.rs       - Orchestration only

// Phase 4: Utils with safety macros (must be first for macro export!)
#[macro_use]
mod utils;

mod generated_elements;
mod elements;
mod grid;
mod chunks;
mod behaviors;
mod reactions;
mod temperature;
mod physics;  // Phase 2: Newtonian Physics
mod rigid_body;  // Rigid body structure
mod rigid_body_system;  // Rigid body manager
mod world;

use wasm_bindgen::prelude::*;

// Better error messages in debug mode
#[cfg(feature = "console_error_panic_hook")]
pub fn set_panic_hook() {
    console_error_panic_hook::set_once();
}

/// Initialize the engine
#[wasm_bindgen]
pub fn init() {
    #[cfg(feature = "console_error_panic_hook")]
    set_panic_hook();
    
    web_sys::console::log_1(&"ðŸ¦€ Particula WASM Engine initialized!".into());
}

/// Get engine version
#[wasm_bindgen]
pub fn version() -> String {
    env!("CARGO_PKG_VERSION").to_string()
}

// Re-export main types
pub use world::World;
pub use elements::ElementType;

// Export element constants for JS
#[wasm_bindgen]
pub fn el_empty() -> u8 { elements::EL_EMPTY }
#[wasm_bindgen]
pub fn el_stone() -> u8 { elements::EL_STONE }
#[wasm_bindgen]
pub fn el_sand() -> u8 { elements::EL_SAND }
#[wasm_bindgen]
pub fn el_wood() -> u8 { elements::EL_WOOD }
#[wasm_bindgen]
pub fn el_metal() -> u8 { elements::EL_METAL }
#[wasm_bindgen]
pub fn el_ice() -> u8 { elements::EL_ICE }
#[wasm_bindgen]
pub fn el_water() -> u8 { elements::EL_WATER }
#[wasm_bindgen]
pub fn el_oil() -> u8 { elements::EL_OIL }
#[wasm_bindgen]
pub fn el_lava() -> u8 { elements::EL_LAVA }
#[wasm_bindgen]
pub fn el_acid() -> u8 { elements::EL_ACID }
#[wasm_bindgen]
pub fn el_steam() -> u8 { elements::EL_STEAM }
#[wasm_bindgen]
pub fn el_smoke() -> u8 { elements::EL_SMOKE }
#[wasm_bindgen]
pub fn el_fire() -> u8 { elements::EL_FIRE }
#[wasm_bindgen]
pub fn el_spark() -> u8 { elements::EL_SPARK }
#[wasm_bindgen]
pub fn el_electricity() -> u8 { elements::EL_ELECTRICITY }
#[wasm_bindgen]
pub fn el_gunpowder() -> u8 { elements::EL_GUNPOWDER }
#[wasm_bindgen]
pub fn el_clone() -> u8 { elements::EL_CLONE }
#[wasm_bindgen]
pub fn el_void() -> u8 { elements::EL_VOID }
#[wasm_bindgen]
pub fn el_dirt() -> u8 { elements::EL_DIRT }
#[wasm_bindgen]
pub fn el_seed() -> u8 { elements::EL_SEED }
#[wasm_bindgen]
pub fn el_plant() -> u8 { elements::EL_PLANT }

--- End of File: packages/engine/src/lib.rs ---


--- File: packages/engine/src/physics.rs ---

//! Physics System - Phase 2: Newtonian Particle Physics
//! 
//! Implements velocity-based movement with DDA raycasting for collision detection.
//! 
//! Key concepts:
//! - Particles have velocity (vx, vy) that persists across frames
//! - Gravity accelerates particles downward each frame
//! - Friction decays velocity based on material properties
//! - DDA raycast detects collisions along the velocity vector
//! - Bounce factor determines energy retained after collision

use crate::grid::Grid;
use crate::elements::{ElementId, EL_EMPTY, ELEMENT_DATA, GRAVITY, AIR_FRICTION, MAX_VELOCITY, CAT_GAS, CAT_SOLID, CAT_ENERGY};
use crate::chunks::ChunkGrid;

/// Baseline simulation framerate used to scale frame-relative constants.
/// Legacy code assumed one "frame step" was roughly 1/60s.
const BASE_FPS: f32 = 60.0;

/// Result of a physics step for a single particle
#[derive(Clone, Copy, Debug)]
pub struct PhysicsResult {
    /// New X position (may be same as old if blocked)
    pub new_x: u32,
    /// New Y position
    pub new_y: u32,
    /// Did particle collide with something?
    pub collided: bool,
    /// Element that was hit (if collided)
    pub hit_element: ElementId,
}

/// Apply gravity to a particle's velocity
/// Gases get INVERTED gravity (they rise instead of fall)
#[inline]
pub fn apply_gravity(grid: &mut Grid, x: u32, y: u32, gravity_y: f32, dt: f32) {
    let idx = grid.index(x, y);
    let element = grid.types[idx];
    
    if element == EL_EMPTY {
        return;
    }
    
    let props = &ELEMENT_DATA[element as usize];
    
    // Gases rise (inverted gravity)
    let effective_gravity = if props.category == CAT_GAS {
        -gravity_y * 0.5  // Gases rise slower than solids fall
    } else {
        gravity_y
    };
    
    // Legacy tuning assumed per-frame increments; scale by dt * BASE_FPS to preserve feel.
    let frame_scale = dt * BASE_FPS;
    grid.vy[idx] += effective_gravity * GRAVITY * frame_scale;
    
    // Clamp to max velocity
    grid.vy[idx] = grid.vy[idx].clamp(-MAX_VELOCITY, MAX_VELOCITY);
    grid.vx[idx] = grid.vx[idx].clamp(-MAX_VELOCITY, MAX_VELOCITY);
}

/// Apply friction to a particle's velocity
#[inline]
pub fn apply_friction(grid: &mut Grid, x: u32, y: u32, dt: f32) {
    let idx = grid.index(x, y);
    let element = grid.types[idx];
    
    if element == EL_EMPTY {
        return;
    }
    
    let props = &ELEMENT_DATA[element as usize];
    
    // Use 1.0 (no decay) if friction is zero to avoid "static" elements ignoring physics
    let friction = if props.friction == 0.0 { 1.0 } else { props.friction };
    let frame_scale = dt * BASE_FPS;
    let friction_factor = friction.powf(frame_scale);
    let air_factor = AIR_FRICTION.powf(frame_scale);
    
    // Apply element-specific friction
    grid.vx[idx] *= friction_factor;
    grid.vy[idx] *= friction_factor;
    
    // Apply global air friction
    grid.vx[idx] *= air_factor;
    grid.vy[idx] *= air_factor;
    
    // Zero out very small velocities (prevents floating point creep)
    if grid.vx[idx].abs() < 0.01 {
        grid.vx[idx] = 0.0;
    }
    if grid.vy[idx].abs() < 0.01 {
        grid.vy[idx] = 0.0;
    }
}

/// DDA Raycast - move particle along velocity vector, stopping at first collision
/// 
/// Uses Bresenham-style DDA (Digital Differential Analyzer) to step through
/// grid cells along the velocity vector until we hit something or reach the end.
/// 
/// Returns (final_x, final_y, hit_element_or_none)
pub fn raycast_move(
    grid: &Grid,
    start_x: u32,
    start_y: u32,
    vx: f32,
    vy: f32,
    dt: f32,
) -> PhysicsResult {
    let frame_scale = dt * BASE_FPS;
    let dx = vx * frame_scale;
    let dy = vy * frame_scale;

    // If no velocity, stay in place
    if dx.abs() < 0.01 && dy.abs() < 0.01 {
        return PhysicsResult {
            new_x: start_x,
            new_y: start_y,
            collided: false,
            hit_element: EL_EMPTY,
        };
    }
    
    let mut x = start_x as f32;
    let mut y = start_y as f32;
    
    // Number of steps = max of |dx| and |dy|, at least 1
    let steps = dx.abs().max(dy.abs()).ceil() as i32;
    if steps == 0 {
        return PhysicsResult {
            new_x: start_x,
            new_y: start_y,
            collided: false,
            hit_element: EL_EMPTY,
        };
    }
    
    let step_x = dx / steps as f32;
    let step_y = dy / steps as f32;
    
    let mut last_valid_x = start_x;
    let mut last_valid_y = start_y;
    
    for _ in 0..steps {
        x += step_x;
        y += step_y;
        
        let ix = x.round() as i32;
        let iy = y.round() as i32;
        
        // Check bounds
        if !grid.in_bounds(ix, iy) {
            // Hit world boundary
            return PhysicsResult {
                new_x: last_valid_x,
                new_y: last_valid_y,
                collided: true,
                hit_element: EL_EMPTY, // Boundary
            };
        }
        
        let ux = ix as u32;
        let uy = iy as u32;
        
        // Skip if we're at start position
        if ux == start_x && uy == start_y {
            continue;
        }
        
        // Check if cell is occupied
        let hit_element = grid.get_type(ix, iy);
        if hit_element != EL_EMPTY {
            // Collision!
            return PhysicsResult {
                new_x: last_valid_x,
                new_y: last_valid_y,
                collided: true,
                hit_element,
            };
        }
        
        // Cell is empty, we can move here
        last_valid_x = ux;
        last_valid_y = uy;
    }
    
    // Reached end without collision
    PhysicsResult {
        new_x: last_valid_x,
        new_y: last_valid_y,
        collided: false,
        hit_element: EL_EMPTY,
    }
}

/// Handle collision response - apply bounce or stop
pub fn handle_collision(
    grid: &mut Grid,
    x: u32,
    y: u32,
    result: &PhysicsResult,
) {
    if !result.collided {
        return;
    }
    
    let idx = grid.index(x, y);
    let element = grid.types[idx];
    
    if element == EL_EMPTY {
        return;
    }
    
    let props = &ELEMENT_DATA[element as usize];
    let bounce = props.bounce;
    
    // Determine collision direction and apply bounce
    let vx = grid.vx[idx];
    let vy = grid.vy[idx];
    
    // Simple bounce: reverse velocity component and apply bounce factor
    // If we hit something below, reverse vy
    // If we hit something to the side, reverse vx
    
    let dx = result.new_x as i32 - x as i32;
    let dy = result.new_y as i32 - y as i32;
    
    // Vertical collision (hit floor/ceiling)
    if dy.abs() < vy.abs() as i32 && vy.abs() > 0.1 {
        grid.vy[idx] = -vy * bounce;
        // Add some horizontal scatter when bouncing
        grid.vx[idx] += (vx.signum()) * vy.abs() * 0.1;
    }
    
    // Horizontal collision (hit wall)
    if dx.abs() < vx.abs() as i32 && vx.abs() > 0.1 {
        grid.vx[idx] = -vx * bounce;
    }
    
    // If bounce is very small, just stop
    if bounce < 0.1 {
        if vy.abs() < 1.0 {
            grid.vy[idx] = 0.0;
        }
        if vx.abs() < 1.0 {
            grid.vx[idx] = 0.0;
        }
    }
}

/// Full physics update for a single particle
/// Returns true if particle moved
/// 
/// NOTE: No `updated` flag check here - we rely on correct processing order
/// (bottom-to-top for gravity) to prevent double-processing.
/// This allows behaviors to still run after physics.
/// 
/// GASES are skipped - they use inverted gravity and are handled by gas.rs behavior
pub fn update_particle_physics(
    grid: &mut Grid,
    chunks: &mut ChunkGrid,
    x: u32,
    y: u32,
    gravity_y: f32,
    dt: f32,
) -> bool {
    let idx = grid.index(x, y);
    
    let element = grid.types[idx];
    if element == EL_EMPTY {
        return false;
    }
    
    let props = &ELEMENT_DATA[element as usize];
    
    // Static solids should not be accelerated by physics
    if props.category == CAT_SOLID {
        grid.set_vx(x, y, 0.0);
        grid.set_vy(x, y, 0.0);
        return false;
    }
    
    // Energy (fire/spark/electricity) is driven by its own behavior, not gravity
    if props.category == CAT_ENERGY {
        grid.set_vx(x, y, 0.0);
        grid.set_vy(x, y, 0.0);
        return false;
    }
    
    // Respect explicit "ignore gravity" flag for future elements
    if props.ignores_gravity() {
        return false;
    }
    
    // Skip gases - they rise (inverted gravity) and are handled by gas.rs behavior
    // Processing them here would cause double-processing issues
    if props.category == CAT_GAS {
        return false;
    }
    
    // 1. Apply gravity
    apply_gravity(grid, x, y, gravity_y, dt);
    
    // 2. Apply friction
    apply_friction(grid, x, y, dt);
    
    // 3. Get current velocity
    let vx = grid.get_vx(x, y);
    let vy = grid.get_vy(x, y);
    
    // 4. No movement if velocity is zero
    if vx.abs() < 0.1 && vy.abs() < 0.1 {
        return false;
    }
    
    // 5. Raycast to find collision point
    let result = raycast_move(grid, x, y, vx, vy, dt);
    
    // 6. Handle collision (apply bounce)
    if result.collided {
        handle_collision(grid, x, y, &result);
    }
    
    // 7. Move particle if position changed
    if result.new_x != x || result.new_y != y {
        grid.swap(x, y, result.new_x, result.new_y);
        
        // Mark chunks as dirty
        chunks.mark_dirty(x, y);
        chunks.mark_dirty(result.new_x, result.new_y);
        
        return true;
    }
    
    false
}

--- End of File: packages/engine/src/physics.rs ---


--- File: packages/engine/src/reactions.rs ---

//! Chemical Reactions - Phase 1 Data-Driven System
//! 
//! This module is now a thin re-export layer.
//! All reaction definitions are in definitions/reactions.json
//! and generated into generated_elements.rs
//! 
//! Benefits:
//! - O(1) reaction lookup via LUT (vs O(N) match statements)
//! - No Rust recompilation needed to add reactions
//! - Edit JSON, run codegen, done!

// Re-export from generated code
pub use crate::generated_elements::{Reaction, ReactionSystem, REACTION_LUT_SIZE, REACTION_INIT_DATA};

/// Legacy compatibility: get_reaction function
/// Deprecated: Use ReactionSystem::get() instead for O(1) lookup
/// 
/// This wrapper exists only for gradual migration.
/// New code should use ReactionSystem directly.
#[deprecated(note = "Use ReactionSystem::get() for O(1) lookup")]
pub fn get_reaction(_aggressor: crate::elements::ElementId, _victim: crate::elements::ElementId) -> Option<&'static Reaction> {
    // Legacy function - should not be called
    // All callers should migrate to ReactionSystem
    None
}

--- End of File: packages/engine/src/reactions.rs ---


--- File: packages/engine/src/rigid_body.rs ---

//! RigidBody - A solid body that moves as a unit
//!
//! Phase: Hybrid Physics System
//! 
//! The body stores its shape in local coordinates (relative to center 0,0)
//! and transforms them to world coordinates using position and rotation.

use crate::elements::ElementId;

/// 2D Vector for physics calculations
#[derive(Clone, Copy, Debug, Default)]
pub struct Vec2 {
    pub x: f32,
    pub y: f32,
}

impl Vec2 {
    pub fn new(x: f32, y: f32) -> Self {
        Self { x, y }
    }
    
    pub fn zero() -> Self {
        Self { x: 0.0, y: 0.0 }
    }
    
    pub fn length(&self) -> f32 {
        (self.x * self.x + self.y * self.y).sqrt()
    }
    
    pub fn length_squared(&self) -> f32 {
        self.x * self.x + self.y * self.y
    }
    
    pub fn dot(&self, other: Vec2) -> f32 {
        self.x * other.x + self.y * other.y
    }
    
    pub fn normalize(&self) -> Self {
        let len = self.length();
        if len > 0.0001 {
            Self { x: self.x / len, y: self.y / len }
        } else {
            Self::zero()
        }
    }
}

impl std::ops::Add for Vec2 {
    type Output = Self;
    fn add(self, rhs: Self) -> Self {
        Self { x: self.x + rhs.x, y: self.y + rhs.y }
    }
}

impl std::ops::Sub for Vec2 {
    type Output = Self;
    fn sub(self, rhs: Self) -> Self {
        Self { x: self.x - rhs.x, y: self.y - rhs.y }
    }
}

impl std::ops::Mul<f32> for Vec2 {
    type Output = Self;
    fn mul(self, rhs: f32) -> Self {
        Self { x: self.x * rhs, y: self.y * rhs }
    }
}

/// A single pixel in the rigid body's local space
#[derive(Clone, Copy)]
pub struct BodyPixel {
    /// Offset from center (local coords)
    pub dx: i8,
    pub dy: i8,
    /// Element type for this pixel
    pub element: ElementId,
    /// Color variation seed
    pub color_seed: u8,
}

/// Rigid Body - moves as a single unit
pub struct RigidBody {
    // === Physics State ===
    /// World position (center of mass)
    pub pos: Vec2,
    /// Velocity vector (pixels per frame)
    pub velocity: Vec2,
    /// Rotation angle (radians)
    pub angle: f32,
    /// Angular velocity (radians per frame)
    pub angular_vel: f32,
    /// Total mass (sum of pixel masses)
    pub mass: f32,
    /// Moment of inertia for rotation (I = Î£ m*rÂ²)
    pub moment_of_inertia: f32,
    /// Is body active (simulated)?
    pub active: bool,
    /// Unique ID for this body
    pub id: u32,
    
    // === Shape Definition ===
    /// Pixels relative to center (0,0)
    pub pixels: Vec<BodyPixel>,
    
    // === Bounding Box (AABB) ===
    pub half_width: f32,
    pub half_height: f32,
    
    // === Previous frame position (for clearing) ===
    pub prev_pos: Vec2,
    pub prev_angle: f32,
    
    /// Cached world coordinates from last rasterization (for accurate clearing)
    pub prev_world_coords: Vec<(i32, i32)>,
    
    // === Material properties ===
    /// Bounciness (0.0 = no bounce, 1.0 = full elastic)
    pub restitution: f32,
}

impl RigidBody {
    /// Create a rectangular rigid body
    pub fn new_rect(x: f32, y: f32, w: i32, h: i32, element: ElementId, id: u32) -> Self {
        let mut pixels = Vec::new();
        let half_w = w / 2;
        let half_h = h / 2;
        
        // Generate rectangle of pixels centered at (0,0)
        for dy in -half_h..=half_h {
            for dx in -half_w..=half_w {
                // Generate color variation seed based on position
                let color_seed = ((dx.abs() as u32 * 7 + dy.abs() as u32 * 13) & 31) as u8;
                
                pixels.push(BodyPixel {
                    dx: dx as i8,
                    dy: dy as i8,
                    element,
                    color_seed,
                });
            }
        }
        
        let mass = pixels.len() as f32;
        
        // Calculate moment of inertia: I = Î£ m*rÂ² (assuming unit mass per pixel)
        let mut moment_of_inertia = 0.0f32;
        for pixel in &pixels {
            let r2 = (pixel.dx as f32).powi(2) + (pixel.dy as f32).powi(2);
            moment_of_inertia += r2; // m = 1 per pixel
        }
        // Ensure minimum moment to avoid division issues
        moment_of_inertia = moment_of_inertia.max(1.0);
        
        let pixel_count = pixels.len();
        
        Self {
            pos: Vec2::new(x, y),
            velocity: Vec2::zero(),
            angle: 0.0,
            angular_vel: 0.0,
            mass,
            moment_of_inertia,
            active: true,
            id,
            pixels,
            half_width: half_w as f32,
            half_height: half_h as f32,
            prev_pos: Vec2::new(x, y),
            prev_angle: 0.0,
            prev_world_coords: Vec::with_capacity(pixel_count),
            restitution: 0.3, // Default: slight bounce like stone
        }
    }
    
    /// Create a circular rigid body
    pub fn new_circle(x: f32, y: f32, radius: i32, element: ElementId, id: u32) -> Self {
        let mut pixels = Vec::new();
        // Use (r + 0.5)^2 for smoother circle edges (Midpoint circle algorithm style)
        let r_adj = radius as f32 + 0.5;
        let r2 = r_adj * r_adj;
        
        for dy in -radius..=radius {
            for dx in -radius..=radius {
                // Use floating point distance for smoother circle
                let dist2 = (dx as f32 * dx as f32) + (dy as f32 * dy as f32);
                if dist2 < r2 {
                    let color_seed = ((dx.abs() as u32 * 7 + dy.abs() as u32 * 13) & 31) as u8;
                    
                    pixels.push(BodyPixel {
                        dx: dx as i8,
                        dy: dy as i8,
                        element,
                        color_seed,
                    });
                }
            }
        }
        
        let mass = pixels.len() as f32;
        
        // Calculate moment of inertia for circle: I = 0.5 * m * rÂ²
        // But we compute exactly: I = Î£ m*rÂ² for all pixels
        let mut moment_of_inertia = 0.0f32;
        for pixel in &pixels {
            let r2 = (pixel.dx as f32).powi(2) + (pixel.dy as f32).powi(2);
            moment_of_inertia += r2;
        }
        moment_of_inertia = moment_of_inertia.max(1.0);
        
        let pixel_count = pixels.len();
        
        Self {
            pos: Vec2::new(x, y),
            velocity: Vec2::zero(),
            angle: 0.0,
            angular_vel: 0.0,
            mass,
            moment_of_inertia,
            active: true,
            id,
            pixels,
            half_width: radius as f32,
            half_height: radius as f32,
            prev_pos: Vec2::new(x, y),
            prev_angle: 0.0,
            prev_world_coords: Vec::with_capacity(pixel_count),
            restitution: 0.3,
        }
    }
    
    /// Transform local pixel coordinates to world coordinates
    #[inline]
    pub fn local_to_world(&self, dx: f32, dy: f32) -> (i32, i32) {
        let (sin, cos) = self.angle.sin_cos();
        let rx = dx * cos - dy * sin;
        let ry = dx * sin + dy * cos;
        
        ((self.pos.x + rx).round() as i32, (self.pos.y + ry).round() as i32)
    }
    
    /// Transform local pixel coordinates to world using previous frame's transform
    #[inline]
    pub fn local_to_world_prev(&self, dx: f32, dy: f32) -> (i32, i32) {
        let (sin, cos) = self.prev_angle.sin_cos();
        let rx = dx * cos - dy * sin;
        let ry = dx * sin + dy * cos;
        
        ((self.prev_pos.x + rx).round() as i32, (self.prev_pos.y + ry).round() as i32)
    }
    
    /// Save current position as previous (call before physics update)
    pub fn save_prev_state(&mut self) {
        self.prev_pos = self.pos;
        self.prev_angle = self.angle;
    }
    
    /// Apply impulse at center of mass
    pub fn apply_impulse(&mut self, impulse: Vec2) {
        self.velocity = self.velocity + impulse * (1.0 / self.mass);
    }
    
    /// Apply force for one frame
    pub fn apply_force(&mut self, force: Vec2) {
        self.velocity = self.velocity + force * (1.0 / self.mass);
    }
    
    /// Apply torque (rotational force)
    pub fn apply_torque(&mut self, torque: f32) {
        self.angular_vel += torque / self.moment_of_inertia;
    }
    
    /// Set restitution (bounciness)
    pub fn set_restitution(&mut self, r: f32) {
        self.restitution = r.clamp(0.0, 1.0);
    }
}

--- End of File: packages/engine/src/rigid_body.rs ---


--- File: packages/engine/src/rigid_body_system.rs ---

//! RigidBodySystem - Manager for all rigid bodies
//!
//! Phase: Advanced Physics with Torque, Momentum Transfer, and Bounce
//!
//! The Loop:
//! 1. ERASE: Clear bodies from old positions in grid
//! 2. UPDATE: Apply gravity/velocity, update positions
//! 3. COLLISION: Check for collisions with world (with momentum transfer!)
//! 4. TORQUE: Apply rotational forces from asymmetric contacts
//! 5. BOUNCE: Reflect velocity based on collision normal
//! 6. RASTERIZE: Draw bodies at new positions

use crate::grid::Grid;
use crate::rigid_body::{RigidBody, Vec2};
use crate::chunks::ChunkGrid;
use crate::elements::{
    EL_EMPTY, ELEMENT_DATA, CAT_SOLID, CAT_POWDER, CAT_LIQUID, CAT_GAS,
    get_color_with_variation, get_props,
};

/// Baseline simulation framerate used to scale legacy per-frame constants.
const BASE_FPS: f32 = 60.0;

// === Physics Constants ===
/// Minimum momentum to penetrate soft materials (powder/liquid)
const PENETRATION_THRESHOLD: f32 = 30.0;
/// How much velocity is transferred to kicked particles (0.0-1.0)
const KICK_TRANSFER: f32 = 0.6;
/// Random spread for particle splashes
const SPLASH_SPREAD: f32 = 2.0;
/// Velocity below which body comes to rest
const REST_THRESHOLD: f32 = 0.1;
/// Angular velocity below which rotation stops  
const ANGULAR_REST_THRESHOLD: f32 = 0.05;
/// Damping factor for angular velocity (lower = more friction)
const ANGULAR_DAMPING: f32 = 0.85;
/// Maximum angular velocity (prevent crazy spinning)
const MAX_ANGULAR_VEL: f32 = 0.3;

/// Extended collision result with contact information
struct CollisionResult {
    /// Did any collision occur?
    hit: bool,
    /// Hit on X axis specifically?
    hit_x: bool,
    /// Hit on Y axis specifically?
    hit_y: bool,
    /// Number of contact points
    contact_count: u32,
    /// Sum of contact X positions (divide by count for average)
    contact_sum_x: f32,
    /// Sum of contact Y positions
    contact_sum_y: f32,
    /// Accumulated collision normal (sum of individual normals)
    normal_sum: Vec2,
    /// Number of soft contacts that were penetrated
    penetrated_count: u32,
}

/// Clear body pixels from grid (using cached world coordinates)
fn clear_body_from_grid(body: &RigidBody, grid: &mut Grid, chunks: &mut ChunkGrid) {
    // Use cached world coordinates for accurate clearing (prevents black spots)
    for (i, &(x, y)) in body.prev_world_coords.iter().enumerate() {
        if grid.in_bounds(x, y) {
            let ux = x as u32;
            let uy = y as u32;
            
            // Only clear if this cell belongs to our rigid body
            let current_type = grid.get_type(x, y);
            // Check against the element type of this pixel
            if i < body.pixels.len() && current_type == body.pixels[i].element {
                grid.clear_cell(ux, uy);
                chunks.mark_dirty(ux, uy);
            }
        }
    }
}

/// Draw body pixels to grid (using CURRENT position)
fn displace_soft_cell(
    grid: &mut Grid,
    chunks: &mut ChunkGrid,
    x: u32,
    y: u32,
    candidates: &[(i32, i32)],
) -> bool {
    for (dx, dy) in candidates {
        let tx = x as i32 + dx;
        let ty = y as i32 + dy;
        if !grid.in_bounds(tx, ty) { continue; }
        let target = grid.get_type(tx, ty);
        if target == EL_EMPTY {
            grid.swap(x, y, tx as u32, ty as u32);
            chunks.mark_dirty(x, y);
            chunks.mark_dirty(tx as u32, ty as u32);
            return true;
        }
    }
    false
}

fn rasterize_body(body: &mut RigidBody, grid: &mut Grid, chunks: &mut ChunkGrid) {
    // Clear and prepare to collect new world coordinates
    body.prev_world_coords.clear();
    
    for pixel in &body.pixels {
        let (x, y) = body.local_to_world(pixel.dx as f32, pixel.dy as f32);
        
        // Always record the world coordinate for this pixel (for accurate clearing later)
        body.prev_world_coords.push((x, y));
        
        if grid.in_bounds(x, y) {
            let ux = x as u32;
            let uy = y as u32;
            
            // If cell contains powder or liquid, try to push it aside instead of deleting
            let existing = grid.get_type(x, y);
            if existing != EL_EMPTY && existing != pixel.element {
                if (existing as usize) < ELEMENT_DATA.len() {
                    let cat = ELEMENT_DATA[existing as usize].category;
                    if cat == CAT_POWDER || cat == CAT_LIQUID {
                        // When falling, do NOT tunnel through soft materialâ€”stop drawing here.
                        if body.velocity.y > 0.05 {
                            continue;
                        }
                        // Build displacement candidates based on velocity and pixel offset
                        let mut candidates: [(i32, i32); 8] = [(0, 0); 8];
                        let mut count = 0;
                        
                        let sign_vx = if body.velocity.x > 0.1 { 1 } else if body.velocity.x < -0.1 { -1 } else { 0 };
                        let sign_vy = if body.velocity.y > 0.1 { 1 } else if body.velocity.y < -0.1 { -1 } else { 0 };
                        
                        if sign_vx != 0 || sign_vy != 0 {
                            candidates[count] = (sign_vx, sign_vy); count += 1;
                            if sign_vx != 0 { candidates[count] = (sign_vx, 0); count += 1; }
                            if sign_vy != 0 { candidates[count] = (0, sign_vy); count += 1; }
                            if sign_vx != 0 || sign_vy != 0 {
                                candidates[count] = (sign_vy, -sign_vx); count += 1; // perpendicular
                                candidates[count] = (-sign_vy, sign_vx); count += 1;
                            }
                        }
                        
                        // Outward from body center as fallback
                        let outward_x = (pixel.dx as i32).signum();
                        let outward_y = (pixel.dy as i32).signum();
                        if outward_x != 0 || outward_y != 0 {
                            candidates[count] = (outward_x, outward_y); count += 1;
                            if outward_x != 0 { candidates[count] = (outward_x, 0); count += 1; }
                            if outward_y != 0 { candidates[count] = (0, outward_y); count += 1; }
                        }
                        
                        if !displace_soft_cell(grid, chunks, ux, uy, &candidates[..count]) {
                            // Could not push out soft material; leave it intact and skip placing this pixel
                            continue;
                        }
                    }
                }
            }
            
            // Get element properties
            let props = get_props(pixel.element);
            
            // Generate color with variation
            let color = get_color_with_variation(pixel.element, pixel.color_seed);
            
            // Set particle with rigid flag
            grid.set_particle(
                ux, uy,
                pixel.element,
                color,
                props.lifetime,
                props.default_temp,
            );
            
            // Mark as updated so behaviors don't touch it
            grid.set_updated(ux, uy, true);
            
            chunks.mark_dirty(ux, uy);
        }
    }
}

/// Simple PRNG for splash randomness (no std lib dependency)
fn simple_random(seed: u32) -> f32 {
    let x = seed.wrapping_mul(1103515245).wrapping_add(12345);
    ((x >> 16) & 0x7FFF) as f32 / 32768.0 - 0.5 // Range: -0.5 to 0.5
}

/// Kick a particle - transfer momentum from rigid body to grid particle
/// Creates the "splash" effect when heavy objects hit soft materials
fn kick_particle(
    grid: &mut Grid,
    chunks: &mut ChunkGrid,
    x: i32,
    y: i32,
    body_velocity: Vec2,
    body_pos: Vec2,
    seed: u32,
) {
    if !grid.in_bounds(x, y) { return; }
    
    let ux = x as u32;
    let uy = y as u32;
    
    // Calculate kick direction: away from body center + along body velocity
    let dx = x as f32 - body_pos.x;
    let dy = y as f32 - body_pos.y;
    let dist = (dx * dx + dy * dy).sqrt().max(1.0);
    
    // Normalize direction from body center
    let dir_x = dx / dist;
    let dir_y = dy / dist;
    
    // Random spread for splash effect
    let rand1 = simple_random(seed);
    let rand2 = simple_random(seed.wrapping_mul(7));
    
    // Combine: body velocity transfer + radial push + random spread
    let kick_x = body_velocity.x * KICK_TRANSFER 
               + dir_x * body_velocity.length() * 0.3
               + rand1 * SPLASH_SPREAD;
    let kick_y = body_velocity.y * KICK_TRANSFER 
               + dir_y * body_velocity.length() * 0.3 
               - 1.5  // Slight upward bias for splash
               + rand2 * SPLASH_SPREAD;
    
    // Apply velocity to particle
    grid.add_velocity(ux, uy, kick_x, kick_y);
    chunks.mark_dirty(ux, uy);
}

/// Check if body would collide at new position
/// Now with momentum-based penetration of soft materials!
fn check_collision_advanced(
    new_x: f32,
    new_y: f32,
    body: &RigidBody,
    grid: &mut Grid,
    chunks: &mut ChunkGrid,
    skip_self_overlap: bool,
) -> CollisionResult {
    let mut hit_x = false;
    let mut hit_y = false;
    let mut contact_count = 0u32;
    let mut contact_sum_x = 0.0f32;
    let mut contact_sum_y = 0.0f32;
    let mut normal_sum = Vec2::zero();
    let mut penetrated_count = 0u32;
    
    // Calculate body momentum for penetration check
    let momentum = body.velocity.length() * body.mass;
    let can_penetrate = momentum > PENETRATION_THRESHOLD;
    
    // Seed for random kicks
    let mut kick_seed = (new_x as u32).wrapping_mul(31337).wrapping_add(new_y as u32);
    
    // Temporarily modify position for checking
    let temp_pos = Vec2::new(new_x, new_y);
    
    for pixel in &body.pixels {
        let (sin, cos) = body.angle.sin_cos();
        let dx = pixel.dx as f32;
        let dy = pixel.dy as f32;
        let rx = dx * cos - dy * sin;
        let ry = dx * sin + dy * cos;
        
        let world_x = (temp_pos.x + rx).round() as i32;
        let world_y = (temp_pos.y + ry).round() as i32;
        
        // Old position for axis detection
        let old_wx = (body.pos.x + rx).round() as i32;
        let old_wy = (body.pos.y + ry).round() as i32;
        
        // Check world bounds
        if !grid.in_bounds(world_x, world_y) {
            if world_x != old_wx { hit_x = true; }
            if world_y != old_wy { hit_y = true; }
            
            // Record contact at boundary
            contact_count += 1;
            contact_sum_x += world_x as f32;
            contact_sum_y += world_y as f32;
            normal_sum.x += body.pos.x - world_x as f32;
            normal_sum.y += body.pos.y - world_y as f32;
            continue;
        }
        
        // Check cell content
        let cell_type = grid.get_type(world_x, world_y);
        
        if cell_type != EL_EMPTY {
            let cell_props = &ELEMENT_DATA[cell_type as usize];
            let category = cell_props.category;
            
            // === SOFT MATERIALS: Powder, Liquid, Gas ===
            if category == CAT_POWDER || category == CAT_LIQUID || category == CAT_GAS {
                if can_penetrate {
                    // === BULLDOZER MODE: Penetrate and kick! ===
                    kick_seed = kick_seed.wrapping_mul(1103515245).wrapping_add(12345);
                    kick_particle(grid, chunks, world_x, world_y, body.velocity, body.pos, kick_seed);
                    penetrated_count += 1;
                    
                    // Don't count as hard collision - body continues through
                    continue;
                } else {
                    // Low momentum - treat powder as solid, but liquids/gases pass through
                    if category == CAT_POWDER {
                        // Record contact for torque calculation
                        contact_count += 1;
                        contact_sum_x += world_x as f32;
                        contact_sum_y += world_y as f32;
                        normal_sum.x += body.pos.x - world_x as f32;
                        normal_sum.y += body.pos.y - world_y as f32;
                        
                        if skip_self_overlap && old_wx == world_x && old_wy == world_y {
                            continue;
                        }
                        
                        if world_x != old_wx { hit_x = true; }
                        if world_y != old_wy { hit_y = true; }
                    }
                    // Liquids and gases at low speed - pass through
                    continue;
                }
            }
            
            // === SOLID MATERIALS: Always collide ===
            if category == CAT_SOLID {
                // Skip self-overlap during movement
                if skip_self_overlap && old_wx == world_x && old_wy == world_y {
                    continue;
                }
                
                // Record contact point for torque
                contact_count += 1;
                contact_sum_x += world_x as f32;
                contact_sum_y += world_y as f32;
                
                // Accumulate normal (direction from obstacle to body center)
                normal_sum.x += (body.pos.x - world_x as f32);
                normal_sum.y += (body.pos.y - world_y as f32);
                
                // Determine collision axis
                if world_x != old_wx { hit_x = true; }
                if world_y != old_wy { hit_y = true; }
            }
        }
    }
    
    CollisionResult {
        hit: hit_x || hit_y,
        hit_x,
        hit_y,
        contact_count,
        contact_sum_x,
        contact_sum_y,
        normal_sum,
        penetrated_count,
    }
}

/// Simple collision check (for spawn validation - no momentum transfer)
fn check_collision_simple(new_x: f32, new_y: f32, body: &RigidBody, grid: &Grid) -> bool {
    for pixel in &body.pixels {
        let (sin, cos) = body.angle.sin_cos();
        let dx = pixel.dx as f32;
        let dy = pixel.dy as f32;
        let rx = dx * cos - dy * sin;
        let ry = dx * sin + dy * cos;
        
        let world_x = (new_x + rx).round() as i32;
        let world_y = (new_y + ry).round() as i32;
        
        if !grid.in_bounds(world_x, world_y) {
            return true;
        }
        
        let cell_type = grid.get_type(world_x, world_y);
        if cell_type != EL_EMPTY {
            let props = &ELEMENT_DATA[cell_type as usize];
            if props.category == CAT_SOLID || props.category == CAT_POWDER {
                return true;
            }
        }
    }
    false
}

/// Manages all rigid bodies in the simulation
pub struct RigidBodySystem {
    /// All rigid bodies
    bodies: Vec<RigidBody>,
    /// Gravity (pixels per frame squared)
    gravity: f32,
    /// Next body ID
    next_id: u32,
    /// Friction for sliding (0-1)
    friction: f32,
}

impl RigidBodySystem {
    pub fn new() -> Self {
        Self {
            bodies: Vec::new(),
            gravity: 0.5, // Match physics.rs GRAVITY constant
            next_id: 1,
            friction: 0.8,
        }
    }
    
    /// Set gravity (can be negative for inverted gravity)
    pub fn set_gravity(&mut self, g: f32) {
        self.gravity = g;
    }
    
    /// Add a new rigid body. Returns 0 if placement collides with existing solids.
    pub fn add_body(&mut self, mut body: RigidBody, grid: &mut Grid, chunks: &mut ChunkGrid) -> u32 {
        // Reject spawn if it intersects existing solids/powders/rigid bodies
        if check_collision_simple(body.pos.x, body.pos.y, &body, grid) {
            return 0;
        }
        
        let id = self.next_id;
        body.id = id;
        self.next_id += 1;
        
        // Draw immediately so new body is visible and blocks future spawns this frame
        rasterize_body(&mut body, grid, chunks);
        body.prev_pos = body.pos;
        body.prev_angle = body.angle;
        
        self.bodies.push(body);
        id
    }
    
    /// Remove a rigid body by ID
    pub fn remove_body(&mut self, id: u32) {
        self.bodies.retain(|b| b.id != id);
    }
    
    /// Get body count
    pub fn body_count(&self) -> usize {
        self.bodies.len()
    }
    
    /// Main update loop - call BEFORE particle simulation
    /// Now with Torque, Bounce, and Momentum Transfer!
    pub fn update(&mut self, grid: &mut Grid, chunks: &mut ChunkGrid, gravity_y: f32, dt: f32) {
        // Update gravity from world
        self.gravity = gravity_y.abs() * 0.5;
        let gravity_sign = if gravity_y >= 0.0 { 1.0 } else { -1.0 };
        let frame_scale = dt * BASE_FPS;
        
        // Process each body sequentially
        for body in &mut self.bodies {
            if !body.active { continue; }
            
            // === PHASE 1: ERASE from previous position ===
            clear_body_from_grid(body, grid, chunks);
            body.save_prev_state();
            
            // === PHASE 2: APPLY FORCES ===
            // Gravity
            body.velocity.y += self.gravity * gravity_sign * frame_scale;
            
            // Clamp velocity
            body.velocity.x = body.velocity.x.clamp(-10.0, 10.0);
            body.velocity.y = body.velocity.y.clamp(-10.0, 10.0);
            
            // Predict next position
            let next_x = body.pos.x + body.velocity.x * frame_scale;
            let next_y = body.pos.y + body.velocity.y * frame_scale;
            
            // === PHASE 3: COLLISION DETECTION with Momentum Transfer ===
            let collision = check_collision_advanced(next_x, next_y, body, grid, chunks, true);
            
            // Slow down body if it penetrated soft materials (drag effect)
            if collision.penetrated_count > 0 {
                let drag = 0.95_f32.powi(collision.penetrated_count as i32);
                body.velocity = body.velocity * drag;
            }
            
            if collision.hit {
                // === PHASE 4: TORQUE from asymmetric contact ===
                if collision.contact_count > 0 {
                    // Calculate contact center
                    let contact_x = collision.contact_sum_x / collision.contact_count as f32;
                    let contact_y = collision.contact_sum_y / collision.contact_count as f32;
                    
                    // Vector from body center to contact center ("arm")
                    let arm_x = contact_x - body.pos.x;
                    let arm_y = contact_y - body.pos.y;
                    
                    // Reaction force (opposite to gravity when resting on ground)
                    // Simplified: use velocity magnitude as proxy for impact force
                    let impact_force = body.velocity.length() * body.mass * 0.1;
                    
                    // 2D cross product: torque = arm Ã— force
                    // If contact is to the LEFT of center (arm_x < 0) and force pushes UP,
                    // torque is positive (counter-clockwise)
                    let torque = arm_x * impact_force * gravity_sign;
                    
                    // Apply torque
                    body.angular_vel += torque / body.moment_of_inertia;
                }
                
                // === PHASE 5: BOUNCE - Reflect velocity off collision normal ===
                if collision.normal_sum.length_squared() > 0.01 {
                    let normal = collision.normal_sum.normalize();
                    
                    // Only bounce if we have significant velocity
                    if body.velocity.length_squared() > 2.0 {
                        // Vector reflection: V' = V - 2(VÂ·N)N
                        let dot = body.velocity.dot(normal);
                        
                        // Only reflect if moving INTO the surface (dot < 0 means moving away)
                        if dot < 0.0 {
                            let bounce_vel = Vec2::new(
                                body.velocity.x - 2.0 * dot * normal.x,
                                body.velocity.y - 2.0 * dot * normal.y,
                            );
                            
                            // Apply restitution (bounciness)
                            body.velocity = bounce_vel * body.restitution;
                            
                            // Add spin from glancing collision
                            body.angular_vel += dot * 0.02;
                        }
                    } else {
                        // Low velocity - come to rest
                        body.velocity = Vec2::zero();
                    }
                }
                
                // === Resolve position: try axis-separated movement ===
                if collision.hit_y && !collision.hit_x {
                    // Can still move horizontally
                    let friction_factor = self.friction.powf(frame_scale);
                    body.velocity.x *= friction_factor;
                    let next_x_only = body.pos.x + body.velocity.x;
                    if !check_collision_simple(next_x_only, body.pos.y, body, grid) {
                        body.pos.x = next_x_only;
                    }
                } else if collision.hit_x && !collision.hit_y {
                    // Can still move vertically
                    let next_y_only = body.pos.y + body.velocity.y;
                    if !check_collision_simple(body.pos.x, next_y_only, body, grid) {
                        body.pos.y = next_y_only;
                    }
                }
                // If both axes blocked - body stays in place
                
                // Rest threshold
                if body.velocity.length_squared() < REST_THRESHOLD * REST_THRESHOLD {
                    body.velocity = Vec2::zero();
                }
            } else {
                // === No collision - move freely ===
                body.pos.x = next_x;
                body.pos.y = next_y;
            }
            
            // === PHASE 6: ROTATION ===
            // Clamp angular velocity to prevent crazy spinning
            body.angular_vel = body.angular_vel.clamp(-MAX_ANGULAR_VEL, MAX_ANGULAR_VEL);
            
            body.angle += body.angular_vel * frame_scale;
            body.angular_vel *= ANGULAR_DAMPING.powf(frame_scale);
            
            // Angular rest threshold - stop small oscillations
            if body.angular_vel.abs() < ANGULAR_REST_THRESHOLD {
                body.angular_vel = 0.0;
            }
            
            // Keep angle in reasonable range to avoid float precision issues
            if body.angle.abs() > std::f32::consts::TAU {
                body.angle = body.angle % std::f32::consts::TAU;
            }
            
            // === PHASE 7: RASTERIZE at new position ===
            rasterize_body(body, grid, chunks);
            
            // Update prev state for next frame
            body.prev_pos = body.pos;
            body.prev_angle = body.angle;
        }
    }
}

impl Default for RigidBodySystem {
    fn default() -> Self {
        Self::new()
    }
}

--- End of File: packages/engine/src/rigid_body_system.rs ---


--- File: packages/engine/src/temperature.rs ---

//! Temperature System - Thermodynamics and Phase Changes
//! 
//! Port from: apps/web/src/lib/engine/core/Simulation.ts
//! EXACT 1:1 port of the TypeScript temperature algorithms
//! 
//! - Heat transfer using Newton's law of cooling (simplified)
//! - Stochastic: only check ONE random neighbor for performance
//! - Phase changes (melting, freezing, boiling, condensing)

use crate::grid::Grid;
use crate::elements::{
    ELEMENT_DATA, ElementId, EL_EMPTY, EL_STONE, EL_SAND, EL_METAL, EL_ICE, EL_WATER, EL_STEAM, EL_LAVA,
    ELEMENT_COUNT, get_color_with_variation
};

/// Phase change definitions: (element, high_temp, high_to, low_temp, low_to)
/// EXACT match to TypeScript apps/web/src/lib/engine/elements.ts
const PHASE_CHANGES: [(ElementId, Option<(f32, ElementId)>, Option<(f32, ElementId)>); 7] = [
    // Stone: melts at 900Â°C -> Lava
    (EL_STONE, Some((900.0, EL_LAVA)), None),
    // Sand: melts at 1700Â°C -> Lava (glass)
    (EL_SAND, Some((1700.0, EL_LAVA)), None),
    // Metal: melts at 1500Â°C -> Lava
    (EL_METAL, Some((1500.0, EL_LAVA)), None),
    // Ice: melts at 0Â°C -> Water
    (EL_ICE, Some((0.0, EL_WATER)), None),
    // Water: boils at 100Â°C -> Steam, freezes at 0Â°C -> Ice
    (EL_WATER, Some((100.0, EL_STEAM)), Some((0.0, EL_ICE))),
    // Lava: solidifies at 700Â°C -> Stone
    (EL_LAVA, None, Some((700.0, EL_STONE))),
    // Steam: condenses at 90Â°C -> Water (EXACT TypeScript value!)
    (EL_STEAM, None, Some((90.0, EL_WATER))),
];

/// Get phase change for element at given temperature
/// Returns new element if phase change occurs, None otherwise
pub fn check_phase_change(element: ElementId, temp: f32) -> Option<ElementId> {
    for (el, high, low) in PHASE_CHANGES.iter() {
        if *el == element {
            // Check high temp (melting/boiling)
            if let Some((threshold, new_el)) = high {
                if temp > *threshold {
                    return Some(*new_el);
                }
            }
            // Check low temp (freezing/condensing)
            if let Some((threshold, new_el)) = low {
                if temp < *threshold {
                    return Some(*new_el);
                }
            }
            return None;
        }
    }
    None
}

/// Process temperature for entire grid
/// Mirrors TypeScript processTemperatureGrid exactly
pub fn process_temperature_grid(grid: &mut Grid, ambient_temp: f32, frame: u64, rng: &mut u32) {
    let h = grid.height();
    let w = grid.width();
    
    for y in 0..h {
        for x in 0..w {
            update_temperature(grid, x, y, ambient_temp, frame, rng);
        }
    }
}

/// Heat transfer using Newton's law of cooling (simplified)
/// Stochastic: only check ONE random neighbor for performance
/// EXACT port of TypeScript updateTemperature
fn update_temperature(grid: &mut Grid, x: u32, y: u32, ambient_temp: f32, frame: u64, rng: &mut u32) {
    let xi = x as i32;
    let yi = y as i32;
    
    let my_temp = grid.get_temp(xi, yi);
    let element = grid.get_type(xi, yi);
    
    // Empty cells (air) tend towards ambient temperature
    if element == EL_EMPTY {
        let diff = ambient_temp - my_temp;
        
        if diff.abs() > 0.5 {
            grid.set_temp(x, y, my_temp + diff * 0.02);
        }
    }
    
    // Get conductivity (air = 5 if empty)
    let conductivity = if element != EL_EMPTY && (element as usize) < ELEMENT_COUNT {
        ELEMENT_DATA[element as usize].heat_conductivity
    } else {
        5
    };
    
    // Skip if insulator (conductivity 0)
    if conductivity == 0 { return; }
    
    // Pick random neighbor direction (EXACT TypeScript: Math.floor(Math.random() * 4))
    // PHASE 1 OPT: & 3 instead of % 4 (saves ~40 CPU cycles)
    let dir = xorshift32(rng) & 3;
    let (nx, ny) = match dir {
        0 => (xi, yi - 1),     // Up
        1 => (xi, yi + 1),     // Down
        2 => (xi - 1, yi),     // Left
        _ => (xi + 1, yi),     // Right
    };
    
    // Boundary: heat sink to ambient temperature
    if !grid.in_bounds(nx, ny) {
        let diff = ambient_temp - my_temp;
        // Slow heat loss at edges
        grid.set_temp(x, y, my_temp + diff * 0.02);
        return;
    }
    
    // Heat transfer with neighbor
    let neighbor_temp = grid.get_temp(nx, ny);
    let diff = neighbor_temp - my_temp;
    
    // Optimization: skip if temperature difference is negligible
    if diff.abs() < 0.5 { return; }
    
    // Transfer rate based on conductivity (0-100 â†’ 0.0-0.5)
    let transfer_rate = (conductivity as f32 / 100.0) * 0.5;
    
    // Exchange heat (conservation of energy)
    let new_temp = my_temp + diff * transfer_rate;
    grid.set_temp(x, y, new_temp);
    grid.set_temp(nx as u32, ny as u32, neighbor_temp - diff * transfer_rate);
    
    // Check phase changes for particles
    if element != EL_EMPTY {
        if let Some(new_element) = check_phase_change(element, new_temp) {
            transform_particle(grid, x, y, new_element, new_temp, frame);
        }
    }
}

/// Transform particle to new element, preserving temperature
/// Mirrors TypeScript transformParticle exactly
fn transform_particle(grid: &mut Grid, x: u32, y: u32, new_element: ElementId, temp: f32, frame: u64) {
    let seed = ((x * 7 + y * 13 + frame as u32) & 31) as u8;
    let props = &ELEMENT_DATA[new_element as usize];
    
    grid.set_particle(
        x, y,
        new_element,
        get_color_with_variation(new_element, seed),
        props.lifetime,
        temp  // Keep temperature! Hot stone from lava stays hot
    );
    
    // Mark as updated so it doesn't process again this frame
    grid.set_updated(x, y, true);
}

/// Transform particle (chunk-aware): also marks chunk dirty for rendering
fn transform_particle_with_chunks(
    grid: &mut Grid,
    chunks: &mut ChunkGrid,
    x: u32,
    y: u32,
    new_element: ElementId,
    temp: f32,
    frame: u64
) {
    if new_element == EL_EMPTY {
        grid.clear_cell(x, y);
        chunks.remove_particle(x, y);
    } else {
        let seed = ((x * 7 + y * 13 + frame as u32) & 31) as u8;
        let props = &ELEMENT_DATA[new_element as usize];

        grid.set_particle(
            x, y,
            new_element,
            get_color_with_variation(new_element, seed),
            props.lifetime,
            temp
        );

        grid.set_updated(x, y, true);
    }

    chunks.mark_dirty(x, y);
}

/// Xorshift32 random number generator
#[inline]
fn xorshift32(state: &mut u32) -> u32 {
    let mut x = *state;
    x ^= x << 13;
    x ^= x >> 17;
    x ^= x << 5;
    *state = x;
    x
}

use crate::chunks::{ChunkGrid, CHUNK_SIZE};

/// Lazy Hydration: Process temperature with chunk-aware optimization
/// 
/// - Sleeping chunks: Only update virtual_temp (O(1) per chunk)
/// - Active chunks: SIMD air lerp + scalar particle processing
/// 
/// PHASE 1 OPT: Two-pass approach for active chunks:
/// 1. SIMD batch lerp for air cells (fast!)
/// 2. Scalar processing for non-empty cells (heat transfer + phase changes)
/// 
/// This reduces O(W*H) to O(active_pixels + all_chunks)
pub fn process_temperature_grid_chunked(
    grid: &mut Grid,
    chunks: &mut ChunkGrid,  // Now mutable for virtual_temp updates!
    ambient_temp: f32,
    frame: u64,
    rng: &mut u32
) {
    let (cx_count, cy_count) = chunks.dimensions();
    
    // Air conductivity speed (same as in update_temperature: 0.02)
    const AIR_LERP_SPEED: f32 = 0.02;
    
    for cy in 0..cy_count {
        for cx in 0..cx_count {
            if chunks.is_sleeping(cx, cy) {
                // === PATH 1: CHUNK IS SLEEPING (Fast O(1)) ===
                // Just smoothly animate virtual_temp towards ambient
                // This is the SAME math as update_temperature for air, but for ONE number
                chunks.update_virtual_temp(cx, cy, ambient_temp, AIR_LERP_SPEED);
            } else {
                // === PATH 2: CHUNK IS ACTIVE ===
                // PHASE 1 OPT: Two-pass processing
                
                // PASS 1: SIMD batch lerp for all air cells (fast!)
                // This does the same thing as update_temperature for empty cells
                // but processes 4 cells at once with SIMD
                unsafe {
                    grid.batch_lerp_air_temps(cx, cy, ambient_temp, AIR_LERP_SPEED);
                }
                
                // PASS 2: Scalar processing for non-empty cells only
                // These need neighbor-based heat transfer and phase changes
                let start_x = cx * CHUNK_SIZE;
                let start_y = cy * CHUNK_SIZE;
                let end_x = (start_x + CHUNK_SIZE).min(grid.width());
                let end_y = (start_y + CHUNK_SIZE).min(grid.height());
                
                for y in start_y..end_y {
                    for x in start_x..end_x {
                        // Only process non-empty cells (air was handled by SIMD pass)
                        let element = grid.get_type(x as i32, y as i32);
                        if element != EL_EMPTY {
                            update_particle_temperature(grid, chunks, x, y, ambient_temp, frame, rng);
                        }
                    }
                }
                
                // Sync virtual_temp with actual air temperature in chunk
                // (so when chunk goes to sleep, it continues from correct value)
                // Do this every 4th frame to save CPU
                // PHASE 1 OPT: & 3 instead of % 4
                if frame & 3 == 0 {
                    let avg = grid.get_average_air_temp(cx, cy);
                    chunks.set_virtual_temp(cx, cy, avg);
                }
            }
        }
    }
}

/// Update temperature for a single NON-EMPTY cell (particle)
/// PHASE 1 OPT: Separate function for particles only (air handled by SIMD batch)
fn update_particle_temperature(
    grid: &mut Grid,
    chunks: &mut ChunkGrid,
    x: u32,
    y: u32,
    ambient_temp: f32,
    frame: u64,
    rng: &mut u32
) {
    let xi = x as i32;
    let yi = y as i32;
    
    let my_temp = grid.get_temp(xi, yi);
    let element = grid.get_type(xi, yi);
    
    // Skip if empty (shouldn't happen, but guard)
    if element == EL_EMPTY { return; }
    
    // Get conductivity
    let conductivity = if (element as usize) < ELEMENT_COUNT {
        ELEMENT_DATA[element as usize].heat_conductivity
    } else {
        return; // Invalid element
    };
    
    // Skip if insulator (conductivity 0)
    if conductivity == 0 { return; }
    
    // BUG FIX: Check phase changes FIRST using CURRENT temperature
    // This ensures frozen water turns to ice even if at thermal equilibrium
    // (when diff < 0.5 would cause early return before old phase check)
    if let Some(new_element) = check_phase_change(element, my_temp) {
        transform_particle_with_chunks(grid, chunks, x, y, new_element, my_temp, frame);
        return; // Already transformed, no need for heat transfer
    }
    
    // Pick random neighbor direction
    // PHASE 1 OPT: & 3 instead of % 4
    let dir = xorshift32(rng) & 3;
    let (nx, ny) = match dir {
        0 => (xi, yi - 1),     // Up
        1 => (xi, yi + 1),     // Down
        2 => (xi - 1, yi),     // Left
        _ => (xi + 1, yi),     // Right
    };
    
    // Boundary: heat sink to ambient temperature
    if !grid.in_bounds(nx, ny) {
        let diff = ambient_temp - my_temp;
        grid.set_temp(x, y, my_temp + diff * 0.02);
        return;
    }
    
    // Heat transfer with neighbor
    let neighbor_temp = grid.get_temp(nx, ny);
    let diff = neighbor_temp - my_temp;
    
    // Optimization: skip if temperature difference is negligible
    if diff.abs() < 0.5 { return; }
    
    // Transfer rate based on conductivity (0-100 â†’ 0.0-0.5)
    let transfer_rate = (conductivity as f32 / 100.0) * 0.5;
    
    // Exchange heat (conservation of energy)
    let new_temp = my_temp + diff * transfer_rate;
    grid.set_temp(x, y, new_temp);
    grid.set_temp(nx as u32, ny as u32, neighbor_temp - diff * transfer_rate);
    
    // Check phase changes for particles
    if let Some(new_element) = check_phase_change(element, new_temp) {
        transform_particle_with_chunks(grid, chunks, x, y, new_element, new_temp, frame);
    }
}

// ============================================================================
// PHASE 3: SIMD-OPTIMIZED TEMPERATURE PROCESSING
// ============================================================================
// 
// WASM SIMD128 provides 128-bit vectors:
// - f32x4: 4 float32 values processed in ONE instruction
// - Speedup: 2-4x for bulk temperature operations
// 
// Usage: Call update_air_temperature_simd for rows of empty cells

#[cfg(target_arch = "wasm32")]
use std::arch::wasm32::*;

/// SIMD: Update air temperature for 4 cells at once
/// All 4 cells lerp towards ambient temperature
/// 
/// # Safety
/// - `temps_ptr` must be aligned to 16 bytes and valid for `count` f32s
/// - `count` must be divisible by 4
#[cfg(target_arch = "wasm32")]
#[inline]
pub unsafe fn update_air_temperature_simd(
    temps_ptr: *mut f32,
    count: usize,
    ambient_temp: f32,
    lerp_speed: f32,
) {
    // Broadcast constants to all 4 lanes
    let v_ambient = f32x4_splat(ambient_temp);
    let v_lerp = f32x4_splat(lerp_speed);
    let v_one_minus_lerp = f32x4_splat(1.0 - lerp_speed);
    
    let mut i = 0;
    while i + 4 <= count {
        let ptr = temps_ptr.add(i);
        
        // Load 4 temperatures
        let v_current = v128_load(ptr as *const v128);
        
        // new_temp = current * (1 - lerp) + ambient * lerp
        // This is equivalent to: current + (ambient - current) * lerp
        let v_scaled_current = f32x4_mul(v_current, v_one_minus_lerp);
        let v_scaled_ambient = f32x4_mul(v_ambient, v_lerp);
        let v_new = f32x4_add(v_scaled_current, v_scaled_ambient);
        
        // Store back
        v128_store(ptr as *mut v128, v_new);
        
        i += 4;
    }
    
    // Handle remainder (0-3 cells) with scalar code
    while i < count {
        let ptr = temps_ptr.add(i);
        let current = *ptr;
        *ptr = current + (ambient_temp - current) * lerp_speed;
        i += 1;
    }
}

/// SIMD: Batch process diffusion between cell and its right neighbor
/// Processes 4 pairs at once: (i, i+1), (i+2, i+3), (i+4, i+5), (i+6, i+7)
/// 
/// # Safety
/// - `temps_ptr` must be valid for at least `count + 1` f32s
/// - `count` must be divisible by 4
#[cfg(target_arch = "wasm32")]
#[inline]
pub unsafe fn diffuse_horizontal_simd(
    temps_ptr: *mut f32,
    count: usize,
    transfer_rate: f32,
) {
    let v_rate = f32x4_splat(transfer_rate);
    let v_threshold = f32x4_splat(0.5);
    
    // Process in steps of 4, comparing each cell with its right neighbor
    let mut i = 0;
    while i + 4 < count {
        let ptr = temps_ptr.add(i);
        
        // Load current 4 temps and next 4 temps (shifted by 1)
        let v_current = v128_load(ptr as *const v128);
        let v_next = v128_load(ptr.add(1) as *const v128);
        
        // diff = next - current
        let v_diff = f32x4_sub(v_next, v_current);
        let v_abs_diff = f32x4_abs(v_diff);
        
        // Only transfer if |diff| > threshold (create mask)
        let v_mask = f32x4_gt(v_abs_diff, v_threshold);
        
        // change = diff * rate (only where mask is true)
        let v_change = f32x4_mul(v_diff, v_rate);
        let v_masked_change = v128_and(v_change, v_mask);
        
        // Apply: current += change, next -= change
        let v_new_current = f32x4_add(v_current, v_masked_change);
        let v_new_next = f32x4_sub(v_next, v_masked_change);
        
        v128_store(ptr as *mut v128, v_new_current);
        v128_store(ptr.add(1) as *mut v128, v_new_next);
        
        i += 4;
    }
}

/// Process a full row of temperatures with SIMD (air cells only)
/// Fallback for non-WASM targets
#[cfg(not(target_arch = "wasm32"))]
pub unsafe fn update_air_temperature_simd(
    temps_ptr: *mut f32,
    count: usize,
    ambient_temp: f32,
    lerp_speed: f32,
) {
    for i in 0..count {
        let ptr = temps_ptr.add(i);
        let current = *ptr;
        *ptr = current + (ambient_temp - current) * lerp_speed;
    }
}

#[cfg(not(target_arch = "wasm32"))]
pub unsafe fn diffuse_horizontal_simd(
    _temps_ptr: *mut f32,
    _count: usize,
    _transfer_rate: f32,
) {
    // No-op on non-WASM, use scalar path
}

--- End of File: packages/engine/src/temperature.rs ---


--- File: packages/engine/src/utils/mod.rs ---

//! Utility modules for the particle engine

pub mod safety;

--- End of File: packages/engine/src/utils/mod.rs ---


--- File: packages/engine/src/utils/safety.rs ---

//! Zero-Cost Safety Macros
//! 
//! Phase 4: "Roll Cage" - Debug checks in dev, raw speed in prod
//! 
//! In Debug mode: Normal bounds-checked access (panics with useful errors)
//! In Release mode: Unsafe unchecked access (zero overhead)
//! 
//! Usage:
//! ```rust
//! // Read: fast!(slice, [index])
//! let val = *fast!(self.types, [idx]);
//! 
//! // Write: fast!(slice, [index] = value)
//! fast!(self.life, [idx] = 100);
//! ```

/// Zero-cost bounds checking macro
/// 
/// - Debug: Uses normal indexing with bounds checks
/// - Release: Uses get_unchecked/get_unchecked_mut
/// 
/// This gives you the best of both worlds:
/// - Safe development with clear panic messages
/// - Maximum performance in production
#[macro_export]
macro_rules! fast {
    // Read pattern: fast!(slice, [index])
    ($slice:expr, [$index:expr]) => {{
        #[cfg(debug_assertions)]
        {
            // Debug: Normal access with bounds check
            &$slice[$index]
        }
        #[cfg(not(debug_assertions))]
        {
            // Release: Unsafe unchecked access
            unsafe { $slice.get_unchecked($index) }
        }
    }};
    
    // Write pattern: fast!(slice, [index] = value)
    ($slice:expr, [$index:expr] = $val:expr) => {{
        #[cfg(debug_assertions)]
        {
            // Debug: Normal access with bounds check
            $slice[$index] = $val;
        }
        #[cfg(not(debug_assertions))]
        {
            // Release: Unsafe unchecked access
            unsafe { *$slice.get_unchecked_mut($index) = $val; }
        }
    }};
}

/// Unsafe block wrapper for explicit "I know what I'm doing" sections
/// In debug mode, adds extra logging before the unsafe operation
#[macro_export]
macro_rules! unsafe_fast {
    ($($code:tt)*) => {{
        #[cfg(debug_assertions)]
        {
            // In debug, still run the unsafe code but could add logging here
            unsafe { $($code)* }
        }
        #[cfg(not(debug_assertions))]
        {
            unsafe { $($code)* }
        }
    }};
}

#[cfg(test)]
mod tests {
    #[test]
    fn test_fast_read() {
        let arr = vec![1, 2, 3, 4, 5];
        let val = *fast!(arr, [2]);
        assert_eq!(val, 3);
    }
    
    #[test]
    fn test_fast_write() {
        let mut arr = vec![1, 2, 3, 4, 5];
        fast!(arr, [2] = 100);
        assert_eq!(arr[2], 100);
    }
    
    #[test]
    #[should_panic]
    #[cfg(debug_assertions)]
    fn test_fast_bounds_check_debug() {
        let arr = vec![1, 2, 3];
        let _ = *fast!(arr, [10]); // Should panic in debug
    }
}

--- End of File: packages/engine/src/utils/safety.rs ---


--- File: packages/engine/src/world.rs ---

//! World - High-performance particle simulation
//! 
//! Phase 4: Chunk-based spatial optimization
//! 
//! Refactored for SOLID principles:
//! - Single Responsibility: World only orchestrates, delegates to behaviors/reactions/temperature
//! - Open/Closed: New behaviors can be added without modifying this file
//! 
//! All particle physics are in behaviors/ module
//! Chemical reactions are in reactions.rs
//! Temperature system is in temperature.rs
//! Chunk optimization in chunks.rs

use wasm_bindgen::prelude::*;
use crate::grid::Grid;
use crate::chunks::{ChunkGrid, CHUNK_SIZE, MergedDirtyRects};
use crate::elements::{
    ELEMENT_DATA, ElementId, EL_EMPTY, ELEMENT_COUNT,
    get_color_with_variation, get_props
};
use crate::behaviors::{BehaviorRegistry, UpdateContext};
use crate::reactions::{Reaction, ReactionSystem};
use crate::temperature::process_temperature_grid_chunked;
use crate::physics::update_particle_physics;
use crate::rigid_body::RigidBody;
use crate::rigid_body_system::RigidBodySystem;

// === Time configuration (Phase 1: Fixed timestep + substeps) ===
const FIXED_DT: f32 = 1.0 / 60.0;
const MAX_STEPS_PER_FRAME: u32 = 8;
const SUBSTEPS: u32 = 4;
const SUB_DT: f32 = FIXED_DT / SUBSTEPS as f32;

/// Random number generator (xorshift32)
#[inline]
fn xorshift32(state: &mut u32) -> u32 {
    let mut x = *state;
    x ^= x << 13;
    x ^= x >> 17;
    x ^= x << 5;
    *state = x;
    x
}

/// The simulation world
#[wasm_bindgen]
pub struct World {
    grid: Grid,
    chunks: ChunkGrid,
    behaviors: BehaviorRegistry,
    reactions: ReactionSystem,  // Phase 1: Data-driven O(1) reaction lookup
    rigid_bodies: RigidBodySystem,  // Rigid body physics system
    
    // Settings
    gravity_x: f32,
    gravity_y: f32,
    ambient_temperature: f32,
    
    // State
    particle_count: u32,
    frame: u64,
    rng_state: u32,
    accumulated_time: f32,
    
    // Phase 3: Smart Rendering buffers
    dirty_list: Vec<u32>,           // List of dirty chunk indices for rendering
    chunk_transfer_buffer: Vec<u32>, // 32x32 pixel buffer for chunk extraction
    
    // Phase 2: Merged dirty rectangles for GPU batching
    merged_rects: MergedDirtyRects,
    rect_transfer_buffer: Vec<u32>, // Larger buffer for merged rect extraction
}

#[wasm_bindgen]
impl World {
    /// Create a new world with given dimensions
    #[wasm_bindgen(constructor)]
    pub fn new(width: u32, height: u32) -> Self {
        Self {
            grid: Grid::new(width, height),
            chunks: ChunkGrid::new(width, height),
            behaviors: BehaviorRegistry::new(),
            reactions: ReactionSystem::new(), // Phase 1: O(1) reaction lookup
            rigid_bodies: RigidBodySystem::new(), // Rigid body physics
            gravity_x: 0.0,
            gravity_y: 1.0,
            ambient_temperature: 20.0,
            particle_count: 0,
            frame: 0,
            rng_state: 12345,
            accumulated_time: 0.0,
            // Phase 3: Smart Rendering
            dirty_list: Vec::with_capacity(1000),
            chunk_transfer_buffer: vec![0u32; (CHUNK_SIZE * CHUNK_SIZE) as usize],
            
            // Phase 2: GPU Batching
            merged_rects: MergedDirtyRects::new(500), // Max 500 rectangles
            rect_transfer_buffer: vec![0u32; (CHUNK_SIZE * CHUNK_SIZE * 16) as usize], // Max 4x4 chunks = 128x128 pixels
        }
    }

    #[wasm_bindgen(getter)]
    pub fn width(&self) -> u32 { self.grid.width() }

    #[wasm_bindgen(getter)]
    pub fn height(&self) -> u32 { self.grid.height() }

    #[wasm_bindgen(getter)]
    pub fn particle_count(&self) -> u32 { self.particle_count }

    #[wasm_bindgen(getter)]
    pub fn frame(&self) -> u64 { self.frame }

    pub fn set_gravity(&mut self, x: f32, y: f32) {
        // Phase 2: Use actual gravity values for velocity-based physics
        // Higher values = faster acceleration
        self.gravity_x = x;
        self.gravity_y = y;
    }

    pub fn set_ambient_temperature(&mut self, temp: f32) {
        self.ambient_temperature = temp;
    }
    
    /// DEBUG: Get current ambient temperature
    pub fn get_ambient_temperature(&self) -> f32 {
        self.ambient_temperature
    }

    /// Add a particle at position
    pub fn add_particle(&mut self, x: u32, y: u32, element: u8) -> bool {
        if x >= self.grid.width() || y >= self.grid.height() {
            return false;
        }
        
        // Validate element ID
        if (element as usize) >= ELEMENT_COUNT || element == EL_EMPTY {
            return false;
        }
        
        if !self.grid.is_empty(x as i32, y as i32) {
            return false;
        }
        
        let seed = ((x * 7 + y * 13 + self.frame as u32) & 31) as u8;
        let props = get_props(element);
        
        self.grid.set_particle(
            x, y, 
            element, 
            get_color_with_variation(element, seed),
            props.lifetime,
            props.default_temp
        );
        
        // Phase 4: Track particle in chunk
        self.chunks.add_particle(x, y);
        
        self.particle_count += 1;
        true
    }

    /// Add particles in radius (brush)
    pub fn add_particles_in_radius(&mut self, cx: i32, cy: i32, radius: i32, element: u8) {
        let r2 = radius * radius;
        for dy in -radius..=radius {
            for dx in -radius..=radius {
                if dx * dx + dy * dy <= r2 {
                    let x = cx + dx;
                    let y = cy + dy;
                    if x >= 0 && y >= 0 {
                        self.add_particle(x as u32, y as u32, element);
                    }
                }
            }
        }
    }

    /// Remove particle at position
    pub fn remove_particle(&mut self, x: u32, y: u32) -> bool {
        if x >= self.grid.width() || y >= self.grid.height() {
            return false;
        }
        
        if self.grid.is_empty(x as i32, y as i32) {
            return false;
        }
        
        // Phase 4: Track removal in chunk
        self.chunks.remove_particle(x, y);
        self.chunks.mark_dirty(x, y); // Ensure render updates even without movement
        
        self.grid.clear_cell(x, y);
        if self.particle_count > 0 {
            self.particle_count -= 1;
        }
        true
    }

    /// Remove particles in radius
    pub fn remove_particles_in_radius(&mut self, cx: i32, cy: i32, radius: i32) {
        let r2 = radius * radius;
        for dy in -radius..=radius {
            for dx in -radius..=radius {
                if dx * dx + dy * dy <= r2 {
                    let x = cx + dx;
                    let y = cy + dy;
                    if x >= 0 && y >= 0 {
                        self.remove_particle(x as u32, y as u32);
                    }
                }
            }
        }
    }

    /// Clear all particles
    pub fn clear(&mut self) {
        self.grid.clear();
        self.chunks.reset();
        self.particle_count = 0;
        self.frame = 0;
    }
    
    // === RIGID BODY API ===
    
    /// Spawn a rectangular rigid body at position (x, y) with size (w, h)
    /// Returns the body ID
    pub fn spawn_rigid_body(&mut self, x: f32, y: f32, w: i32, h: i32, element_id: u8) -> u32 {
        let body = RigidBody::new_rect(x, y, w, h, element_id, 0);
        self.rigid_bodies.add_body(body, &mut self.grid, &mut self.chunks)
    }
    
    /// Spawn a circular rigid body at position (x, y) with given radius
    /// Returns the body ID
    pub fn spawn_rigid_circle(&mut self, x: f32, y: f32, radius: i32, element_id: u8) -> u32 {
        let body = RigidBody::new_circle(x, y, radius, element_id, 0);
        self.rigid_bodies.add_body(body, &mut self.grid, &mut self.chunks)
    }
    
    /// Remove a rigid body by ID
    pub fn remove_rigid_body(&mut self, id: u32) {
        self.rigid_bodies.remove_body(id);
    }
    
    /// Get number of active rigid bodies
    pub fn rigid_body_count(&self) -> usize {
        self.rigid_bodies.body_count()
    }

    /// Step the simulation forward
    /// Phase 4: Only process active chunks!
    /// Phase 2: Newtonian physics with velocity
    pub fn step(&mut self) {
        // Backward-compatible single fixed tick (60 FPS baseline)
        self.step_with_dt(FIXED_DT);
    }

    /// Step simulation with variable frame delta (seconds).
    /// Uses accumulator + sub-stepping to keep physics stable across frame rates.
    pub fn step_with_dt(&mut self, dt_seconds: f32) {
        // Clamp extreme pauses to avoid spiral-of-death
        let clamped = dt_seconds.clamp(0.0, FIXED_DT * MAX_STEPS_PER_FRAME as f32);
        // Accumulate time and limit catch-up
        self.accumulated_time = (self.accumulated_time + clamped).min(FIXED_DT * MAX_STEPS_PER_FRAME as f32);

        let mut steps = 0;
        while self.accumulated_time >= FIXED_DT && steps < MAX_STEPS_PER_FRAME {
            self.accumulated_time -= FIXED_DT;
            // Sub-steps for stability (contact resolution, stacking)
            for _ in 0..SUBSTEPS {
                self.fixed_step(SUB_DT);
            }
            steps += 1;
        }
    }

    /// Single fixed sub-step with explicit dt (seconds)
    fn fixed_step(&mut self, dt: f32) {
        // === LAZY HYDRATION: Process waking chunks ===
        // When a chunk transitions Sleep -> Active, we need to fill its air cells
        // with the current virtual_temp (which has been smoothly animating)
        self.hydrate_waking_chunks();
        
        // Reset updated flags and clear move tracking
        self.grid.reset_updated();
        self.grid.clear_moves();
        
        // Phase 4: Begin frame for chunk tracking
        self.chunks.begin_frame();
        
        // === RIGID BODY PHYSICS ===
        // Update rigid bodies BEFORE particle physics so particles can react to new body positions
        self.rigid_bodies.update(&mut self.grid, &mut self.chunks, self.gravity_y, dt);
        
        // === PHASE 2: PHYSICS PASS ===
        // Apply gravity and velocity-based movement BEFORE behavior pass
        self.process_physics(dt);
        
        let go_right = (self.frame & 1) == 0;
        let (chunks_x, chunks_y) = self.chunks.dimensions();
        
        // Process chunks from bottom to top (for gravity)
        if self.gravity_y >= 0.0 {
            for cy in (0..chunks_y).rev() {
                self.process_chunk_row(cy, chunks_x, go_right, dt);
            }
        } else {
            for cy in 0..chunks_y {
                self.process_chunk_row(cy, chunks_x, go_right, dt);
            }
        }
        
        // Phase 4.1: Apply recorded moves to chunk system
        self.apply_pending_moves();
        
        // Temperature pass - run every other frame for performance
        // Lazy Hydration: now updates virtual_temp for sleeping chunks!
        const TEMP_STRIDE: u64 = (2 * SUBSTEPS) as u64;
        if self.frame % TEMP_STRIDE == 0 {
            process_temperature_grid_chunked(
                &mut self.grid,
                &mut self.chunks,  // Now mutable for virtual_temp updates
                self.ambient_temperature,
                self.frame,
                &mut self.rng_state
            );
        }
        
        self.frame += 1;
    }
    
    /// Lazy Hydration: Fill waking chunks with their virtual temperature
    /// This ensures particles entering a previously-sleeping chunk
    /// encounter the correct (smoothly animated) air temperature
    fn hydrate_waking_chunks(&mut self) {
        let (chunks_x, _) = self.chunks.dimensions();
        
        for (idx, &woke) in self.chunks.just_woke_up.iter().enumerate() {
            if woke {
                let cx = (idx as u32) % chunks_x;
                let cy = (idx as u32) / chunks_x;
                let v_temp = self.chunks.virtual_temp[idx];
                
                // Fill all air cells in this chunk with the virtual temperature
                self.grid.hydrate_chunk(cx, cy, v_temp);
            }
        }
        
        // Clear wake flags after processing
        self.chunks.clear_wake_flags();
    }
    
    /// Phase 4.1: Apply all recorded moves to chunk tracking
    /// Zero-allocation: uses raw pointer iteration instead of drain()
    fn apply_pending_moves(&mut self) {
        let count = self.grid.pending_moves.count;
        let moves_ptr = self.grid.pending_moves.as_ptr();
        
        // SAFETY: We iterate only over valid data (0..count)
        // ParticleMove is Copy, so we can read directly
        unsafe {
            for i in 0..count {
                let (from_x, from_y, to_x, to_y) = *moves_ptr.add(i);
                self.chunks.move_particle(from_x, from_y, to_x, to_y);
            }
        }
    }
    
    /// Phase 2: Process physics for all particles in active chunks
    /// Applies gravity and velocity-based movement
    /// 
    /// CRITICAL: Processing order depends on gravity direction!
    /// - Positive gravity (down): process bottom-to-top
    /// - Negative gravity (up): process top-to-bottom
    fn process_physics(&mut self, dt: f32) {
        let (chunks_x, chunks_y) = self.chunks.dimensions();
        let gravity_y = self.gravity_y;
        
        // Choose processing order based on gravity direction
        if gravity_y >= 0.0 {
            // Positive gravity: particles fall DOWN â†’ process bottom-to-top
            for cy in (0..chunks_y).rev() {
                for cx in 0..chunks_x {
                    self.process_physics_chunk(cx, cy, gravity_y, false, dt);
                }
            }
        } else {
            // Negative gravity: particles fly UP â†’ process top-to-bottom
            for cy in 0..chunks_y {
                for cx in 0..chunks_x {
                    self.process_physics_chunk(cx, cy, gravity_y, true, dt);
                }
            }
        }
    }
    
    /// Process physics for a single chunk
    fn process_physics_chunk(&mut self, cx: u32, cy: u32, gravity_y: f32, top_to_bottom: bool, dt: f32) {
        if self.chunks.is_sleeping(cx, cy) {
            return;
        }
        
        let start_x = cx * CHUNK_SIZE;
        let start_y = cy * CHUNK_SIZE;
        let end_x = (start_x + CHUNK_SIZE).min(self.grid.width());
        let end_y = (start_y + CHUNK_SIZE).min(self.grid.height());
        
        if top_to_bottom {
            // For negative gravity: process top-to-bottom
            for y in start_y..end_y {
                for x in start_x..end_x {
                    let element = self.grid.get_type(x as i32, y as i32);
                    if element != EL_EMPTY {
                        update_particle_physics(&mut self.grid, &mut self.chunks, x, y, gravity_y, dt);
                    }
                }
            }
        } else {
            // For positive gravity: process bottom-to-top
            for y in (start_y..end_y).rev() {
                for x in start_x..end_x {
                    let element = self.grid.get_type(x as i32, y as i32);
                    if element != EL_EMPTY {
                        update_particle_physics(&mut self.grid, &mut self.chunks, x, y, gravity_y, dt);
                    }
                }
            }
        }
    }
    
    /// Get active chunk count (for debugging/stats)
    pub fn active_chunks(&self) -> usize {
        self.chunks.active_chunk_count()
    }
    
    /// Get total chunk count
    pub fn total_chunks(&self) -> usize {
        self.chunks.total_chunks()
    }

    /// Get pointer to types array (for JS rendering)
    pub fn types_ptr(&self) -> *const u8 {
        self.grid.types_ptr()
    }

    /// Get pointer to colors array (for JS rendering)
    pub fn colors_ptr(&self) -> *const u32 {
        self.grid.colors_ptr()
    }

    /// Get grid size for types
    pub fn types_len(&self) -> usize {
        self.grid.size()
    }

    /// Get grid size for colors
    pub fn colors_len(&self) -> usize {
        self.grid.size() * 4
    }
    
    /// Get pointer to temperature array (for JS thermal rendering)
    pub fn temperature_ptr(&self) -> *const f32 {
        self.grid.temperature_ptr()
    }
    
    /// Get temperature array length
    pub fn temperature_len(&self) -> usize {
        self.grid.size()
    }
    
    // === PHASE 3: SMART RENDERING API ===
    
    /// Collect list of dirty chunks that need rendering
    /// Uses visual_dirty (separate from physics dirty) to avoid state desync
    pub fn collect_dirty_chunks(&mut self) -> usize {
        self.dirty_list.clear();
        let total = self.chunks.total_chunks();
        
        for i in 0..total {
            if self.chunks.visual_dirty[i] {
                self.dirty_list.push(i as u32);
                self.chunks.clear_visual_dirty(i);
            }
        }
        
        self.dirty_list.len()
    }
    
    /// Get pointer to dirty chunk list
    pub fn get_dirty_list_ptr(&self) -> *const u32 {
        self.dirty_list.as_ptr()
    }
    
    /// Extract pixels from a chunk into transfer buffer (strided -> linear)
    /// Returns pointer to the transfer buffer
    pub fn extract_chunk_pixels(&mut self, chunk_idx: u32) -> *const u32 {
        let (cx_count, _) = self.chunks.dimensions();
        let cx = chunk_idx % cx_count;
        let cy = chunk_idx / cx_count;
        
        let start_x = cx * CHUNK_SIZE;
        let start_y = cy * CHUNK_SIZE;
        let end_x = (start_x + CHUNK_SIZE).min(self.grid.width());
        let end_y = (start_y + CHUNK_SIZE).min(self.grid.height());
        
        let grid_width = self.grid.width() as usize;
        let colors_ptr = self.grid.colors.as_ptr();
        let buffer_ptr = self.chunk_transfer_buffer.as_mut_ptr();
        
        let mut buf_idx = 0usize;
        
        unsafe {
            for y in start_y..end_y {
                let row_offset = (y as usize) * grid_width;
                let src_start = row_offset + (start_x as usize);
                let row_len = (end_x - start_x) as usize;
                
                // Fast memcpy for each row
                std::ptr::copy_nonoverlapping(
                    colors_ptr.add(src_start),
                    buffer_ptr.add(buf_idx),
                    row_len
                );
                
                // Move to next row in 32x32 buffer
                buf_idx += CHUNK_SIZE as usize;
            }
        }
        
        self.chunk_transfer_buffer.as_ptr()
    }
    
    /// Get chunk transfer buffer size (32*32 = 1024 pixels * 4 bytes = 4096 bytes)
    pub fn chunk_buffer_byte_size(&self) -> usize {
        (CHUNK_SIZE * CHUNK_SIZE * 4) as usize
    }
    
    /// Get chunks X count (for JS coordinate calculation)
    pub fn chunks_x(&self) -> u32 {
        self.chunks.dimensions().0
    }
    
    /// Get chunks Y count
    pub fn chunks_y(&self) -> u32 {
        self.chunks.dimensions().1
    }
    
    // === PHASE 2: MERGED DIRTY RECTANGLES API ===
    
    /// Collect dirty chunks and merge into rectangles for GPU batching
    /// Returns number of merged rectangles
    /// 
    /// Call get_merged_rect_* functions to get each rectangle's properties
    pub fn collect_merged_rects(&mut self) -> usize {
        // Collect and merge horizontally
        let _count = self.chunks.collect_merged_dirty_rects(&mut self.merged_rects);
        
        // Also try to merge vertically
        self.chunks.merge_vertical(&mut self.merged_rects);
        
        // Clear visual dirty flags for collected chunks
        let total = self.chunks.total_chunks();
        for i in 0..total {
            if self.chunks.visual_dirty[i] {
                self.chunks.clear_visual_dirty(i);
            }
        }
        
        self.merged_rects.count()
    }
    
    /// DEBUG: Count dirty chunks WITHOUT clearing (for logging)
    pub fn count_dirty_chunks(&self) -> usize {
        let mut count = 0;
        for i in 0..self.chunks.total_chunks() {
            if self.chunks.visual_dirty[i] {
                count += 1;
            }
        }
        count
    }
    
    /// Get merged rect X (in pixels)
    pub fn get_merged_rect_x(&self, idx: usize) -> u32 {
        self.merged_rects.get(idx).map(|r| r.cx * CHUNK_SIZE).unwrap_or(0)
    }
    
    /// Get merged rect Y (in pixels)
    pub fn get_merged_rect_y(&self, idx: usize) -> u32 {
        self.merged_rects.get(idx).map(|r| r.cy * CHUNK_SIZE).unwrap_or(0)
    }
    
    /// Get merged rect Width (in pixels)
    pub fn get_merged_rect_w(&self, idx: usize) -> u32 {
        self.merged_rects.get(idx).map(|r| r.cw * CHUNK_SIZE).unwrap_or(0)
    }
    
    /// Get merged rect Height (in pixels)
    pub fn get_merged_rect_h(&self, idx: usize) -> u32 {
        self.merged_rects.get(idx).map(|r| r.ch * CHUNK_SIZE).unwrap_or(0)
    }
    
    /// Extract pixels for a merged rectangle into transfer buffer
    /// Returns pointer to the buffer
    /// 
    /// The buffer is laid out as row-major: width * height pixels
    pub fn extract_rect_pixels(&mut self, idx: usize) -> *const u32 {
        let rect = match self.merged_rects.get(idx) {
            Some(r) => r.clone(),
            None => return self.rect_transfer_buffer.as_ptr(),
        };
        
        let px = rect.cx * CHUNK_SIZE;
        let py = rect.cy * CHUNK_SIZE;
        let pw = rect.cw * CHUNK_SIZE;
        let ph = rect.ch * CHUNK_SIZE;
        
        // Clamp to world bounds
        let end_x = (px + pw).min(self.grid.width());
        let end_y = (py + ph).min(self.grid.height());
        let actual_w = end_x - px;
        let _actual_h = end_y - py;
        
        let grid_width = self.grid.width() as usize;
        let colors_ptr = self.grid.colors.as_ptr();
        let buffer_ptr = self.rect_transfer_buffer.as_mut_ptr();
        
        let mut buf_idx = 0usize;
        
        unsafe {
            for y in py..end_y {
                let row_offset = (y as usize) * grid_width;
                let src_start = row_offset + (px as usize);
                let row_len = actual_w as usize;
                
                std::ptr::copy_nonoverlapping(
                    colors_ptr.add(src_start),
                    buffer_ptr.add(buf_idx),
                    row_len
                );
                
                buf_idx += pw as usize; // Stride is full rect width
            }
        }
        
        self.rect_transfer_buffer.as_ptr()
    }
    
    /// Get the size of the rect transfer buffer in bytes
    pub fn rect_buffer_size(&self) -> usize {
        self.rect_transfer_buffer.len() * 4
    }
}

// Private simulation methods
impl World {
    /// Process a row of chunks
    fn process_chunk_row(&mut self, cy: u32, chunks_x: u32, go_right: bool, dt: f32) {
        if go_right {
            for cx in 0..chunks_x {
                self.process_chunk(cx, cy, go_right, dt);
            }
        } else {
            for cx in (0..chunks_x).rev() {
                self.process_chunk(cx, cy, go_right, dt);
            }
        }
    }
    
    /// Process a single chunk
    fn process_chunk(&mut self, cx: u32, cy: u32, go_right: bool, dt: f32) {
        // Skip sleeping chunks with no activity
        if !self.chunks.should_process(cx, cy) {
            return;
        }
        
        // Calculate pixel bounds for this chunk
        let start_x = cx * CHUNK_SIZE;
        let start_y = cy * CHUNK_SIZE;
        let end_x = (start_x + CHUNK_SIZE).min(self.grid.width());
        let end_y = (start_y + CHUNK_SIZE).min(self.grid.height());
        
        let mut had_movement = false;
        
        // Process rows within chunk (bottom to top for gravity)
        if self.gravity_y >= 0.0 {
            for y in (start_y..end_y).rev() {
                if go_right {
                    for x in start_x..end_x {
                        if self.update_particle_chunked(x, y, dt) {
                            had_movement = true;
                        }
                    }
                } else {
                    for x in (start_x..end_x).rev() {
                        if self.update_particle_chunked(x, y, dt) {
                            had_movement = true;
                        }
                    }
                }
            }
        } else {
            for y in start_y..end_y {
                if go_right {
                    for x in start_x..end_x {
                        if self.update_particle_chunked(x, y, dt) {
                            had_movement = true;
                        }
                    }
                } else {
                    for x in (start_x..end_x).rev() {
                        if self.update_particle_chunked(x, y, dt) {
                            had_movement = true;
                        }
                    }
                }
            }
        }
        
        // Update chunk state
        self.chunks.end_chunk_update(cx, cy, had_movement);
    }
    
    /// Update particle and return true if it moved
    /// PHASE 1: Optimized with unsafe access - coordinates are guaranteed valid by process_chunk bounds
    fn update_particle_chunked(&mut self, x: u32, y: u32, _dt: f32) -> bool {
        // SAFETY: x,y are bounded by process_chunk's min() calls
        unsafe {
            // Fast type read without bounds check
            let element = self.grid.get_type_unchecked(x, y);
            if element == EL_EMPTY { return false; }
            
            // Element ID bounds check (data could be corrupted)
            if (element as usize) >= ELEMENT_COUNT {
                self.grid.clear_cell_unchecked(x, y);
                return false;
            }
            
            let idx = self.grid.index_unchecked(x, y);
            
            // Fast updated check
            if self.grid.is_updated_unchecked(idx) { return false; }
            
            // Fast set updated
            self.grid.set_updated_unchecked(idx, true);
            
            // Handle lifetime with fast access
            let life = self.grid.get_life_unchecked(idx);
            if life > 0 {
                self.grid.set_life_unchecked(idx, life - 1);
                if life - 1 == 0 {
                    self.grid.clear_cell_unchecked(x, y);
                    self.chunks.remove_particle(x, y);
                    if self.particle_count > 0 {
                        self.particle_count -= 1;
                    }
                    return true; // Particle disappeared = activity
                }
            }
            
            // Get category and dispatch to behavior
            let category = ELEMENT_DATA[element as usize].category;
            
            // Remember position before update
            let old_type = element;
            
            // Create update context
            let mut ctx = UpdateContext {
                grid: &mut self.grid,
                chunks: &mut self.chunks,
                x,
                y,
                frame: self.frame,
                gravity_x: self.gravity_x,
                gravity_y: self.gravity_y,
                ambient_temp: self.ambient_temperature,
                rng: &mut self.rng_state,
            };
            
            // Delegate to behavior registry
            self.behaviors.update(category, &mut ctx);
            
            // Drop ctx to release borrows
            drop(ctx);
            
            // Check if particle moved (cell is now empty or different)
            let new_type = self.grid.get_type_unchecked(x, y);
            let moved = new_type != old_type || new_type == EL_EMPTY;
            
            if moved {
                // Wake neighbors if particle moved
                self.chunks.wake_neighbors(x, y);
            }
            
            // Process chemical reactions AFTER movement (EXACT TypeScript)
            let current_type = self.grid.get_type_unchecked(x, y);
            if current_type != EL_EMPTY {
                self.process_reactions(x, y, current_type);
            }
            
            moved
        }
    }
    
    // Legacy method for compatibility
    fn process_row(&mut self, y: u32, w: u32, go_right: bool, dt: f32) {
        if go_right {
            for x in 0..w {
                self.update_particle(x, y, dt);
            }
        } else {
            for x in (0..w).rev() {
                self.update_particle(x, y, dt);
            }
        }
    }

    fn update_particle(&mut self, x: u32, y: u32, _dt: f32) {
        let xi = x as i32;
        let yi = y as i32;
        
        let element = self.grid.get_type(xi, yi);
        if element == EL_EMPTY { return; }
        
        // Bounds check for element ID
        if (element as usize) >= ELEMENT_COUNT {
            self.grid.clear_cell(x, y);
            return;
        }
        
        if self.grid.is_updated(x, y) { return; }
        
        self.grid.set_updated(x, y, true);
        
        // Handle lifetime
        let life = self.grid.get_life(x, y);
        if life > 0 {
            self.grid.set_life(x, y, life - 1);
            if life - 1 == 0 {
                self.grid.clear_cell(x, y);
                if self.particle_count > 0 {
                    self.particle_count -= 1;
                }
                return;
            }
        }
        
        // Get category and dispatch to behavior
        let category = ELEMENT_DATA[element as usize].category;
        
        // Create update context
        let mut ctx = UpdateContext {
            grid: &mut self.grid,
            chunks: &mut self.chunks,
            x,
            y,
            frame: self.frame,
            gravity_x: self.gravity_x,
            gravity_y: self.gravity_y,
            ambient_temp: self.ambient_temperature,
            rng: &mut self.rng_state,
        };
        
        // Delegate to behavior registry
        self.behaviors.update(category, &mut ctx);
        
        // Process chemical reactions AFTER movement (EXACT TypeScript)
        let current_type = self.grid.get_type(x as i32, y as i32);
        if current_type != EL_EMPTY {
            self.process_reactions(x, y, current_type);
        }
    }
    
    /// Process chemical reactions (mirrors TypeScript processReactionsTyped)
    fn process_reactions(&mut self, x: u32, y: u32, element: ElementId) {
        // Pick a random neighbor
        // PHASE 1 OPT: & 3 instead of % 4 (saves ~40 CPU cycles)
        let dir = xorshift32(&mut self.rng_state) & 3;
        let xi = x as i32;
        let yi = y as i32;
        
        let (nx, ny) = match dir {
            0 => (xi, yi - 1),     // Up
            1 => (xi, yi + 1),     // Down
            2 => (xi - 1, yi),     // Left
            _ => (xi + 1, yi),     // Right
        };
        
        if !self.grid.in_bounds(nx, ny) { return; }
        
        let neighbor_type = self.grid.get_type(nx, ny);
        if neighbor_type == EL_EMPTY { return; }
        
        // Phase 1: O(1) reaction lookup from LUT
        if let Some(reaction) = self.reactions.get(element, neighbor_type) {
            // Roll the dice (chance is 0-255 in new system)
            let roll = (xorshift32(&mut self.rng_state) & 0xFF) as u8;
            if roll >= reaction.chance { return; }
            
            // Copy reaction to release the borrow before apply
            let r = *reaction;
            self.apply_reaction(x, y, nx as u32, ny as u32, &r);
        }
    }
    
    /// Apply a bilateral reaction (mirrors TypeScript applyReaction)
    fn apply_reaction(&mut self, src_x: u32, src_y: u32, target_x: u32, target_y: u32, reaction: &Reaction) {
        // A. Transform the TARGET (victim)
        if reaction.target_becomes == EL_EMPTY {
            self.remove_particle(target_x, target_y);
        } else {
            self.replace_particle(target_x, target_y, reaction.target_becomes);
        }
        
        // B. Transform the SOURCE (aggressor) - BILATERAL!
        if reaction.source_becomes != Reaction::NO_CHANGE {
            if reaction.source_becomes == EL_EMPTY {
                self.remove_particle(src_x, src_y);
            } else {
                self.replace_particle(src_x, src_y, reaction.source_becomes);
            }
        }
        
        // C. Spawn byproduct (smoke, steam)
        if reaction.spawn != EL_EMPTY {
            let sxi = src_x as i32;
            let syi = src_y as i32;
            let txi = target_x as i32;
            let tyi = target_y as i32;
            
            // Try to spawn above the reaction site
            if self.grid.is_empty(sxi, syi - 1) {
                self.add_particle(src_x, (syi - 1) as u32, reaction.spawn);
            } else if self.grid.is_empty(txi, tyi - 1) {
                self.add_particle(target_x, (tyi - 1) as u32, reaction.spawn);
            }
        }
    }
    
    /// Replace a particle with a new element type
    /// PRESERVES temperature like TypeScript! Hot stone from lava stays hot
    fn replace_particle(&mut self, x: u32, y: u32, element: ElementId) {
        let seed = ((x * 7 + y * 13 + self.frame as u32) & 31) as u8;
        let props = &ELEMENT_DATA[element as usize];
        
        // Save current temperature BEFORE replacing
        let current_temp = self.grid.get_temp(x as i32, y as i32);
        
        self.grid.set_particle(
            x, y,
            element,
            get_color_with_variation(element, seed),
            props.lifetime,
            current_temp  // Keep temperature! (was: props.default_temp)
        );
        
        // Mark as updated
        self.grid.set_updated(x, y, true);
        
        // CRITICAL: Mark chunk as dirty for rendering!
        // Without this, reactions don't trigger re-render!
        self.chunks.mark_dirty(x, y);
    }
}

--- End of File: packages/engine/src/world.rs ---


--- File: packages/engine-wasm/package.json ---

{
  "name": "particula-engine",
  "type": "module",
  "collaborators": [
    "Particula Team"
  ],
  "description": "Physics engine for Particula sandbox simulation",
  "version": "0.1.0",
  "files": [
    "particula_engine_bg.wasm",
    "particula_engine.js",
    "particula_engine.d.ts"
  ],
  "main": "particula_engine.js",
  "types": "particula_engine.d.ts",
  "sideEffects": [
    "./snippets/*"
  ]
}

--- End of File: packages/engine-wasm/package.json ---


--- File: turbo.json ---

{
  "$schema": "https://turbo.build/schema.json",
  "globalDependencies": ["**/.env.*local"],
  "tasks": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**", ".next/**", "!.next/cache/**"]
    },
    "dev": {
      "cache": false,
      "persistent": true
    },
    "lint": {
      "dependsOn": ["^build"]
    },
    "clean": {
      "cache": false
    }
  }
}

--- End of File: turbo.json ---
