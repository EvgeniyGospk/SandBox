--- File: apps/web/src/App.tsx ---

import { useEffect, useState } from 'react'
import { Canvas } from '@/components/Canvas'
import { LeftPanel } from '@/components/panels/LeftPanel'
import { TopToolbar } from '@/components/panels/TopToolbar'
import { BottomBar } from '@/components/panels/BottomBar'
import { RightPanel } from '@/components/panels/RightPanel'

function App() {
  const [isEngineReady, setIsEngineReady] = useState(false)

  useEffect(() => {
    // TODO: Initialize WASM engine here
    // For now, just mark as ready
    setIsEngineReady(true)
  }, [])

  if (!isEngineReady) {
    return (
      <div className="flex items-center justify-center h-screen bg-[#0D0D0D]">
        <div className="text-white text-xl">Loading Particula...</div>
      </div>
    )
  }

  return (
    <div className="flex flex-col h-screen bg-[#0D0D0D] text-white overflow-hidden">
      {/* Top Toolbar */}
      <TopToolbar />

      {/* Main Content */}
      <div className="flex flex-1 overflow-hidden">
        {/* Left Panel - Elements */}
        <LeftPanel />

        {/* Canvas - Center */}
        <main className="flex-1 relative">
          <Canvas />
        </main>

        {/* Right Panel - Settings */}
        <RightPanel />
      </div>

      {/* Bottom Bar */}
      <BottomBar />
    </div>
  )
}

export default App

--- End of File: apps/web/src/App.tsx ---


--- File: apps/web/src/components/Canvas.tsx ---

import { useRef, useEffect, useCallback, useState } from 'react'
import { useSimulationStore } from '@/stores/simulationStore'
import { useToolStore } from '@/stores/toolStore'
import { WasmParticleEngine } from '@/lib/engine'
import { FpsCounter } from '@/lib/FpsCounter'

// Global engine instance for external access (reset, etc.)
let globalEngine: WasmParticleEngine | null = null
export function getEngine(): WasmParticleEngine | null { return globalEngine }

// Camera reset callback (set by Canvas component)
let resetCameraCallback: (() => void) | null = null
export function resetCamera(): void { resetCameraCallback?.() }

export function Canvas() {
  const canvasRef = useRef<HTMLCanvasElement>(null)
  const containerRef = useRef<HTMLDivElement>(null)
  const engineRef = useRef<WasmParticleEngine | null>(null)
  const ctxRef = useRef<CanvasRenderingContext2D | null>(null)
  const isDrawing = useRef(false)
  const isDragging = useRef(false)
  const lastPos = useRef<{ x: number; y: number } | null>(null)
  const lastMousePos = useRef({ x: 0, y: 0 })
  const animationRef = useRef<number>(0)
  const lastTimeRef = useRef<number>(0)
  // Phase 4: Zero-allocation FPS counter
  const fpsCounter = useRef(new FpsCounter(20))
  
  // Loading state
  const [isLoading, setIsLoading] = useState(true)
  
  // Camera state (refs to avoid re-renders)
  const cameraRef = useRef({ x: 0, y: 0, zoom: 1 })
  
  const { isPlaying, speed, gravity, ambientTemperature, setFps, setParticleCount } = useSimulationStore()
  const { selectedElement, brushSize, selectedTool } = useToolStore()

  // Use refs for values accessed in render loop to avoid recreating the loop
  const isPlayingRef = useRef(isPlaying)
  const speedRef = useRef(speed)
  isPlayingRef.current = isPlaying
  speedRef.current = speed

  // Register camera reset callback
  useEffect(() => {
    resetCameraCallback = () => {
      cameraRef.current = { x: 0, y: 0, zoom: 1 }
      engineRef.current?.setTransform(1, 0, 0)
    }
    return () => { resetCameraCallback = null }
  }, [])

  // Sync physics settings with engine
  useEffect(() => {
    const engine = engineRef.current
    if (engine) {
      engine.setSettings({ gravity, ambientTemperature })
    }
  }, [gravity, ambientTemperature])

  // Initialize engine and start render loop
  useEffect(() => {
    const canvas = canvasRef.current
    const container = containerRef.current
    if (!canvas || !container) return

    const ctx = canvas.getContext('2d', { alpha: false })
    if (!ctx) return
    ctxRef.current = ctx

    const { width, height } = container.getBoundingClientRect()
    if (width <= 0 || height <= 0) return
    
    canvas.width = width
    canvas.height = height
    
    // Throttle state updates
    let lastStatsUpdate = 0
    const STATS_UPDATE_INTERVAL = 200

    // Render loop
    const startRenderLoop = () => {
      const render = (time: number) => {
        const eng = engineRef.current
        if (!eng) return

        // Calculate smoothed FPS (Phase 4: Zero-allocation)
        const delta = time - lastTimeRef.current
        if (delta > 0) {
          fpsCounter.current.add(1000 / delta)
        }
        lastTimeRef.current = time

        // Step simulation
        if (isPlayingRef.current) {
          const steps = speedRef.current >= 1 ? Math.floor(speedRef.current) : 1
          for (let i = 0; i < steps; i++) {
            eng.step()
          }
        }

        // Render using Smart Rendering (Phase 3: Dirty Rectangles)
        const renderer = eng.getRenderer()
        const memory = eng.memory
        if (renderer && memory) {
          renderer.renderSmart(eng, memory)
        } else {
          // Fallback to full render
          eng.render()
        }

        // Throttle React state updates
        if (time - lastStatsUpdate > STATS_UPDATE_INTERVAL) {
          const avgFps = fpsCounter.current.getAverage() // Zero allocations!
          setFps(avgFps)
          setParticleCount(eng.particleCount)
          lastStatsUpdate = time
        }

        animationRef.current = requestAnimationFrame(render)
      }
      
      animationRef.current = requestAnimationFrame(render)
    }
    
    // Initialize WASM engine
    const initEngine = async () => {
      try {
        console.log('ðŸ¦€ Loading WASM engine...')
        const engine = await WasmParticleEngine.create(width, height)
        engine.attachRenderer(ctx)
        
        engineRef.current = engine
        globalEngine = engine
        setIsLoading(false)
        console.log('ðŸ¦€ WasmParticleEngine ready!')
        
        // Start render loop
        startRenderLoop()
      } catch (err) {
        console.error('Failed to load WASM engine:', err)
        setIsLoading(false)
      }
    }
    
    initEngine()

    return () => {
      cancelAnimationFrame(animationRef.current)
      if (engineRef.current) {
        engineRef.current.destroy()
      }
      globalEngine = null
    }
  }, [setFps, setParticleCount])

  // Handle resize
  useEffect(() => {
    const handleResize = () => {
      const canvas = canvasRef.current
      const container = containerRef.current
      if (!canvas || !container) return

      const { width, height } = container.getBoundingClientRect()
      canvas.width = width
      canvas.height = height

      if (engineRef.current) {
        engineRef.current.resize(width, height)
      }
    }

    window.addEventListener('resize', handleResize)
    return () => window.removeEventListener('resize', handleResize)
  }, [])

  // Get canvas position (screen coordinates)
  const getCanvasPosition = useCallback((e: React.MouseEvent) => {
    const canvas = canvasRef.current
    if (!canvas) return { x: 0, y: 0 }
    
    const rect = canvas.getBoundingClientRect()
    return {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    }
  }, [])

  // Screen -> World coordinate conversion
  const screenToWorld = useCallback((sx: number, sy: number) => {
    const cam = cameraRef.current
    return {
      x: Math.floor((sx - cam.x) / cam.zoom),
      y: Math.floor((sy - cam.y) / cam.zoom)
    }
  }, [])

  // Zoom handler (mouse wheel)
  const handleWheel = useCallback((e: React.WheelEvent) => {
    const eng = engineRef.current
    if (!eng) return
    e.preventDefault()

    const delta = e.deltaY > 0 ? 0.9 : 1.1
    const cam = cameraRef.current
    const newZoom = Math.min(Math.max(cam.zoom * delta, 1), 10) // Min 1x, Max 10x

    // Zoom toward cursor position
    const rect = canvasRef.current!.getBoundingClientRect()
    const mouseX = e.clientX - rect.left
    const mouseY = e.clientY - rect.top

    // Adjust pan so point under cursor stays fixed
    const scale = newZoom / cam.zoom
    cam.x = mouseX - (mouseX - cam.x) * scale
    cam.y = mouseY - (mouseY - cam.y) * scale
    cam.zoom = newZoom

    eng.setTransform(cam.zoom, cam.x, cam.y)
  }, [])

  // Draw particles
  const draw = useCallback((x: number, y: number) => {
    const engine = engineRef.current
    if (!engine) return

    const radius = Math.floor(brushSize / 2)

    if (selectedTool === 'eraser') {
      engine.removeParticlesInRadius(x, y, radius)
    } else if (selectedTool === 'brush') {
      engine.addParticlesInRadius(x, y, radius, selectedElement)
    }
  }, [brushSize, selectedElement, selectedTool])

  // Mouse handlers
  const handleMouseDown = useCallback((e: React.MouseEvent) => {
    const pos = getCanvasPosition(e)
    lastMousePos.current = { x: e.clientX, y: e.clientY }

    // Middle mouse button (1) or move tool -> pan
    if (selectedTool === 'move' || e.button === 1) {
      isDragging.current = true
      e.preventDefault()
      return
    }

    // Drawing
    isDrawing.current = true
    const worldPos = screenToWorld(pos.x, pos.y)
    lastPos.current = worldPos
    draw(worldPos.x, worldPos.y)
  }, [getCanvasPosition, screenToWorld, draw, selectedTool])

  const handleMouseMove = useCallback((e: React.MouseEvent) => {
    const pos = getCanvasPosition(e)

    // Pan mode
    if (isDragging.current) {
      const dx = e.clientX - lastMousePos.current.x
      const dy = e.clientY - lastMousePos.current.y
      
      const cam = cameraRef.current
      cam.x += dx
      cam.y += dy
      
      if (engineRef.current) {
        engineRef.current.setTransform(cam.zoom, cam.x, cam.y)
      }
      
      lastMousePos.current = { x: e.clientX, y: e.clientY }
      return
    }

    // Drawing mode
    if (!isDrawing.current) return
    
    const worldPos = screenToWorld(pos.x, pos.y)
    
    // Interpolate between last position and current (in world space)
    if (lastPos.current) {
      const dx = worldPos.x - lastPos.current.x
      const dy = worldPos.y - lastPos.current.y
      const dist = Math.sqrt(dx * dx + dy * dy)
      const steps = Math.max(1, Math.floor(dist))
      
      for (let i = 0; i <= steps; i++) {
        const t = i / steps
        const x = Math.floor(lastPos.current.x + dx * t)
        const y = Math.floor(lastPos.current.y + dy * t)
        draw(x, y)
      }
    }
    
    lastPos.current = worldPos
  }, [getCanvasPosition, screenToWorld, draw])

  const handleMouseUp = useCallback(() => {
    isDrawing.current = false
    isDragging.current = false
    lastPos.current = null
  }, [])

  const handleMouseLeave = useCallback(() => {
    isDrawing.current = false
    isDragging.current = false
    lastPos.current = null
  }, [])

  // Get cursor class
  const getCursorClass = () => {
    switch (selectedTool) {
      case 'eraser': return 'cursor-cell'
      case 'pipette': return 'cursor-copy'
      case 'move': return 'cursor-grab'
      default: return 'cursor-crosshair'
    }
  }

  return (
    <div 
      ref={containerRef} 
      className="w-full h-full bg-[#0a0a0a] overflow-hidden relative"
    >
      {/* Loading overlay */}
      {isLoading && (
        <div className="absolute inset-0 flex items-center justify-center bg-[#0a0a0a] z-10">
          <div className="text-white text-lg">ðŸ¦€ Loading WASM engine...</div>
        </div>
      )}
      
      <canvas
        ref={canvasRef}
        className={`w-full h-full ${getCursorClass()}`}
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseLeave}
        onWheel={handleWheel}
        onContextMenu={(e) => e.preventDefault()}
      />
    </div>
  )
}

--- End of File: apps/web/src/components/Canvas.tsx ---


--- File: apps/web/src/components/panels/BottomBar.tsx ---

import { useSimulationStore } from '@/stores/simulationStore'
import { Play, Pause, SkipForward, RotateCcw } from 'lucide-react'

export function BottomBar() {
  const {
    isPlaying,
    speed,
    fps,
    particleCount,
    play,
    pause,
    step,
    reset,
    setSpeed
  } = useSimulationStore()

  const speedOptions = [0.5, 1, 2, 4] as const

  return (
    <footer className="h-12 bg-[#1A1A1A] border-t border-[#333] flex items-center px-4 gap-4">
      {/* Playback Controls */}
      <div className="flex items-center gap-1">
        <button
          onClick={isPlaying ? pause : play}
          className="p-2 rounded-lg hover:bg-[#252525] transition-colors"
          title={isPlaying ? 'Pause' : 'Play'}
        >
          {isPlaying ? <Pause size={18} /> : <Play size={18} />}
        </button>
        <button
          onClick={step}
          disabled={isPlaying}
          className="p-2 rounded-lg hover:bg-[#252525] transition-colors disabled:opacity-50"
          title="Step"
        >
          <SkipForward size={18} />
        </button>
        <button
          onClick={reset}
          className="p-2 rounded-lg hover:bg-[#252525] transition-colors text-[#EF4444]"
          title="Reset"
        >
          <RotateCcw size={18} />
        </button>
      </div>

      {/* Divider */}
      <div className="w-px h-6 bg-[#333]" />

      {/* Speed Control */}
      <div className="flex items-center gap-2">
        <span className="text-sm text-[#A0A0A0]">Speed:</span>
        <div className="flex gap-0.5">
          {speedOptions.map((s) => (
            <button
              key={s}
              onClick={() => setSpeed(s)}
              className={`px-3 py-1 text-sm rounded-lg transition-colors ${
                speed === s
                  ? 'bg-[#3B82F6] text-white'
                  : 'bg-[#252525] text-[#A0A0A0] hover:text-white'
              }`}
            >
              {s}x
            </button>
          ))}
        </div>
      </div>

      {/* Spacer */}
      <div className="flex-1" />

      {/* Stats */}
      <div className="flex items-center gap-6 text-sm">
        <div className="flex items-center gap-1.5">
          <span 
            className={`w-2.5 h-2.5 rounded-full ${
              fps >= 50 ? 'bg-[#22C55E]' : fps >= 30 ? 'bg-[#F59E0B]' : 'bg-[#EF4444]'
            }`} 
          />
          <span className="text-[#A0A0A0]">FPS:</span>
          <span className="font-mono w-6">{fps}</span>
        </div>
        <div className="flex items-center gap-1.5">
          <span className="text-[#A0A0A0]">Particles:</span>
          <span className="font-mono">{formatNumber(particleCount)}</span>
        </div>
      </div>
    </footer>
  )
}

function formatNumber(num: number): string {
  if (num >= 1_000_000) return `${(num / 1_000_000).toFixed(1)}M`
  if (num >= 1_000) return `${(num / 1_000).toFixed(1)}K`
  return num.toString()
}

--- End of File: apps/web/src/components/panels/BottomBar.tsx ---


--- File: apps/web/src/components/panels/LeftPanel.tsx ---

import { useState } from 'react'
import { useToolStore } from '@/stores/toolStore'
import { ELEMENTS, ELEMENT_CATEGORIES } from '@/lib/elements'
import { ChevronLeft, ChevronRight } from 'lucide-react'

export function LeftPanel() {
  const [isCollapsed, setIsCollapsed] = useState(false)
  const [activeCategory, setActiveCategory] = useState<string>('solids')
  const { selectedElement, setElement } = useToolStore()

  const categories = Object.entries(ELEMENT_CATEGORIES)
  const elementsInCategory = ELEMENTS.filter(el => el.category === activeCategory)

  if (isCollapsed) {
    return (
      <div className="w-14 bg-[#1A1A1A] border-r border-[#333] flex flex-col items-center py-4">
        <button
          onClick={() => setIsCollapsed(false)}
          className="p-2.5 hover:bg-[#252525] rounded-lg transition-colors"
          title="Expand panel"
        >
          <ChevronRight size={18} />
        </button>
      </div>
    )
  }

  return (
    <aside className="w-64 bg-[#1A1A1A] border-r border-[#333] flex flex-col">
      {/* Header */}
      <div className="flex items-center justify-between px-5 py-4 border-b border-[#333]">
        <span className="text-lg font-semibold">Elements</span>
        <button
          onClick={() => setIsCollapsed(true)}
          className="p-2 hover:bg-[#252525] rounded-lg transition-colors"
          title="Collapse panel"
        >
          <ChevronLeft size={16} />
        </button>
      </div>

      {/* Category Tabs */}
      <div className="px-4 py-3 border-b border-[#333]">
        <div className="flex gap-2 overflow-x-auto scrollbar-hide">
          {categories.map(([key, label]) => (
            <button
              key={key}
              onClick={() => setActiveCategory(key)}
              className={`px-4 py-2 text-sm font-medium rounded-lg whitespace-nowrap transition-all ${
                activeCategory === key
                  ? 'bg-[#3B82F6] text-white shadow-lg shadow-blue-500/20'
                  : 'bg-[#252525] text-[#808080] hover:text-white hover:bg-[#2a2a2a]'
              }`}
            >
              {label}
            </button>
          ))}
        </div>
      </div>

      {/* Elements Grid */}
      <div className="flex-1 overflow-y-auto p-3">
        <div className="grid grid-cols-3 gap-2">
          {elementsInCategory.map((element) => (
            <ElementButton
              key={element.id}
              element={element}
              isSelected={selectedElement === element.id}
              onClick={() => setElement(element.id)}
            />
          ))}
        </div>
      </div>
    </aside>
  )
}

interface ElementButtonProps {
  element: typeof ELEMENTS[0]
  isSelected: boolean
  onClick: () => void
}

function ElementButton({ element, isSelected, onClick }: ElementButtonProps) {
  return (
    <button
      onClick={onClick}
      className={`
        aspect-square
        flex flex-col items-center justify-center 
        p-2 rounded-lg 
        transition-all duration-200 
        ${isSelected
          ? 'bg-[#252525] ring-2 ring-[#3B82F6] shadow-lg shadow-blue-500/20'
          : 'bg-[#1f1f1f] hover:bg-[#252525]'
        }
      `}
      title={`${element.name}: ${element.description}`}
    >
      {/* Element Color Box */}
      <div
        className="w-10 h-10 rounded-lg shadow-md flex-shrink-0"
        style={{
          background: `linear-gradient(145deg, ${element.color}, ${adjustColor(element.color, -30)})`,
          boxShadow: isSelected 
            ? `0 0 12px ${element.color}50, inset 0 1px 0 ${adjustColor(element.color, 50)}40` 
            : `inset 0 1px 0 ${adjustColor(element.color, 50)}30`,
        }}
      />
      
      {/* Element Name */}
      <span className={`
        text-xs mt-1.5 font-medium text-center w-full truncate
        ${isSelected ? 'text-white' : 'text-[#707070]'}
      `}>
        {element.name}
      </span>
    </button>
  )
}

// Helper to darken/lighten color
function adjustColor(hex: string, amount: number): string {
  const num = parseInt(hex.replace('#', ''), 16)
  const r = Math.min(255, Math.max(0, (num >> 16) + amount))
  const g = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + amount))
  const b = Math.min(255, Math.max(0, (num & 0x0000FF) + amount))
  return `#${((r << 16) | (g << 8) | b).toString(16).padStart(6, '0')}`
}

--- End of File: apps/web/src/components/panels/LeftPanel.tsx ---


--- File: apps/web/src/components/panels/RightPanel.tsx ---

import { useState } from 'react'
import { useSimulationStore } from '@/stores/simulationStore'
import { ChevronLeft, ChevronRight } from 'lucide-react'

export function RightPanel() {
  const [isCollapsed, setIsCollapsed] = useState(false)
  const { gravity, ambientTemperature, setGravity, setAmbientTemperature } = useSimulationStore()

  if (isCollapsed) {
    return (
      <div className="w-12 bg-[#1A1A1A] border-l border-[#333] flex flex-col items-center py-3">
        <button
          onClick={() => setIsCollapsed(false)}
          className="p-2 hover:bg-[#252525] rounded transition-colors"
        >
          <ChevronLeft size={16} />
        </button>
      </div>
    )
  }

  return (
    <aside className="w-64 bg-[#1A1A1A] border-l border-[#333] flex flex-col">
      {/* Header */}
      <div className="flex items-center justify-between px-4 py-3 border-b border-[#333]">
        <span className="text-base font-semibold">Settings</span>
        <button
          onClick={() => setIsCollapsed(true)}
          className="p-1.5 hover:bg-[#252525] rounded transition-colors"
        >
          <ChevronRight size={14} />
        </button>
      </div>

      {/* Settings */}
      <div className="flex-1 overflow-y-auto p-4 space-y-5">
        {/* Gravity */}
        <div className="space-y-2">
          <label className="text-sm text-[#A0A0A0] font-medium">Gravity</label>
          
          <div className="space-y-1">
            <div className="flex items-center gap-2">
              <span className="text-sm text-[#A0A0A0] w-5">X:</span>
              <input
                type="range"
                min={-20}
                max={20}
                step={0.1}
                value={gravity.x}
                onChange={(e) => setGravity({ ...gravity, x: Number(e.target.value) })}
                className="flex-1 h-1.5 bg-[#333] rounded-full appearance-none cursor-pointer
                           [&::-webkit-slider-thumb]:appearance-none
                           [&::-webkit-slider-thumb]:w-4
                           [&::-webkit-slider-thumb]:h-4
                           [&::-webkit-slider-thumb]:bg-[#3B82F6]
                           [&::-webkit-slider-thumb]:rounded-full"
              />
              <span className="text-xs font-mono w-10 text-right">{gravity.x.toFixed(1)}</span>
            </div>
            <div className="flex items-center gap-2">
              <span className="text-sm text-[#A0A0A0] w-5">Y:</span>
              <input
                type="range"
                min={-20}
                max={20}
                step={0.1}
                value={gravity.y}
                onChange={(e) => setGravity({ ...gravity, y: Number(e.target.value) })}
                className="flex-1 h-1.5 bg-[#333] rounded-full appearance-none cursor-pointer
                           [&::-webkit-slider-thumb]:appearance-none
                           [&::-webkit-slider-thumb]:w-4
                           [&::-webkit-slider-thumb]:h-4
                           [&::-webkit-slider-thumb]:bg-[#3B82F6]
                           [&::-webkit-slider-thumb]:rounded-full"
              />
              <span className="text-xs font-mono w-10 text-right">{gravity.y.toFixed(1)}</span>
            </div>
          </div>
          
          {/* Gravity Presets */}
          <div className="flex gap-1">
            <PresetButton 
              label="Earth" 
              onClick={() => setGravity({ x: 0, y: 9.8 })} 
            />
            <PresetButton 
              label="Moon" 
              onClick={() => setGravity({ x: 0, y: 1.6 })} 
            />
            <PresetButton 
              label="None" 
              onClick={() => setGravity({ x: 0, y: 0 })} 
            />
          </div>
        </div>

        {/* Divider */}
        <div className="h-px bg-[#333]" />

        {/* Ambient Temperature */}
        <div className="space-y-2">
          <label className="text-sm text-[#A0A0A0] font-medium">
            Ambient Temperature
          </label>
          <div className="flex items-center gap-2">
            <input
              type="range"
              min={-50}
              max={100}
              value={ambientTemperature}
              onChange={(e) => setAmbientTemperature(Number(e.target.value))}
              className="flex-1 h-1.5 bg-[#333] rounded-full appearance-none cursor-pointer
                         [&::-webkit-slider-thumb]:appearance-none
                         [&::-webkit-slider-thumb]:w-4
                         [&::-webkit-slider-thumb]:h-4
                         [&::-webkit-slider-thumb]:bg-[#3B82F6]
                         [&::-webkit-slider-thumb]:rounded-full"
            />
            <span className="text-xs font-mono w-12 text-right">{ambientTemperature}Â°C</span>
          </div>
          
          {/* Temperature Presets */}
          <div className="flex gap-1">
            <PresetButton 
              label="Cold" 
              onClick={() => setAmbientTemperature(-20)} 
            />
            <PresetButton 
              label="Normal" 
              onClick={() => setAmbientTemperature(20)} 
            />
            <PresetButton 
              label="Hot" 
              onClick={() => setAmbientTemperature(50)} 
            />
          </div>
        </div>
      </div>
    </aside>
  )
}

interface PresetButtonProps {
  label: string
  onClick: () => void
}

function PresetButton({ label, onClick }: PresetButtonProps) {
  return (
    <button
      onClick={onClick}
      className="flex-1 px-2 py-1.5 text-xs bg-[#252525] rounded-lg
                 text-[#A0A0A0] hover:text-white transition-colors"
    >
      {label}
    </button>
  )
}

--- End of File: apps/web/src/components/panels/RightPanel.tsx ---


--- File: apps/web/src/components/panels/TopToolbar.tsx ---

import { useToolStore } from '@/stores/toolStore'
import { useSimulationStore } from '@/stores/simulationStore'
import { resetCamera } from '@/components/Canvas'
import { 
  Circle, 
  Square, 
  Minus, 
  Eraser, 
  Pipette, 
  PaintBucket,
  Hand,
  Focus,
  Undo,
  Redo,
  Save,
  FolderOpen,
  Thermometer
} from 'lucide-react'

export function TopToolbar() {
  const { 
    selectedTool, 
    brushShape, 
    brushSize, 
    setTool, 
    setBrushShape, 
    setBrushSize 
  } = useToolStore()
  
  const { renderMode, toggleRenderMode } = useSimulationStore()

  return (
    <header className="h-14 bg-[#1A1A1A] border-b border-[#333] flex items-center px-4 gap-4">
      {/* Logo */}
      <div className="flex items-center gap-2 mr-4">
        <div className="w-7 h-7 bg-gradient-to-br from-[#3B82F6] to-purple-500 rounded" />
        <span className="font-semibold text-base">Particula</span>
      </div>

      {/* Divider */}
      <div className="w-px h-6 bg-[#333]" />

      {/* Brush Shapes */}
      <div className="flex items-center gap-1">
        <ToolButton
          icon={<Circle size={16} />}
          isActive={brushShape === 'circle'}
          onClick={() => setBrushShape('circle')}
          tooltip="Circle Brush"
        />
        <ToolButton
          icon={<Square size={16} />}
          isActive={brushShape === 'square'}
          onClick={() => setBrushShape('square')}
          tooltip="Square Brush"
        />
        <ToolButton
          icon={<Minus size={16} />}
          isActive={brushShape === 'line'}
          onClick={() => setBrushShape('line')}
          tooltip="Line Tool"
        />
      </div>

      {/* Divider */}
      <div className="w-px h-6 bg-[#333]" />

      {/* Brush Size */}
      <div className="flex items-center gap-2">
        <span className="text-sm text-[#A0A0A0]">Size:</span>
        <input
          type="range"
          min={1}
          max={50}
          value={brushSize}
          onChange={(e) => setBrushSize(Number(e.target.value))}
          className="w-28 h-1.5 bg-[#333] rounded-full appearance-none cursor-pointer
                     [&::-webkit-slider-thumb]:appearance-none
                     [&::-webkit-slider-thumb]:w-4
                     [&::-webkit-slider-thumb]:h-4
                     [&::-webkit-slider-thumb]:bg-[#3B82F6]
                     [&::-webkit-slider-thumb]:rounded-full
                     [&::-webkit-slider-thumb]:cursor-pointer"
        />
        <span className="text-sm text-[#A0A0A0] w-8 font-mono">{brushSize}</span>
      </div>

      {/* Divider */}
      <div className="w-px h-6 bg-[#333]" />

      {/* Tools */}
      <div className="flex items-center gap-1">
        <ToolButton
          icon={<Eraser size={16} />}
          isActive={selectedTool === 'eraser'}
          onClick={() => setTool('eraser')}
          tooltip="Eraser"
        />
        <ToolButton
          icon={<Hand size={16} />}
          isActive={selectedTool === 'move'}
          onClick={() => setTool('move')}
          tooltip="Move / Pan (Middle Mouse)"
        />
        <ToolButton
          icon={<Pipette size={16} />}
          isActive={selectedTool === 'pipette'}
          onClick={() => setTool('pipette')}
          tooltip="Pipette"
        />
        <ToolButton
          icon={<PaintBucket size={16} />}
          isActive={selectedTool === 'fill'}
          onClick={() => setTool('fill')}
          tooltip="Fill"
        />
      </div>

      {/* Divider */}
      <div className="w-px h-6 bg-[#333]" />

      {/* View Controls */}
      <div className="flex items-center gap-1">
        <ToolButton
          icon={<Thermometer size={16} />}
          isActive={renderMode === 'thermal'}
          onClick={toggleRenderMode}
          tooltip={renderMode === 'thermal' ? 'Normal View' : 'Thermal Vision'}
        />
        <ToolButton
          icon={<Focus size={16} />}
          onClick={resetCamera}
          tooltip="Reset View (1:1)"
        />
      </div>

      {/* Spacer */}
      <div className="flex-1" />

      {/* Actions */}
      <div className="flex items-center gap-1">
        <ToolButton
          icon={<Undo size={16} />}
          onClick={() => console.log('Undo')}
          tooltip="Undo"
        />
        <ToolButton
          icon={<Redo size={16} />}
          onClick={() => console.log('Redo')}
          tooltip="Redo"
        />
        <div className="w-px h-6 bg-border mx-1" />
        <ToolButton
          icon={<Save size={16} />}
          onClick={() => console.log('Save')}
          tooltip="Save"
        />
        <ToolButton
          icon={<FolderOpen size={16} />}
          onClick={() => console.log('Load')}
          tooltip="Load"
        />
      </div>
    </header>
  )
}

interface ToolButtonProps {
  icon: React.ReactNode
  isActive?: boolean
  onClick: () => void
  tooltip: string
}

function ToolButton({ icon, isActive, onClick, tooltip }: ToolButtonProps) {
  return (
    <button
      onClick={onClick}
      title={tooltip}
      className={`p-2.5 rounded-lg transition-colors ${
        isActive
          ? 'bg-[#3B82F6] text-white'
          : 'hover:bg-[#252525] text-[#A0A0A0] hover:text-white'
      }`}
    >
      {icon}
    </button>
  )
}

--- End of File: apps/web/src/components/panels/TopToolbar.tsx ---


--- File: apps/web/src/lib/FpsCounter.ts ---

/**
 * Zero-allocation FPS counter using Ring Buffer
 * 
 * Phase 4: Eliminates Array.push/shift allocations that cause GC stuttering
 * Uses Float32Array as fixed-size ring buffer
 */

export class FpsCounter {
  private buffer: Float32Array
  private index: number = 0
  private size: number
  private count: number = 0 // How many slots are actually filled

  constructor(size: number = 20) {
    this.size = size
    this.buffer = new Float32Array(size) // Single allocation at startup
  }

  /**
   * Add FPS sample - zero allocations!
   */
  add(fps: number): void {
    this.buffer[this.index] = fps
    this.index = (this.index + 1) % this.size
    if (this.count < this.size) this.count++
  }

  /**
   * Get smoothed average FPS - zero allocations!
   */
  getAverage(): number {
    if (this.count === 0) return 0
    
    let sum = 0
    for (let i = 0; i < this.count; i++) {
      sum += this.buffer[i]
    }
    return Math.round(sum / this.count)
  }

  /**
   * Reset counter
   */
  reset(): void {
    this.count = 0
    this.index = 0
  }
}

--- End of File: apps/web/src/lib/FpsCounter.ts ---


--- File: apps/web/src/lib/elements.ts ---

/**
 * UI-facing element definitions for LeftPanel
 */

import type { ElementType } from './engine'

export type { ElementType }

export interface Element {
  id: ElementType
  name: string
  category: string
  color: string
  description: string
}

export const ELEMENT_CATEGORIES: Record<string, string> = {
  solids: 'Solids',
  liquids: 'Liquids',
  gases: 'Gases',
  energy: 'Energy',
  utility: 'Utility',
  bio: 'Nature',
}

export const ELEMENTS: Element[] = [
  // Solids
  {
    id: 'stone',
    name: 'Stone',
    category: 'solids',
    color: '#808080',
    description: 'Heavy solid, melts at high temperature',
  },
  {
    id: 'sand',
    name: 'Sand',
    category: 'solids',
    color: '#C2B280',
    description: 'Falls and piles up, melts into glass',
  },
  {
    id: 'wood',
    name: 'Wood',
    category: 'solids',
    color: '#8B4513',
    description: 'Flammable solid',
  },
  {
    id: 'metal',
    name: 'Metal',
    category: 'solids',
    color: '#A9A9A9',
    description: 'Conducts heat and electricity',
  },
  {
    id: 'ice',
    name: 'Ice',
    category: 'solids',
    color: '#A5F2F3',
    description: 'Melts from fire/lava, floats on water',
  },
  {
    id: 'gunpowder',
    name: 'Gunpowder',
    category: 'solids',
    color: '#404040',
    description: 'Explosive! Ignites instantly from fire',
  },
  
  // Liquids
  {
    id: 'water',
    name: 'Water',
    category: 'liquids',
    color: '#4169E1',
    description: 'Flows, evaporates, extinguishes fire',
  },
  {
    id: 'oil',
    name: 'Oil',
    category: 'liquids',
    color: '#4A4A2A',
    description: 'Flammable liquid, floats on water',
  },
  {
    id: 'lava',
    name: 'Lava',
    category: 'liquids',
    color: '#FF4500',
    description: 'Hot liquid, ignites flammables',
  },
  {
    id: 'acid',
    name: 'Acid',
    category: 'liquids',
    color: '#39FF14',
    description: 'Dissolves stone, metal, wood (1:1)',
  },
  
  // Gases
  {
    id: 'steam',
    name: 'Steam',
    category: 'gases',
    color: '#E0E0E0',
    description: 'Rises up, condenses into water',
  },
  {
    id: 'smoke',
    name: 'Smoke',
    category: 'gases',
    color: '#2F2F2F',
    description: 'Rises and dissipates',
  },
  
  // Energy
  {
    id: 'fire',
    name: 'Fire',
    category: 'energy',
    color: '#FF6600',
    description: 'Burns flammables, extinguished by water',
  },
  {
    id: 'spark',
    name: 'Spark',
    category: 'energy',
    color: '#FFFF00',
    description: 'Brief ignition source',
  },
  {
    id: 'electricity',
    name: 'Electric',
    category: 'energy',
    color: '#00FFFF',
    description: 'Flows through conductors',
  },
  
  // Utility
  {
    id: 'clone',
    name: 'Clone',
    category: 'utility',
    color: '#00FF00',
    description: 'Duplicates touching particles',
  },
  {
    id: 'void',
    name: 'Void',
    category: 'utility',
    color: '#000000',
    description: 'Destroys all particles',
  },
  
  // Nature/Bio
  {
    id: 'dirt',
    name: 'Dirt',
    category: 'bio',
    color: '#5C4033',
    description: 'Fertile soil for plants',
  },
  {
    id: 'seed',
    name: 'Seed',
    category: 'bio',
    color: '#E2C489',
    description: 'Plant on wet dirt to grow!',
  },
  {
    id: 'plant',
    name: 'Plant',
    category: 'bio',
    color: '#228B22',
    description: 'Grows with water, burns easily',
  },
]

export function getElementById(id: ElementType): Element | undefined {
  return ELEMENTS.find(el => el.id === id)
}

export function getElementColor(id: ElementType): string {
  return getElementById(id)?.color ?? '#FFFFFF'
}

--- End of File: apps/web/src/lib/elements.ts ---


--- File: apps/web/src/lib/engine/Renderer.ts ---

/**
 * High-performance renderer using Double Buffering
 * Phase 5: ABGR direct copy + OffscreenCanvas optimization
 * 
 * Optimizations:
 * - ABGR format: Direct pixels32.set() from WASM memory
 * - OffscreenCanvas: Better memory management, no DOM overhead
 * - Uint32Array.fill(): 50-100x faster clear
 * - No object access = no pointer chasing = cache friendly
 */

import { EL_EMPTY } from './types'

export type RenderMode = 'normal' | 'thermal'

// Check OffscreenCanvas support
const hasOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'

export class CanvasRenderer {
  private ctx: CanvasRenderingContext2D  // Screen (visible)
  
  // Virtual buffer (Offscreen) - use OffscreenCanvas if available
  private bufferCanvas: HTMLCanvasElement | OffscreenCanvas
  private bufferCtx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D
  private imageData: ImageData
  private pixels: Uint8ClampedArray
  private pixels32: Uint32Array  // View over pixels for fast fill
  
  private width: number
  private height: number
  private mode: RenderMode = 'normal'

  // Camera state
  private zoom: number = 1
  private panX: number = 0
  private panY: number = 0
  
  // Background color as packed ABGR (for Uint32Array)
  // 0xFF0A0A0A = alpha=255, r=10, g=10, b=10
  private readonly BG_COLOR_32 = 0xFF0A0A0A
  private readonly BG_R = 10
  private readonly BG_G = 10
  private readonly BG_B = 10
  
  // Phase 3: Smart Rendering (Dirty Rectangles)
  private static readonly CHUNK_SIZE = 32
  private chunkImageData: ImageData

  constructor(ctx: CanvasRenderingContext2D, width: number, height: number) {
    this.ctx = ctx
    this.width = width
    this.height = height

    // 1. Create offscreen buffer - prefer OffscreenCanvas for better performance
    if (hasOffscreenCanvas) {
      this.bufferCanvas = new OffscreenCanvas(width, height)
      const bCtx = this.bufferCanvas.getContext('2d', { alpha: false })
      if (!bCtx) throw new Error('Failed to create OffscreenCanvas context')
      this.bufferCtx = bCtx
    } else {
      this.bufferCanvas = document.createElement('canvas')
      this.bufferCanvas.width = width
      this.bufferCanvas.height = height
      const bCtx = this.bufferCanvas.getContext('2d', { alpha: false })
      if (!bCtx) throw new Error('Failed to create buffer context')
      this.bufferCtx = bCtx
    }

    // 2. Pixels are tied to buffer
    this.imageData = this.bufferCtx.createImageData(width, height)
    this.pixels = this.imageData.data
    // Create Uint32 view over the same buffer for fast operations
    this.pixels32 = new Uint32Array(this.pixels.buffer)
    
    // Pixel-art rendering (no smoothing on zoom)
    this.ctx.imageSmoothingEnabled = false
    
    // Phase 3: Create chunk ImageData once (32x32)
    this.chunkImageData = new ImageData(CanvasRenderer.CHUNK_SIZE, CanvasRenderer.CHUNK_SIZE)
    
    this.clearPixels()
  }

  // Camera control from outside
  setTransform(zoom: number, panX: number, panY: number): void {
    this.zoom = zoom
    this.panX = panX
    this.panY = panY
  }

  resize(width: number, height: number): void {
    this.width = width
    this.height = height
    
    // Resize buffer (works for both HTMLCanvasElement and OffscreenCanvas)
    this.bufferCanvas.width = width
    this.bufferCanvas.height = height
    this.imageData = this.bufferCtx.createImageData(width, height)
    this.pixels = this.imageData.data
    this.pixels32 = new Uint32Array(this.pixels.buffer)
    
    // Re-disable smoothing after resize
    this.ctx.imageSmoothingEnabled = false
    
    this.clearPixels()
  }

  setMode(mode: RenderMode): void {
    this.mode = mode
  }

  getMode(): RenderMode {
    return this.mode
  }

  // OPTIMIZED: Use Uint32Array.fill() - 50-100x faster than loop!
  private clearPixels(): void {
    this.pixels32.fill(this.BG_COLOR_32)
  }

  // NEW API: Accept TypedArrays directly
  render(types: Uint8Array, colors: Uint32Array, temperatureData?: Float32Array): void {
    // 1. Render pixels to BUFFER
    if (this.mode === 'thermal' && temperatureData) {
      this.renderThermal(temperatureData)
    } else {
      this.renderNormalTyped(types, colors)
    }

    // Put pixels to buffer context
    this.bufferCtx.putImageData(this.imageData, 0, 0)

    // 2. Draw BUFFER to SCREEN with camera transform
    // Clear screen with background
    this.ctx.fillStyle = `rgb(${this.BG_R}, ${this.BG_G}, ${this.BG_B})`
    this.ctx.fillRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height)
    
    this.ctx.save()
    // Apply Pan then Zoom
    this.ctx.translate(this.panX, this.panY)
    this.ctx.scale(this.zoom, this.zoom)
    
    // Draw buffer image
    this.ctx.drawImage(this.bufferCanvas, 0, 0)
    
    // 3. Draw world border (neon glow effect)
    this.drawWorldBorder()
    
    this.ctx.restore()
  }

  /**
   * Draw a stylish border around the simulation world
   * Creates a neon glow effect with gradient
   */
  private drawWorldBorder(): void {
    const ctx = this.ctx
    const w = this.width
    const h = this.height
    
    // Outer glow (wider, more transparent)
    ctx.strokeStyle = 'rgba(59, 130, 246, 0.3)' // Blue glow
    ctx.lineWidth = 6 / this.zoom // Compensate for zoom
    ctx.strokeRect(-3 / this.zoom, -3 / this.zoom, w + 6 / this.zoom, h + 6 / this.zoom)
    
    // Middle glow
    ctx.strokeStyle = 'rgba(59, 130, 246, 0.5)'
    ctx.lineWidth = 3 / this.zoom
    ctx.strokeRect(-1.5 / this.zoom, -1.5 / this.zoom, w + 3 / this.zoom, h + 3 / this.zoom)
    
    // Inner sharp border
    ctx.strokeStyle = 'rgba(59, 130, 246, 0.8)'
    ctx.lineWidth = 1 / this.zoom
    ctx.strokeRect(0, 0, w, h)
    
    // Corner accents (bright dots)
    const cornerSize = 8 / this.zoom
    ctx.fillStyle = '#3B82F6'
    
    // Top-left
    ctx.fillRect(-cornerSize / 2, -cornerSize / 2, cornerSize, 2 / this.zoom)
    ctx.fillRect(-cornerSize / 2, -cornerSize / 2, 2 / this.zoom, cornerSize)
    
    // Top-right
    ctx.fillRect(w - cornerSize / 2, -cornerSize / 2, cornerSize, 2 / this.zoom)
    ctx.fillRect(w - 2 / this.zoom + cornerSize / 2, -cornerSize / 2, 2 / this.zoom, cornerSize)
    
    // Bottom-left
    ctx.fillRect(-cornerSize / 2, h - 2 / this.zoom + cornerSize / 2, cornerSize, 2 / this.zoom)
    ctx.fillRect(-cornerSize / 2, h - cornerSize / 2, 2 / this.zoom, cornerSize)
    
    // Bottom-right
    ctx.fillRect(w - cornerSize / 2, h - 2 / this.zoom + cornerSize / 2, cornerSize, 2 / this.zoom)
    ctx.fillRect(w - 2 / this.zoom + cornerSize / 2, h - cornerSize / 2, 2 / this.zoom, cornerSize)
  }

  /**
   * Phase 5: ULTRA-OPTIMIZED direct copy from WASM memory!
   * WASM now returns ABGR format - direct copy with pixels32.set()
   * ~3-5x faster than byte-by-byte unpacking
   */
  private renderNormalTyped(types: Uint8Array, colors: Uint32Array): void {
    const pixels32 = this.pixels32
    const len = Math.min(types.length, this.width * this.height)
    
    // Fast path: Direct copy all colors (WASM provides ABGR format)
    // Background is already correct format, just set everything!
    pixels32.set(colors.subarray(0, len))
    
    // Fix empty cells to background color (particles have correct colors)
    // This is still fast because most cells are particles in active simulations
    for (let i = 0; i < len; i++) {
      if (types[i] === EL_EMPTY) {
        pixels32[i] = this.BG_COLOR_32
      }
    }
  }

  /**
   * Render thermal vision - temperature to color gradient
   */
  private renderThermal(temps: Float32Array): void {
    const pixels = this.pixels
    const len = Math.min(temps.length, this.width * this.height)

    for (let i = 0; i < len; i++) {
      const temp = temps[i]
      const base = i << 2
      
      const [r, g, b] = this.getThermalColor(temp)
      
      pixels[base] = r
      pixels[base + 1] = g
      pixels[base + 2] = b
      pixels[base + 3] = 255
    }
  }

  /**
   * Temperature to color gradient:
   * Blue (-20) -> Cyan (0) -> Green (20) -> Yellow (100) -> Red (500) -> White (1000)
   */
  private getThermalColor(t: number): [number, number, number] {
    // Freezing: Deep Blue to Blue
    if (t < 0) {
      const intensity = Math.min(1, Math.abs(t) / 30)
      return [0, 0, Math.floor(128 + 127 * intensity)]
    }
    
    // Cold: Blue to Cyan (0-20)
    if (t < 20) {
      const ratio = t / 20
      return [0, Math.floor(ratio * 255), 255]
    }
    
    // Ambient: Cyan to Green (20-50)
    if (t < 50) {
      const ratio = (t - 20) / 30
      return [0, 255, Math.floor(255 * (1 - ratio))]
    }
    
    // Warm: Green to Yellow (50-100)
    if (t < 100) {
      const ratio = (t - 50) / 50
      return [Math.floor(255 * ratio), 255, 0]
    }
    
    // Hot: Yellow to Red (100-500)
    if (t < 500) {
      const ratio = (t - 100) / 400
      return [255, Math.floor(255 * (1 - ratio)), 0]
    }
    
    // Extreme: Red to White (500-1000+)
    const ratio = Math.min(1, (t - 500) / 500)
    return [255, Math.floor(255 * ratio), Math.floor(255 * ratio)]
  }
  
  // === PHASE 3: SMART RENDERING (Dirty Rectangles) ===
  
  /**
   * Smart render - only update dirty chunks
   * Massive performance improvement when most of the screen is static
   */
  renderSmart(
    engine: { 
      getDirtyChunksCount: () => number
      getDirtyListPtr: () => number
      extractChunkPixels: (idx: number) => number
      getChunksX: () => number
      render: () => void
    },
    memory: WebAssembly.Memory
  ): void {
    // 1. Ask Rust: how many chunks changed?
    const count = engine.getDirtyChunksCount()
    
    // Heuristic: If >70% of chunks changed, full render is faster
    const totalChunks = Math.ceil(this.width / CanvasRenderer.CHUNK_SIZE) * 
                        Math.ceil(this.height / CanvasRenderer.CHUNK_SIZE)
    
    if (count > totalChunks * 0.7) {
      // Fallback to full render
      engine.render()
      return
    }
    
    if (count === 0) {
      // Nothing changed, just redraw buffer to screen (for zoom/pan)
      this.drawBufferToScreen()
      return
    }
    
    // 2. Get dirty chunk list (zero-copy view into WASM memory)
    const listPtr = engine.getDirtyListPtr()
    const dirtyIds = new Uint32Array(memory.buffer, listPtr, count)
    
    const chunksX = engine.getChunksX()
    const CHUNK_SIZE = CanvasRenderer.CHUNK_SIZE
    
    // 3. Process each dirty chunk
    for (let i = 0; i < count; i++) {
      const chunkIdx = dirtyIds[i]
      
      // Ask Rust to copy chunk pixels to transfer buffer
      const pixelsPtr = engine.extractChunkPixels(chunkIdx)
      
      // Create view into chunk pixels (4096 bytes = 32*32*4)
      const chunkPixels = new Uint8ClampedArray(memory.buffer, pixelsPtr, 4096)
      
      // Copy to ImageData
      this.chunkImageData.data.set(chunkPixels)
      
      // Calculate screen position
      const cx = chunkIdx % chunksX
      const cy = Math.floor(chunkIdx / chunksX)
      const x = cx * CHUNK_SIZE
      const y = cy * CHUNK_SIZE
      
      // Stamp chunk to buffer
      this.bufferCtx.putImageData(this.chunkImageData, x, y)
    }
    
    // 4. Draw buffer to screen with camera transform
    this.drawBufferToScreen()
  }
  
  /**
   * Draw buffer canvas to screen with camera transform
   */
  private drawBufferToScreen(): void {
    // Clear screen with background
    this.ctx.fillStyle = `rgb(${this.BG_R}, ${this.BG_G}, ${this.BG_B})`
    this.ctx.fillRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height)
    
    this.ctx.save()
    // Apply Pan then Zoom
    this.ctx.translate(this.panX, this.panY)
    this.ctx.scale(this.zoom, this.zoom)
    
    // Draw buffer image
    this.ctx.drawImage(this.bufferCanvas, 0, 0)
    
    // Draw world border
    this.drawWorldBorder()
    
    this.ctx.restore()
  }
}

--- End of File: apps/web/src/lib/engine/Renderer.ts ---


--- File: apps/web/src/lib/engine/WasmParticleEngine.ts ---

/**
 * WasmParticleEngine - WASM-powered particle simulation
 * 
 * Phase 3: Maximum performance with Rust + WebAssembly
 * 
 * The simulation runs entirely in WASM. JS only handles:
 * - Initialization
 * - User input (add/remove particles)
 * - Rendering (reading from WASM memory)
 */

import { CanvasRenderer, RenderMode } from './Renderer'
import { ElementType } from './types'

// Element name to WASM ID mapping
const ELEMENT_TO_WASM_ID: Record<ElementType, number> = {
  'empty': 0,
  'stone': 1,
  'sand': 2,
  'wood': 3,
  'metal': 4,
  'ice': 5,
  'water': 6,
  'oil': 7,
  'lava': 8,
  'acid': 9,
  'steam': 10,
  'smoke': 11,
  'fire': 12,
  'spark': 13,
  'electricity': 14,
  'gunpowder': 15,
  'clone': 16,
  'void': 17,
  'dirt': 18,
  'seed': 19,
  'plant': 20,
}

// WASM module type (will be loaded dynamically)
interface WasmModule {
  init: () => void
  version: () => string
  World: new (width: number, height: number) => WasmWorld
}

interface WasmWorld {
  width: number
  height: number
  particle_count: number
  frame: bigint
  set_gravity: (x: number, y: number) => void
  set_ambient_temperature: (temp: number) => void
  add_particle: (x: number, y: number, element: number) => boolean
  add_particles_in_radius: (cx: number, cy: number, radius: number, element: number) => void
  remove_particle: (x: number, y: number) => boolean
  remove_particles_in_radius: (cx: number, cy: number, radius: number) => void
  clear: () => void
  step: () => void
  types_ptr: () => number
  colors_ptr: () => number
  types_len: () => number
  colors_len: () => number
  temperature_ptr: () => number
  temperature_len: () => number
  // Phase 3: Smart Rendering
  collect_dirty_chunks: () => number
  get_dirty_list_ptr: () => number
  extract_chunk_pixels: (chunkIdx: number) => number
  chunks_x: () => number
  chunks_y: () => number
}

let wasmModule: WasmModule | null = null
let wasmMemory: WebAssembly.Memory | null = null

/**
 * Load WASM module
 */
export async function loadWasmEngine(): Promise<WasmModule> {
  if (wasmModule) return wasmModule
  
  try {
    // Dynamic import of WASM package
    // @ts-ignore - WASM module loaded dynamically
    const wasm = await import('@particula/engine-wasm/particula_engine')
    
    // Initialize WASM and get exports (including memory!)
    const wasmExports = await wasm.default()
    
    // Memory is in the exports returned by init
    wasmMemory = wasmExports.memory
    
    if (!wasmMemory) {
      console.error('WASM memory not found in exports:', Object.keys(wasmExports))
      throw new Error('WASM memory not available')
    }
    
    wasmModule = wasm as unknown as WasmModule
    wasmModule.init()
    
    console.log(`ðŸ¦€ WASM Engine loaded, version: ${wasmModule.version()}`)
    console.log(`ðŸ¦€ WASM memory size: ${wasmMemory.buffer.byteLength} bytes`)
    return wasmModule
  } catch (err) {
    console.error('Failed to load WASM engine:', err)
    throw err
  }
}

/**
 * Check if WASM is available
 */
export function isWasmAvailable(): boolean {
  return typeof WebAssembly !== 'undefined'
}

export class WasmParticleEngine {
  private world: WasmWorld
  private renderer: CanvasRenderer | null = null
  private wasm: WasmModule
  
  private _width: number
  private _height: number
  
  // TypedArray views into WASM memory (updated each frame)
  private typesView: Uint8Array | null = null
  private colorsView: Uint32Array | null = null
  private temperatureView: Float32Array | null = null
  
  // Prevent recursive WASM calls
  private _isBusy: boolean = false
  
  private constructor(wasm: WasmModule, width: number, height: number) {
    this.wasm = wasm
    this._width = width
    this._height = height
    this.world = new wasm.World(width, height)
    this.updateMemoryViews()
  }
  
  /**
   * Create WasmParticleEngine (async factory)
   */
  static async create(width: number, height: number): Promise<WasmParticleEngine> {
    const wasm = await loadWasmEngine()
    return new WasmParticleEngine(wasm, width, height)
  }
  
  /**
   * Update TypedArray views into WASM memory
   */
  private updateMemoryViews(): void {
    if (!wasmMemory) return
    
    const typesPtr = this.world.types_ptr()
    const colorsPtr = this.world.colors_ptr()
    const tempPtr = this.world.temperature_ptr()
    const size = this.world.types_len()
    
    this.typesView = new Uint8Array(wasmMemory.buffer, typesPtr, size)
    this.colorsView = new Uint32Array(wasmMemory.buffer, colorsPtr, size)
    this.temperatureView = new Float32Array(wasmMemory.buffer, tempPtr, size)
  }
  
  // === Public API ===
  
  get width(): number { return this._width }
  get height(): number { return this._height }
  get particleCount(): number { return this.world.particle_count }
  get frame(): number { return Number(this.world.frame) }
  
  attachRenderer(ctx: CanvasRenderingContext2D): void {
    this.renderer = new CanvasRenderer(ctx, this._width, this._height)
  }
  
  setSettings(settings: { gravity?: { x: number; y: number }; ambientTemperature?: number }): void {
    if (settings.gravity) {
      this.world.set_gravity(settings.gravity.x, settings.gravity.y)
    }
    if (settings.ambientTemperature !== undefined) {
      this.world.set_ambient_temperature(settings.ambientTemperature)
    }
  }
  
  addParticle(x: number, y: number, element: ElementType): boolean {
    if (this._isBusy) return false
    const wasmId = ELEMENT_TO_WASM_ID[element] ?? 0
    if (wasmId === 0) return false  // Don't add empty
    return this.world.add_particle(Math.floor(x), Math.floor(y), wasmId)
  }
  
  addParticlesInRadius(cx: number, cy: number, radius: number, element: ElementType): void {
    if (this._isBusy) return
    const wasmId = ELEMENT_TO_WASM_ID[element] ?? 0
    if (wasmId === 0) return  // Don't add empty
    this.world.add_particles_in_radius(Math.floor(cx), Math.floor(cy), Math.floor(radius), wasmId)
  }
  
  removeParticle(x: number, y: number): boolean {
    if (this._isBusy) return false
    return this.world.remove_particle(Math.floor(x), Math.floor(y))
  }
  
  removeParticlesInRadius(cx: number, cy: number, radius: number): void {
    if (this._isBusy) return
    this.world.remove_particles_in_radius(Math.floor(cx), Math.floor(cy), Math.floor(radius))
  }
  
  clear(): void {
    if (this._isBusy) return
    this.world.clear()
  }
  
  step(): void {
    if (this._isBusy) return
    this._isBusy = true
    try {
      this.world.step()
      // Memory views may need to be refreshed if WASM memory grew
      this.updateMemoryViews()
    } finally {
      this._isBusy = false
    }
  }
  
  render(): void {
    if (!this.renderer || !this.typesView || !this.colorsView) return
    
    // Render directly from WASM memory - zero copy!
    // Pass temperature for thermal view mode
    this.renderer.render(this.typesView, this.colorsView, this.temperatureView ?? undefined)
  }
  
  // === Phase 3: Smart Rendering API ===
  
  /** Get WASM memory for zero-copy access */
  get memory(): WebAssembly.Memory | null {
    return wasmMemory
  }
  
  /** Get the renderer instance */
  getRenderer(): CanvasRenderer | null {
    return this.renderer
  }
  
  /** Collect dirty chunks and return count */
  getDirtyChunksCount(): number {
    return this.world.collect_dirty_chunks()
  }
  
  /** Get pointer to dirty chunk list */
  getDirtyListPtr(): number {
    return this.world.get_dirty_list_ptr()
  }
  
  /** Extract chunk pixels to transfer buffer, returns pointer */
  extractChunkPixels(chunkIdx: number): number {
    return this.world.extract_chunk_pixels(chunkIdx)
  }
  
  /** Get chunks X count */
  getChunksX(): number {
    return this.world.chunks_x()
  }
  
  /** Get chunks Y count */
  getChunksY(): number {
    return this.world.chunks_y()
  }
  
  /** Get total chunks count */
  getTotalChunks(): number {
    return this.world.chunks_x() * this.world.chunks_y()
  }
  
  setRenderMode(mode: RenderMode): void {
    this.renderer?.setMode(mode)
  }
  
  getRenderMode(): RenderMode {
    return this.renderer?.getMode() ?? 'normal'
  }
  
  setTransform(zoom: number, panX: number, panY: number): void {
    this.renderer?.setTransform(zoom, panX, panY)
  }
  
  resize(width: number, height: number): void {
    // Create new world with new dimensions
    this._width = width
    this._height = height
    this.world = new this.wasm.World(width, height)
    this.updateMemoryViews()
    this.renderer?.resize(width, height)
  }
  
  destroy(): void {
    // WASM world will be garbage collected
  }
}

--- End of File: apps/web/src/lib/engine/WasmParticleEngine.ts ---


--- File: apps/web/src/lib/engine/elements.ts ---

/**
 * Element definitions with all properties
 * Phase 1: Data-Oriented Design with numeric IDs
 * 
 * Elements are stored in a flat array indexed by ElementId
 * This allows O(1) access without hash lookups
 */

import { 
  ElementType, 
  ElementProperties,
  ElementCategory,
  CategoryId,
  ElementId,
  ELEMENT_COUNT,
  ELEMENT_ID_TO_NAME,
  // Element IDs
  EL_EMPTY, EL_STONE, EL_SAND, EL_WOOD, EL_METAL, EL_ICE,
  EL_WATER, EL_OIL, EL_LAVA, EL_ACID,
  EL_STEAM, EL_SMOKE,
  EL_FIRE, EL_SPARK, EL_ELECTRICITY,
  EL_GUNPOWDER, EL_CLONE, EL_VOID,
  EL_DIRT, EL_SEED, EL_PLANT,
  // Category IDs
  CAT_SOLID, CAT_POWDER, CAT_LIQUID, CAT_GAS, CAT_ENERGY, CAT_UTILITY, CAT_BIO
} from './types'

// Color helper - convert hex string to packed RGBA
function rgba(hex: string, alpha = 255): number {
  const num = parseInt(hex.replace('#', ''), 16)
  return (alpha << 24) | num
}

// ============================================
// ELEMENT DATA - Flat array indexed by ElementId
// ============================================
export const ELEMENT_DATA: ElementProperties[] = [
  // 0: Empty
  {
    id: EL_EMPTY,
    name: 'Empty',
    category: CAT_SOLID,
    color: rgba('#0a0a0a'),
    density: 0,
    flammable: false,
    conductive: false,
    lifetime: 0,
    dispersion: 0,
    defaultTemp: 20,
    heatConductivity: 5,
  },
  // 1: Stone
  {
    id: EL_STONE,
    name: 'Stone',
    category: CAT_SOLID,
    color: rgba('#808080'),
    density: 2500,
    flammable: false,
    conductive: false,
    lifetime: 0,
    dispersion: 0,
    defaultTemp: 20,
    heatConductivity: 10,
    phaseChange: { high: { temp: 900, to: EL_LAVA } },
  },
  // 2: Sand
  {
    id: EL_SAND,
    name: 'Sand',
    category: CAT_POWDER,
    color: rgba('#C2B280'),
    density: 1600,
    flammable: false,
    conductive: false,
    lifetime: 0,
    dispersion: 0,
    defaultTemp: 20,
    heatConductivity: 15,
    phaseChange: { high: { temp: 1700, to: EL_LAVA } },
  },
  // 3: Wood
  {
    id: EL_WOOD,
    name: 'Wood',
    category: CAT_SOLID,
    color: rgba('#8B4513'),
    density: 600,
    flammable: true,
    conductive: false,
    lifetime: 0,
    dispersion: 0,
    defaultTemp: 20,
    heatConductivity: 5,
  },
  // 4: Metal
  {
    id: EL_METAL,
    name: 'Metal',
    category: CAT_SOLID,
    color: rgba('#A9A9A9'),
    density: 7800,
    flammable: false,
    conductive: true,
    lifetime: 0,
    dispersion: 0,
    defaultTemp: 20,
    heatConductivity: 90,
    phaseChange: { high: { temp: 1500, to: EL_LAVA } },
  },
  // 5: Ice
  {
    id: EL_ICE,
    name: 'Ice',
    category: CAT_SOLID,
    color: rgba('#A5F2F3'),
    density: 916,
    flammable: false,
    conductive: false,
    lifetime: 0,
    dispersion: 0,
    defaultTemp: -10,
    heatConductivity: 20,
    phaseChange: { high: { temp: 0, to: EL_WATER } },
  },
  // 6: Water
  {
    id: EL_WATER,
    name: 'Water',
    category: CAT_LIQUID,
    color: rgba('#4169E1'),
    density: 1000,
    flammable: false,
    conductive: true,
    lifetime: 0,
    dispersion: 8,
    defaultTemp: 20,
    heatConductivity: 40,
    phaseChange: {
      high: { temp: 100, to: EL_STEAM },
      low: { temp: 0, to: EL_ICE }
    },
  },
  // 7: Oil
  {
    id: EL_OIL,
    name: 'Oil',
    category: CAT_LIQUID,
    color: rgba('#4A4A2A'),
    density: 800,
    flammable: true,
    conductive: false,
    lifetime: 0,
    dispersion: 5,
    defaultTemp: 20,
    heatConductivity: 15,
  },
  // 8: Lava
  {
    id: EL_LAVA,
    name: 'Lava',
    category: CAT_LIQUID,
    color: rgba('#FF4500'),
    density: 2500,
    flammable: false,
    conductive: false,
    lifetime: 0,
    dispersion: 2,
    defaultTemp: 1000,
    heatConductivity: 30,
    phaseChange: { low: { temp: 700, to: EL_STONE } },
  },
  // 9: Acid
  {
    id: EL_ACID,
    name: 'Acid',
    category: CAT_LIQUID,
    color: rgba('#39FF14'),
    density: 1050,
    flammable: false,
    conductive: true,
    lifetime: 0,
    dispersion: 5,
    defaultTemp: 20,
    heatConductivity: 35,
  },
  // 10: Steam
  {
    id: EL_STEAM,
    name: 'Steam',
    category: CAT_GAS,
    color: rgba('#E0E0E0', 180),
    density: 0.6,
    flammable: false,
    conductive: false,
    lifetime: 0,
    dispersion: 6,
    defaultTemp: 100,
    heatConductivity: 10,
    phaseChange: { low: { temp: 90, to: EL_WATER } },
  },
  // 11: Smoke
  {
    id: EL_SMOKE,
    name: 'Smoke',
    category: CAT_GAS,
    color: rgba('#3F3F3F', 200),
    density: 1.1,
    flammable: false,
    conductive: false,
    lifetime: 0,
    dispersion: 4,
    defaultTemp: 50,
    heatConductivity: 5,
  },
  // 12: Fire
  {
    id: EL_FIRE,
    name: 'Fire',
    category: CAT_ENERGY,
    color: rgba('#FF6600'),
    density: 0.3,
    flammable: false,
    conductive: false,
    lifetime: 60,
    dispersion: 0,
    defaultTemp: 800,
    heatConductivity: 50,
  },
  // 13: Spark
  {
    id: EL_SPARK,
    name: 'Spark',
    category: CAT_ENERGY,
    color: rgba('#FFFF00'),
    density: 0.1,
    flammable: false,
    conductive: false,
    lifetime: 10,
    dispersion: 0,
    defaultTemp: 500,
    heatConductivity: 50,
  },
  // 14: Electricity
  {
    id: EL_ELECTRICITY,
    name: 'Electric',
    category: CAT_ENERGY,
    color: rgba('#00FFFF'),
    density: 0,
    flammable: false,
    conductive: false,
    lifetime: 3,
    dispersion: 0,
    defaultTemp: 200,
    heatConductivity: 80,
  },
  // 15: Gunpowder
  {
    id: EL_GUNPOWDER,
    name: 'Gunpowder',
    category: CAT_POWDER,
    color: rgba('#404040'),
    density: 1400,
    flammable: true,
    conductive: false,
    lifetime: 0,
    dispersion: 0,
    defaultTemp: 20,
    heatConductivity: 10,
  },
  // 16: Clone
  {
    id: EL_CLONE,
    name: 'Clone',
    category: CAT_UTILITY,
    color: rgba('#00FF00'),
    density: Infinity,
    flammable: false,
    conductive: false,
    lifetime: 0,
    dispersion: 0,
    defaultTemp: 20,
    heatConductivity: 0,
  },
  // 17: Void
  {
    id: EL_VOID,
    name: 'Void',
    category: CAT_UTILITY,
    color: rgba('#000000'),
    density: Infinity,
    flammable: false,
    conductive: false,
    lifetime: 0,
    dispersion: 0,
    defaultTemp: 20,
    heatConductivity: 0,
  },
  // 18: Dirt
  {
    id: EL_DIRT,
    name: 'Dirt',
    category: CAT_POWDER,
    color: rgba('#5C4033'),
    density: 1200,
    flammable: false,
    conductive: false,
    lifetime: 0,
    dispersion: 0,
    defaultTemp: 20,
    heatConductivity: 10,
  },
  // 19: Seed
  {
    id: EL_SEED,
    name: 'Seed',
    category: CAT_BIO,
    color: rgba('#E2C489'),
    density: 1100,
    flammable: true,
    conductive: false,
    lifetime: 0,
    dispersion: 0,
    defaultTemp: 20,
    heatConductivity: 5,
  },
  // 20: Plant
  {
    id: EL_PLANT,
    name: 'Plant',
    category: CAT_BIO,
    color: rgba('#228B22'),
    density: 900,
    flammable: true,
    conductive: false,
    lifetime: 0,
    dispersion: 0,
    defaultTemp: 20,
    heatConductivity: 10,
  },
]

// ============================================
// LEGACY COMPATIBILITY - Record<ElementType, ElementProperties>
// ============================================
export const ELEMENTS: Record<ElementType, ElementProperties> = {} as Record<ElementType, ElementProperties>

// Build ELEMENTS from ELEMENT_DATA
for (let i = 0; i < ELEMENT_COUNT; i++) {
  const name = ELEMENT_ID_TO_NAME[i]
  if (name) {
    ELEMENTS[name] = ELEMENT_DATA[i]
  }
}

// ============================================
// FAST LOOKUP FUNCTIONS (use numeric IDs)
// ============================================

// Get element properties by numeric ID - O(1), no hash lookup!
export function getElement(id: ElementId): ElementProperties {
  return ELEMENT_DATA[id] || ELEMENT_DATA[EL_EMPTY]
}

// Get category by element ID
export function getCategoryById(id: ElementId): CategoryId {
  return ELEMENT_DATA[id]?.category ?? CAT_SOLID
}

// Get density by element ID
export function getDensityById(id: ElementId): number {
  return ELEMENT_DATA[id]?.density ?? 0
}

// Get dispersion by element ID
export function getDispersionById(id: ElementId): number {
  return ELEMENT_DATA[id]?.dispersion ?? 0
}

// ============================================
// COLOR VARIATIONS (pre-computed per element)
// ============================================
const COLOR_VARIATIONS_BY_ID: Uint32Array[] = new Array(ELEMENT_COUNT)

// Pre-compute all color variations at load time!
for (let elId = 0; elId < ELEMENT_COUNT; elId++) {
  const base = ELEMENT_DATA[elId].color
  const variations = new Uint32Array(32)
  
  for (let i = 0; i < 32; i++) {
    const variation = (i - 16) * 2
    const a = (base >> 24) & 0xFF
    const r = Math.max(0, Math.min(255, ((base >> 16) & 0xFF) + variation))
    const g = Math.max(0, Math.min(255, ((base >> 8) & 0xFF) + variation))
    const b = Math.max(0, Math.min(255, (base & 0xFF) + variation))
    variations[i] = (a << 24) | (r << 16) | (g << 8) | b
  }
  
  COLOR_VARIATIONS_BY_ID[elId] = variations
}

// Get color variation by element ID - super fast!
export function getColorById(id: ElementId, seed: number): number {
  return COLOR_VARIATIONS_BY_ID[id][seed & 31]
}

// ============================================
// LEGACY FUNCTIONS (use string ElementType)
// ============================================
const COLOR_VARIATIONS = new Map<ElementType, Uint32Array>()

export function getColorWithVariation(element: ElementType, seed: number): number {
  let variations = COLOR_VARIATIONS.get(element)
  
  if (!variations) {
    const base = ELEMENTS[element].color
    variations = new Uint32Array(32)
    
    for (let i = 0; i < 32; i++) {
      const variation = (i - 16) * 2
      const a = (base >> 24) & 0xFF
      const r = Math.max(0, Math.min(255, ((base >> 16) & 0xFF) + variation))
      const g = Math.max(0, Math.min(255, ((base >> 8) & 0xFF) + variation))
      const b = Math.max(0, Math.min(255, (base & 0xFF) + variation))
      variations[i] = (a << 24) | (r << 16) | (g << 8) | b
    }
    
    COLOR_VARIATIONS.set(element, variations)
  }
  
  return variations[seed & 31]
}

export function getElementCategory(element: ElementType): ElementCategory {
  const cat = ELEMENTS[element].category
  // Convert numeric category back to string for legacy code
  const names: ElementCategory[] = ['solid', 'powder', 'liquid', 'gas', 'energy', 'utility', 'bio']
  return names[cat] || 'solid'
}

export function getElementColor(element: ElementType): string {
  const color = ELEMENTS[element].color
  const r = (color >> 16) & 0xFF
  const g = (color >> 8) & 0xFF
  const b = color & 0xFF
  return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`
}

--- End of File: apps/web/src/lib/engine/elements.ts ---


--- File: apps/web/src/lib/engine/index.ts ---

/**
 * Particula Engine - WASM-powered particle simulation
 * 
 * Phase 5: Clean architecture - WASM only!
 * Legacy fallback engines moved to _LEGACY/
 */

// Core exports
export { ELEMENTS, getElementColor } from './elements'
export type { ElementType, WorldSettings } from './types'
export type { RenderMode } from './Renderer'

// Primary engine: Rust WASM
export { WasmParticleEngine, loadWasmEngine, isWasmAvailable } from './WasmParticleEngine'

// Re-export WasmParticleEngine as ParticleEngine for convenience
export { WasmParticleEngine as ParticleEngine } from './WasmParticleEngine'

--- End of File: apps/web/src/lib/engine/index.ts ---


--- File: apps/web/src/lib/engine/types.ts ---

/**
 * Core types for the particle simulation engine
 * Phase 1: Data-Oriented Design with TypedArrays
 * 
 * Key changes:
 * - ElementId is now a number (Uint8) for TypedArray storage
 * - No more Particle objects - data stored in SoA (Structure of Arrays)
 * - Zero GC pressure during simulation
 */

// ============================================
// ELEMENT IDS - Numeric constants for TypedArrays
// ============================================
export const EL_EMPTY       = 0
export const EL_STONE       = 1
export const EL_SAND        = 2
export const EL_WOOD        = 3
export const EL_METAL       = 4
export const EL_ICE         = 5
export const EL_WATER       = 6
export const EL_OIL         = 7
export const EL_LAVA        = 8
export const EL_ACID        = 9
export const EL_STEAM       = 10
export const EL_SMOKE       = 11
export const EL_FIRE        = 12
export const EL_SPARK       = 13
export const EL_ELECTRICITY = 14
export const EL_GUNPOWDER   = 15
export const EL_CLONE       = 16
export const EL_VOID        = 17
export const EL_DIRT        = 18
export const EL_SEED        = 19
export const EL_PLANT       = 20

export const ELEMENT_COUNT  = 21

// ElementId type - the numeric ID
export type ElementId = number

// Legacy string type for backwards compatibility during transition
export type ElementType = 
  | 'empty'
  | 'stone' | 'sand' | 'wood' | 'metal' | 'ice'
  | 'water' | 'oil' | 'lava' | 'acid'
  | 'steam' | 'smoke'
  | 'fire' | 'spark' | 'electricity'
  | 'gunpowder'
  | 'clone' | 'void'
  | 'dirt' | 'seed' | 'plant'

// String to ID mapping
export const ELEMENT_NAME_TO_ID: Record<ElementType, ElementId> = {
  empty: EL_EMPTY,
  stone: EL_STONE,
  sand: EL_SAND,
  wood: EL_WOOD,
  metal: EL_METAL,
  ice: EL_ICE,
  water: EL_WATER,
  oil: EL_OIL,
  lava: EL_LAVA,
  acid: EL_ACID,
  steam: EL_STEAM,
  smoke: EL_SMOKE,
  fire: EL_FIRE,
  spark: EL_SPARK,
  electricity: EL_ELECTRICITY,
  gunpowder: EL_GUNPOWDER,
  clone: EL_CLONE,
  void: EL_VOID,
  dirt: EL_DIRT,
  seed: EL_SEED,
  plant: EL_PLANT,
}

// ID to string mapping (for debugging/UI)
export const ELEMENT_ID_TO_NAME: ElementType[] = [
  'empty', 'stone', 'sand', 'wood', 'metal', 'ice',
  'water', 'oil', 'lava', 'acid',
  'steam', 'smoke',
  'fire', 'spark', 'electricity',
  'gunpowder',
  'clone', 'void',
  'dirt', 'seed', 'plant'
]

// ============================================
// CATEGORY IDS - Numeric for fast comparison
// ============================================
export const CAT_SOLID   = 0
export const CAT_POWDER  = 1
export const CAT_LIQUID  = 2
export const CAT_GAS     = 3
export const CAT_ENERGY  = 4
export const CAT_UTILITY = 5
export const CAT_BIO     = 6

export type CategoryId = number
export type ElementCategory = 'solid' | 'powder' | 'liquid' | 'gas' | 'energy' | 'utility' | 'bio'

export const CATEGORY_NAME_TO_ID: Record<ElementCategory, CategoryId> = {
  solid: CAT_SOLID,
  powder: CAT_POWDER,
  liquid: CAT_LIQUID,
  gas: CAT_GAS,
  energy: CAT_ENERGY,
  utility: CAT_UTILITY,
  bio: CAT_BIO,
}

// ============================================
// ELEMENT PROPERTIES - Flat arrays for cache efficiency
// ============================================
export interface PhaseChange {
  high?: { temp: number; to: ElementId }
  low?: { temp: number; to: ElementId }
}

export interface ElementProperties {
  id: ElementId
  name: string
  category: CategoryId
  color: number
  density: number
  flammable: boolean
  conductive: boolean
  lifetime: number
  dispersion: number
  defaultTemp: number
  heatConductivity: number
  phaseChange?: PhaseChange
}

// ============================================
// WORLD SETTINGS
// ============================================
export interface WorldSettings {
  gravity: { x: number; y: number }
  ambientTemperature: number
  speed: number
}

// ============================================
// LEGACY INTERFACES (for gradual migration)
// ============================================
export interface Particle {
  element: ElementType
  color: number
  updated: boolean
  lifetime: number
}

export interface IRenderer {
  render(types: Uint8Array, colors: Uint32Array): void
  resize(width: number, height: number): void
}

export interface ISimulation {
  step(): void
  addParticle(x: number, y: number, element: ElementType): boolean
  removeParticle(x: number, y: number): boolean
  clear(): void
  resize(width: number, height: number): void
  readonly particleCount: number
  readonly width: number
  readonly height: number
}

--- End of File: apps/web/src/lib/engine/types.ts ---


--- File: apps/web/src/main.tsx ---

import ReactDOM from 'react-dom/client'
import App from './App'
import './styles/globals.css'

ReactDOM.createRoot(document.getElementById('root')!).render(<App />)

--- End of File: apps/web/src/main.tsx ---


--- File: apps/web/src/stores/simulationStore.ts ---

import { create } from 'zustand'
import { getEngine } from '@/components/Canvas'
import type { RenderMode } from '@/lib/engine'

interface SimulationState {
  // State
  isPlaying: boolean
  speed: 0.5 | 1 | 2 | 4
  fps: number
  particleCount: number
  renderMode: RenderMode
  
  // World settings
  gravity: { x: number; y: number }
  ambientTemperature: number
  
  // Actions
  play: () => void
  pause: () => void
  step: () => void
  reset: () => void
  setSpeed: (speed: 0.5 | 1 | 2 | 4) => void
  setGravity: (gravity: { x: number; y: number }) => void
  setAmbientTemperature: (temp: number) => void
  setFps: (fps: number) => void
  setParticleCount: (count: number) => void
  toggleRenderMode: () => void
}

export const useSimulationStore = create<SimulationState>((set, get) => ({
  // Initial state
  isPlaying: false,
  speed: 1,
  fps: 60,
  particleCount: 0,
  renderMode: 'normal' as RenderMode,
  gravity: { x: 0, y: 9.8 },
  ambientTemperature: 20,
  
  // Actions
  play: () => set({ isPlaying: true }),
  pause: () => set({ isPlaying: false }),
  step: () => {
    const engine = getEngine()
    if (engine) {
      engine.step()
    }
  },
  reset: () => {
    const engine = getEngine()
    if (engine) {
      engine.clear()
    }
    set({ particleCount: 0, isPlaying: false })
  },
  setSpeed: (speed) => set({ speed }),
  setGravity: (gravity) => set({ gravity }),
  setAmbientTemperature: (ambientTemperature) => set({ ambientTemperature }),
  setFps: (fps) => set({ fps }),
  setParticleCount: (particleCount) => set({ particleCount }),
  toggleRenderMode: () => {
    const engine = getEngine()
    const currentMode = get().renderMode
    const newMode: RenderMode = currentMode === 'normal' ? 'thermal' : 'normal'
    if (engine) {
      engine.setRenderMode(newMode)
    }
    set({ renderMode: newMode })
  },
}))

--- End of File: apps/web/src/stores/simulationStore.ts ---


--- File: apps/web/src/stores/toolStore.ts ---

import { create } from 'zustand'
import type { ElementType } from '@/lib/engine'

type ToolType = 'brush' | 'eraser' | 'pipette' | 'fill' | 'move'
type BrushShape = 'circle' | 'square' | 'line'

interface ToolState {
  // Current tool
  selectedTool: ToolType
  brushShape: BrushShape
  brushSize: number
  
  // Selected element
  selectedElement: ElementType
  
  // Actions
  setTool: (tool: ToolType) => void
  setBrushShape: (shape: BrushShape) => void
  setBrushSize: (size: number) => void
  setElement: (element: ElementType) => void
}

export const useToolStore = create<ToolState>((set) => ({
  // Initial state
  selectedTool: 'brush',
  brushShape: 'circle',
  brushSize: 10,
  selectedElement: 'sand',
  
  // Actions
  setTool: (selectedTool) => set({ selectedTool }),
  setBrushShape: (brushShape) => set({ brushShape }),
  setBrushSize: (brushSize) => set({ brushSize: Math.min(50, Math.max(1, brushSize)) }),
  setElement: (selectedElement) => set({ selectedElement, selectedTool: 'brush' }),
}))

--- End of File: apps/web/src/stores/toolStore.ts ---


--- File: packages/engine/src/behaviors/energy.rs ---

//! EnergyBehavior - Physics for energy particles (fire, spark, electricity)
//! 
//! Port from: apps/web/src/lib/engine/behaviors/EnergyBehavior.ts
//! PHASE 1: Optimized with unsafe access after bounds check
//! 
//! Fire rises erratically, spark/electricity move through conductors

use super::{Behavior, UpdateContext};
use crate::elements::{EL_EMPTY, EL_FIRE, EL_SPARK, EL_ELECTRICITY};

pub struct EnergyBehavior;

impl EnergyBehavior {
    pub fn new() -> Self {
        Self
    }
    
    /// Fire rises erratically (mirrors TypeScript updateFire)
    /// PHASE 1: Uses unsafe after bounds check
    #[inline]
    fn update_fire(&self, ctx: &mut UpdateContext) {
        let x = ctx.x;
        let y = ctx.y;
        let xi = x as i32;
        let yi = y as i32;
        
        // Fire rises erratically (EXACT TypeScript: const rand = (frame * x * y) & 3)
        let rand = (ctx.frame as u32).wrapping_mul(x).wrapping_mul(y) & 3;
        
        match rand {
            0 => {
                let ty = yi - 1;
                if ctx.grid.in_bounds(xi, ty) {
                    // SAFETY: We just checked in_bounds
                    let target = unsafe { ctx.grid.get_type_unchecked(x, ty as u32) };
                    if target == EL_EMPTY {
                        unsafe { ctx.grid.swap_unchecked(x, y, x, ty as u32); }
                    }
                }
            }
            1 => {
                let tx = xi - 1;
                let ty = yi - 1;
                if ctx.grid.in_bounds(tx, ty) {
                    let target = unsafe { ctx.grid.get_type_unchecked(tx as u32, ty as u32) };
                    if target == EL_EMPTY {
                        unsafe { ctx.grid.swap_unchecked(x, y, tx as u32, ty as u32); }
                    }
                }
            }
            2 => {
                let tx = xi + 1;
                let ty = yi - 1;
                if ctx.grid.in_bounds(tx, ty) {
                    let target = unsafe { ctx.grid.get_type_unchecked(tx as u32, ty as u32) };
                    if target == EL_EMPTY {
                        unsafe { ctx.grid.swap_unchecked(x, y, tx as u32, ty as u32); }
                    }
                }
            }
            _ => {}
        }
    }
    
    /// Spark is handled by lifetime, no movement (mirrors TypeScript)
    #[inline]
    fn update_spark(&self, _ctx: &mut UpdateContext) {
        // Spark is handled by lifetime, no movement needed
    }
    
    /// Electricity is handled by lifetime (mirrors TypeScript)
    #[inline]
    fn update_electricity(&self, _ctx: &mut UpdateContext) {
        // Electricity is handled by lifetime
    }
}

impl Behavior for EnergyBehavior {
    fn update(&self, ctx: &mut UpdateContext) {
        // SAFETY: x,y come from update_particle_chunked which guarantees valid coords
        let element = unsafe { ctx.grid.get_type_unchecked(ctx.x, ctx.y) };
        if element == EL_EMPTY { return; }
        
        match element {
            EL_FIRE => self.update_fire(ctx),
            EL_SPARK => self.update_spark(ctx),
            EL_ELECTRICITY => self.update_electricity(ctx),
            _ => {}
        }
    }
}

--- End of File: packages/engine/src/behaviors/energy.rs ---


--- File: packages/engine/src/behaviors/gas.rs ---

//! GasBehavior - Pure dispersion-based gas physics
//! 
//! Port from: apps/web/src/lib/engine/behaviors/GasBehavior.ts
//! PHASE 1: Optimized with unsafe access after bounds check
//! 
//! Philosophy:
//! - Gases are "inverted liquids" - they rise instead of fall
//! - Scan & teleport horizontally to find "chimneys" (openings above)
//! - Can bubble up through liquids and powders (density-based)

use super::{Behavior, UpdateContext, get_random_dir, xorshift32};
use crate::elements::{ELEMENT_DATA, EL_EMPTY, CAT_SOLID};

/// Result of scanning ceiling for chimneys
struct ScanResult {
    found: bool,
    x: i32,
    has_chimney: bool,
}

pub struct GasBehavior;

impl GasBehavior {
    pub fn new() -> Self {
        Self
    }
    
    /// Try to rise to target cell (mirrors TypeScript tryRise)
    /// PHASE 1: Uses unsafe after bounds check
    #[inline]
    fn try_rise(&self, ctx: &mut UpdateContext, from_x: u32, from_y: u32, to_x: i32, to_y: i32, my_density: f32) -> bool {
        if !ctx.grid.in_bounds(to_x, to_y) { return false; }
        
        // SAFETY: We just checked in_bounds above
        let target_type = unsafe { ctx.grid.get_type_unchecked(to_x as u32, to_y as u32) };
        
        // Empty cell - just rise
        if target_type == EL_EMPTY {
            unsafe { ctx.grid.swap_unchecked(from_x, from_y, to_x as u32, to_y as u32); }
            return true;
        }
        
        // Bounds check
        if (target_type as usize) >= ELEMENT_DATA.len() { return false; }
        
        // Can we bubble through? (target must be heavier and not solid)
        let t_cat = ELEMENT_DATA[target_type as usize].category;
        
        if t_cat != CAT_SOLID {
            let t_density = ELEMENT_DATA[target_type as usize].density;
            if t_density > my_density {
                unsafe { ctx.grid.swap_unchecked(from_x, from_y, to_x as u32, to_y as u32); }
                return true;
            }
        }
        
        false
    }
    
    /// Scan ceiling for chimneys (mirrors TypeScript scanCeiling)
    /// PHASE 1: Uses unsafe after bounds check
    #[inline]
    fn scan_ceiling(&self, ctx: &UpdateContext, start_x: i32, y: i32, dir: i32, range: i32, my_density: f32) -> ScanResult {
        let mut best_x = start_x;
        let mut found = false;
        let mut has_chimney = false;
        
        for i in 1..=range {
            let tx = start_x + (dir * i);
            
            if !ctx.grid.in_bounds(tx, y) { break; }
            
            // SAFETY: We just checked in_bounds above
            let target_type = unsafe { ctx.grid.get_type_unchecked(tx as u32, y as u32) };
            
            // CASE 1: Empty cell
            if target_type == EL_EMPTY {
                best_x = tx;
                found = true;
                
                // Check for chimney above
                let above_y = y - 1;
                if ctx.grid.in_bounds(tx, above_y) {
                    // SAFETY: We just checked in_bounds above
                    let above_type = unsafe { ctx.grid.get_type_unchecked(tx as u32, above_y as u32) };
                    if above_type == EL_EMPTY {
                        has_chimney = true;
                        break;
                    }
                    if (above_type as usize) < ELEMENT_DATA.len() {
                        if ELEMENT_DATA[above_type as usize].density > my_density {
                            has_chimney = true;
                            break;
                        }
                    }
                }
                continue;
            }
            
            // Bounds check
            if (target_type as usize) >= ELEMENT_DATA.len() { break; }
            
            // CASE 2: Occupied - can we displace it?
            let t_cat = ELEMENT_DATA[target_type as usize].category;
            
            if t_cat != CAT_SOLID {
                let t_density = ELEMENT_DATA[target_type as usize].density;
                if t_density > my_density {
                    best_x = tx;
                    found = true;
                    break;
                }
            }
            
            // CASE 3: Wall or lighter/same gas - stop
            break;
        }
        
        ScanResult { found, x: best_x, has_chimney }
    }
}

impl Behavior for GasBehavior {
    fn update(&self, ctx: &mut UpdateContext) {
        let x = ctx.x;
        let y = ctx.y;
        let xi = x as i32;
        let yi = y as i32;
        
        // SAFETY: x,y come from update_particle_chunked which guarantees valid coords
        let element = unsafe { ctx.grid.get_type_unchecked(x, y) };
        if element == EL_EMPTY { return; }
        if (element as usize) >= ELEMENT_DATA.len() { return; }
        
        let props = &ELEMENT_DATA[element as usize];
        let density = props.density;
        // Match TypeScript: props.dispersion || 5 (fallback to 5 if 0)
        let range = if props.dispersion > 0 { props.dispersion as i32 } else { 5 };
        
        let (dx1, dx2) = get_random_dir(ctx.frame, x);
        
        // --- 1. Rise UP (against gravity) ---
        if self.try_rise(ctx, x, y, xi, yi - 1, density) { return; }
        
        // --- 2. Rise DIAGONALLY ---
        if self.try_rise(ctx, x, y, xi + dx1, yi - 1, density) { return; }
        if self.try_rise(ctx, x, y, xi + dx2, yi - 1, density) { return; }
        
        // --- 3. Dispersion: Scan ceiling for chimneys (EXACT TypeScript) ---
        let left_target = self.scan_ceiling(ctx, xi, yi, -1, range, density);
        let right_target = self.scan_ceiling(ctx, xi, yi, 1, range, density);
        
        let target_x = if left_target.found && right_target.found {
            if left_target.has_chimney && !right_target.has_chimney {
                left_target.x
            } else if !left_target.has_chimney && right_target.has_chimney {
                right_target.x
            } else {
                // Random choice
                let rand = xorshift32(ctx.rng);
                if rand & 1 == 0 { left_target.x } else { right_target.x }
            }
        } else if left_target.found {
            left_target.x
        } else if right_target.found {
            right_target.x
        } else {
            xi
        };
        
        if target_x != xi {
            // SAFETY: target_x comes from scan_ceiling which verified bounds
            unsafe { ctx.grid.swap_unchecked(x, y, target_x as u32, y); }
        }
    }
}

--- End of File: packages/engine/src/behaviors/gas.rs ---


--- File: packages/engine/src/behaviors/liquid.rs ---

//! LiquidBehavior - Pure dispersion-based liquid physics
//! 
//! Port from: apps/web/src/lib/engine/behaviors/LiquidBehavior.ts
//! PHASE 1: Optimized with unsafe access after bounds check
//! 
//! Philosophy:
//! - No mass, no pressure formulas - just discrete particle movement
//! - Liquids "scan & teleport" up to N cells horizontally (dispersion rate)
//! - Prioritizes falling into holes/cliffs for waterfall effect
//! - Heavier liquids can push lighter ones horizontally for level equalization

use super::{Behavior, UpdateContext, get_random_dir, xorshift32};
use crate::elements::{ELEMENT_DATA, EL_EMPTY, CAT_LIQUID, CAT_GAS};

/// Result of scanning a horizontal line
struct ScanResult {
    found: bool,
    x: i32,
    has_cliff: bool,
}

pub struct LiquidBehavior;

impl LiquidBehavior {
    pub fn new() -> Self {
        Self
    }
    
    /// Try to move liquid to target cell (mirrors TypeScript tryMove)
    /// PHASE 1: Uses unsafe after bounds check
    #[inline]
    fn try_move(&self, ctx: &mut UpdateContext, from_x: u32, from_y: u32, to_x: i32, to_y: i32, my_density: f32) -> bool {
        if !ctx.grid.in_bounds(to_x, to_y) { return false; }
        
        // SAFETY: We just checked in_bounds above
        let target_type = unsafe { ctx.grid.get_type_unchecked(to_x as u32, to_y as u32) };
        
        // Empty cell - just move
        if target_type == EL_EMPTY {
            // SAFETY: Both coords verified (from_x/from_y from caller, to_x/to_y from in_bounds)
            unsafe { ctx.grid.swap_unchecked(from_x, from_y, to_x as u32, to_y as u32); }
            return true;
        }
        
        // Bounds check
        if (target_type as usize) >= ELEMENT_DATA.len() { return false; }
        
        // Check if we can displace (heavier sinks into lighter)
        let t_cat = ELEMENT_DATA[target_type as usize].category;
        if t_cat == CAT_LIQUID || t_cat == CAT_GAS {
            if my_density > ELEMENT_DATA[target_type as usize].density {
                unsafe { ctx.grid.swap_unchecked(from_x, from_y, to_x as u32, to_y as u32); }
                return true;
            }
        }
        
        false
    }
    
    /// Scan horizontally for empty cells or cliffs (mirrors TypeScript scanLine)
    /// PHASE 1: Uses unsafe after bounds check
    #[inline]
    fn scan_line(&self, ctx: &UpdateContext, start_x: i32, y: i32, dir: i32, range: i32, my_density: f32) -> ScanResult {
        let mut best_x = start_x;
        let mut found = false;
        let mut has_cliff = false;
        
        for i in 1..=range {
            let tx = start_x + (dir * i);
            
            if !ctx.grid.in_bounds(tx, y) { break; }
            
            // SAFETY: We just checked in_bounds above
            let target_type = unsafe { ctx.grid.get_type_unchecked(tx as u32, y as u32) };
            
            // CASE 1: Empty cell
            if target_type == EL_EMPTY {
                best_x = tx;
                found = true;
                
                // Check for cliff below (waterfall effect)
                let below_y = y + 1;
                if ctx.grid.in_bounds(tx, below_y) {
                    // SAFETY: We just checked in_bounds above
                    let below_type = unsafe { ctx.grid.get_type_unchecked(tx as u32, below_y as u32) };
                    if below_type == EL_EMPTY {
                        has_cliff = true;
                        break;
                    }
                }
                continue;
            }
            
            // Bounds check
            if (target_type as usize) >= ELEMENT_DATA.len() { break; }
            
            // CASE 2: Occupied cell - check if we can displace
            let t_cat = ELEMENT_DATA[target_type as usize].category;
            
            if t_cat == CAT_LIQUID || t_cat == CAT_GAS {
                let t_density = ELEMENT_DATA[target_type as usize].density;
                
                if my_density > t_density {
                    best_x = tx;
                    found = true;
                    break;
                }
            }
            
            // CASE 3: Wall or same/heavier liquid - stop scanning
            break;
        }
        
        ScanResult { found, x: best_x, has_cliff }
    }
}

impl Behavior for LiquidBehavior {
    fn update(&self, ctx: &mut UpdateContext) {
        let x = ctx.x;
        let y = ctx.y;
        let xi = x as i32;
        let yi = y as i32;
        
        // SAFETY: x,y come from update_particle_chunked which guarantees valid coords
        let element = unsafe { ctx.grid.get_type_unchecked(x, y) };
        if element == EL_EMPTY { return; }
        if (element as usize) >= ELEMENT_DATA.len() { return; }
        
        let props = &ELEMENT_DATA[element as usize];
        let density = props.density;
        // Match TypeScript: props.dispersion || 5 (fallback to 5 if 0)
        let range = if props.dispersion > 0 { props.dispersion as i32 } else { 5 };
        
        let (dx1, dx2) = get_random_dir(ctx.frame, x);
        
        // --- 1. Gravity: Fall Down ---
        if self.try_move(ctx, x, y, xi, yi + 1, density) { return; }
        
        // --- 2. Gravity: Fall Diagonally ---
        if self.try_move(ctx, x, y, xi + dx1, yi + 1, density) { return; }
        if self.try_move(ctx, x, y, xi + dx2, yi + 1, density) { return; }
        
        // --- 3. Dispersion: Scan & Teleport (EXACT TypeScript algorithm) ---
        let left_target = self.scan_line(ctx, xi, yi, -1, range, density);
        let right_target = self.scan_line(ctx, xi, yi, 1, range, density);
        
        // Choose best target (mirrors TypeScript logic exactly)
        let target_x = if left_target.found && right_target.found {
            if left_target.has_cliff && !right_target.has_cliff {
                left_target.x
            } else if !left_target.has_cliff && right_target.has_cliff {
                right_target.x
            } else {
                // Both have space - random choice (using frame + x for determinism)
                let rand = xorshift32(ctx.rng);
                if rand & 1 == 0 { left_target.x } else { right_target.x }
            }
        } else if left_target.found {
            left_target.x
        } else if right_target.found {
            right_target.x
        } else {
            xi // No movement
        };
        
        if target_x != xi {
            // SAFETY: target_x comes from scan_line which verified bounds
            unsafe { ctx.grid.swap_unchecked(x, y, target_x as u32, y); }
        }
    }
}

--- End of File: packages/engine/src/behaviors/liquid.rs ---


--- File: packages/engine/src/behaviors/mod.rs ---

//! Behaviors - Particle physics implementations
//! 
//! SOLID: Single Responsibility - each behavior handles one particle category
//! SOLID: Open/Closed - new behaviors can be added without modifying existing code
//! 
//! Port from TypeScript: apps/web/src/lib/engine/behaviors/

mod powder;
mod liquid;
mod gas;
mod energy;
mod utility;
mod plant;

pub use powder::PowderBehavior;
pub use liquid::LiquidBehavior;
pub use gas::GasBehavior;
pub use energy::EnergyBehavior;
pub use utility::UtilityBehavior;
pub use plant::PlantBehavior;

use crate::grid::Grid;
use crate::elements::{CategoryId, CAT_POWDER, CAT_LIQUID, CAT_GAS, CAT_ENERGY, CAT_UTILITY, CAT_BIO};

/// Update context passed to behaviors (mirrors TypeScript UpdateContext)
pub struct UpdateContext<'a> {
    pub grid: &'a mut Grid,
    pub x: u32,
    pub y: u32,
    pub frame: u64,
    pub gravity_x: f32,
    pub gravity_y: f32,
    pub ambient_temp: f32,
    pub rng: &'a mut u32,
}

/// Behavior trait - each category implements this
pub trait Behavior {
    fn update(&self, ctx: &mut UpdateContext);
}

/// Random direction helper (mirrors TypeScript getRandomDirection EXACTLY)
/// TS: const goLeft = (frame + x) & 1; dx1 = goLeft ? -1 : 1
#[inline]
pub fn get_random_dir(frame: u64, x: u32) -> (i32, i32) {
    // TypeScript: goLeft = (frame + x) & 1 -> if truthy (1) then left first
    let go_left = ((frame as u32 + x) & 1) == 1;
    if go_left { (-1, 1) } else { (1, -1) }
}

/// Xorshift32 random number generator
#[inline]
pub fn xorshift32(state: &mut u32) -> u32 {
    let mut x = *state;
    x ^= x << 13;
    x ^= x >> 17;
    x ^= x << 5;
    *state = x;
    x
}

/// Behavior registry - dispatch by category
pub struct BehaviorRegistry {
    powder: PowderBehavior,
    liquid: LiquidBehavior,
    gas: GasBehavior,
    energy: EnergyBehavior,
    utility: UtilityBehavior,
    plant: PlantBehavior,
}

impl BehaviorRegistry {
    pub fn new() -> Self {
        Self {
            powder: PowderBehavior::new(),
            liquid: LiquidBehavior::new(),
            gas: GasBehavior::new(),
            energy: EnergyBehavior::new(),
            utility: UtilityBehavior::new(),
            plant: PlantBehavior::new(),
        }
    }
    
    /// Dispatch update to appropriate behavior based on category
    pub fn update(&self, category: CategoryId, ctx: &mut UpdateContext) {
        match category {
            CAT_POWDER => self.powder.update(ctx),
            CAT_LIQUID => self.liquid.update(ctx),
            CAT_GAS => self.gas.update(ctx),
            CAT_ENERGY => self.energy.update(ctx),
            CAT_UTILITY => self.utility.update(ctx),
            CAT_BIO => self.plant.update(ctx),
            _ => {} // Solid - no behavior
        }
    }
}

impl Default for BehaviorRegistry {
    fn default() -> Self {
        Self::new()
    }
}

--- End of File: packages/engine/src/behaviors/mod.rs ---


--- File: packages/engine/src/behaviors/plant.rs ---

//! PlantBehavior - Agent-based plant growth system
//! 
//! Port from: apps/web/src/lib/engine/behaviors/PlantBehavior.ts
//! EXACT 1:1 port of the TypeScript algorithm
//! 
//! Seed: Falls like powder, germinates when touching dirt + water
//! Plant: Grows upward consuming water, affected by temperature

use super::{Behavior, UpdateContext, get_random_dir, xorshift32};
use crate::elements::{
    ELEMENT_DATA, EL_EMPTY, EL_SEED, EL_PLANT, EL_WATER, EL_DIRT, EL_SAND,
    CAT_LIQUID, get_color_with_variation
};

const SEED_DENSITY: f32 = 1100.0;

/// Grow options with weights (mirrors TypeScript exactly)
const GROW_OPTIONS: [(i32, i32, f32); 3] = [
    (0, -1, 0.6),   // Up - 60%
    (-1, -1, 0.2),  // Up-left - 20%
    (1, -1, 0.2),   // Up-right - 20%
];

pub struct PlantBehavior;

impl PlantBehavior {
    pub fn new() -> Self {
        Self
    }
    
    /// Check if seed can displace target (mirrors TypeScript canSeedDisplace)
    fn can_seed_displace(&self, ctx: &UpdateContext, x: i32, y: i32) -> bool {
        if !ctx.grid.in_bounds(x, y) { return false; }
        
        let target_type = ctx.grid.get_type(x, y);
        if target_type == EL_EMPTY { return true; }
        
        // Bounds check
        if (target_type as usize) >= ELEMENT_DATA.len() { return false; }
        
        let target_cat = ELEMENT_DATA[target_type as usize].category;
        if target_cat == CAT_LIQUID {
            return SEED_DENSITY > ELEMENT_DATA[target_type as usize].density;
        }
        
        false
    }
    
    /// Check if there's water nearby (mirrors TypeScript hasWaterNeighbor)
    fn has_water_neighbor(&self, ctx: &UpdateContext, x: i32, y: i32) -> bool {
        self.find_water(ctx, x, y, 1).is_some()
    }
    
    /// Find water within radius (mirrors TypeScript findWater)
    fn find_water(&self, ctx: &UpdateContext, cx: i32, cy: i32, radius: i32) -> Option<(i32, i32)> {
        for dy in -radius..=radius {
            for dx in -radius..=radius {
                let nx = cx + dx;
                let ny = cy + dy;
                if ctx.grid.in_bounds(nx, ny) {
                    if ctx.grid.get_type(nx, ny) == EL_WATER {
                        return Some((nx, ny));
                    }
                }
            }
        }
        None
    }
    
    /// Transform cell to plant (mirrors TypeScript transformToPlant)
    fn transform_to_plant(&self, ctx: &mut UpdateContext, x: i32, y: i32) {
        let seed = ((x as u32 * 11 + y as u32 * 17 + ctx.frame as u32) & 31) as u8;
        let props = &ELEMENT_DATA[EL_PLANT as usize];
        
        ctx.grid.set_particle(
            x as u32, y as u32,
            EL_PLANT,
            get_color_with_variation(EL_PLANT, seed),
            props.lifetime,
            20.0  // Room temperature
        );
    }
    
    /// Process seed behavior (mirrors TypeScript processSeed)
    fn process_seed(&self, ctx: &mut UpdateContext) {
        let x = ctx.x;
        let y = ctx.y;
        let xi = x as i32;
        let yi = y as i32;
        
        // 1. Gravity - fall down
        if self.can_seed_displace(ctx, xi, yi + 1) {
            ctx.grid.swap(x, y, x, y + 1);
            return;
        }
        
        // 2. Diagonal falling
        let (dx1, dx2) = get_random_dir(ctx.frame, x);
        if self.can_seed_displace(ctx, xi + dx1, yi + 1) {
            ctx.grid.swap(x, y, (xi + dx1) as u32, y + 1);
            return;
        }
        if self.can_seed_displace(ctx, xi + dx2, yi + 1) {
            ctx.grid.swap(x, y, (xi + dx2) as u32, y + 1);
            return;
        }
        
        // 3. Germination check (EXACT TypeScript logic)
        let below_type = ctx.grid.get_type(xi, yi + 1);
        if below_type == EL_DIRT || below_type == EL_SAND {
            if self.has_water_neighbor(ctx, xi, yi) {
                self.transform_to_plant(ctx, xi, yi);
            }
        }
    }
    
    /// Process plant behavior (mirrors TypeScript processPlant)
    fn process_plant(&self, ctx: &mut UpdateContext) {
        let x = ctx.x;
        let y = ctx.y;
        let xi = x as i32;
        let yi = y as i32;
        
        // Temperature affects growth
        let temp = ctx.grid.get_temp(xi, yi);
        
        // Too cold - no growth
        if temp < 0.0 { return; }
        
        // Too hot - burns
        if temp > 150.0 {
            ctx.grid.clear_cell(x, y);
            return;
        }
        
        // 5% chance to try growing each frame (EXACT TypeScript: Math.random() > 0.05)
        let rand = xorshift32(ctx.rng);
        if (rand % 100) > 5 { return; }
        
        // Check if can grow up
        let can_grow_up = ctx.grid.in_bounds(xi, yi - 1) && ctx.grid.is_empty(xi, yi - 1);
        
        if !can_grow_up {
            // 20% chance to try growing sideways (EXACT TypeScript: Math.random() > 0.2)
            let rand2 = xorshift32(ctx.rng);
            if (rand2 % 100) > 20 { return; }
        }
        
        // Find water within radius 3
        if let Some((wx, wy)) = self.find_water(ctx, xi, yi, 3) {
            // Consume water
            ctx.grid.clear_cell(wx as u32, wy as u32);
            
            // Choose grow direction using weighted random (EXACT TypeScript)
            let rand3 = xorshift32(ctx.rng);
            let rand_f = (rand3 % 1000) as f32 / 1000.0;
            
            let mut cumulative = 0.0;
            let mut chosen = GROW_OPTIONS[0];
            
            for opt in GROW_OPTIONS.iter() {
                cumulative += opt.2;
                if rand_f < cumulative {
                    chosen = *opt;
                    break;
                }
            }
            
            let gx = xi + chosen.0;
            let gy = yi + chosen.1;
            
            if ctx.grid.in_bounds(gx, gy) && ctx.grid.is_empty(gx, gy) {
                self.transform_to_plant(ctx, gx, gy);
            }
        }
    }
}

impl Behavior for PlantBehavior {
    fn update(&self, ctx: &mut UpdateContext) {
        let xi = ctx.x as i32;
        let yi = ctx.y as i32;
        
        let element = ctx.grid.get_type(xi, yi);
        if element == EL_EMPTY { return; }
        
        if element == EL_SEED {
            self.process_seed(ctx);
        } else if element == EL_PLANT {
            self.process_plant(ctx);
        }
    }
}

--- End of File: packages/engine/src/behaviors/plant.rs ---


--- File: packages/engine/src/behaviors/powder.rs ---

//! PowderBehavior - Physics for powder particles (sand, dirt, gunpowder)
//! 
//! Port from: apps/web/src/lib/engine/behaviors/PowderBehavior.ts
//! PHASE 1: Optimized with unsafe access after bounds check
//! 
//! Falls down, piles up, can sink into lighter liquids

use super::{Behavior, UpdateContext, get_random_dir};
use crate::elements::{ELEMENT_DATA, EL_EMPTY, CAT_LIQUID};

pub struct PowderBehavior;

impl PowderBehavior {
    pub fn new() -> Self {
        Self
    }
    
    /// Check if powder can move to target cell
    /// PHASE 1: Uses unsafe after bounds check to avoid double-checking
    #[inline]
    fn can_displace(&self, ctx: &UpdateContext, x: i32, y: i32, my_density: f32) -> bool {
        if !ctx.grid.in_bounds(x, y) { return false; }
        
        // SAFETY: We just checked in_bounds above
        let target_type = unsafe { ctx.grid.get_type_unchecked(x as u32, y as u32) };
        
        // Empty = can move
        if target_type == EL_EMPTY { return true; }
        
        // Check bounds for target element
        if (target_type as usize) >= ELEMENT_DATA.len() { return false; }
        
        let target_cat = ELEMENT_DATA[target_type as usize].category;
        
        // Can only displace liquids, not solids
        if target_cat != CAT_LIQUID { return false; }
        
        // Heavier sinks into lighter
        my_density > ELEMENT_DATA[target_type as usize].density
    }
}

impl Behavior for PowderBehavior {
    fn update(&self, ctx: &mut UpdateContext) {
        let x = ctx.x;
        let y = ctx.y;
        let xi = x as i32;
        let yi = y as i32;
        
        // SAFETY: x,y come from update_particle_chunked which guarantees valid coords
        let element = unsafe { ctx.grid.get_type_unchecked(x, y) };
        if element == EL_EMPTY { return; }
        if (element as usize) >= ELEMENT_DATA.len() { return; }
        
        let my_density = ELEMENT_DATA[element as usize].density;
        
        // Get gravity direction (from TypeScript getGravityDirection)
        let gx = if ctx.gravity_x > 0.0 { 1 } else if ctx.gravity_x < 0.0 { -1 } else { 0 };
        let gy = if ctx.gravity_y > 0.0 { 1 } else if ctx.gravity_y < 0.0 { -1 } else { 0 };
        
        // No gravity = no movement
        if gy == 0 && gx == 0 { return; }
        
        // 1. Try to fall in gravity direction
        let tx = xi + gx;
        let ty = yi + gy;
        if self.can_displace(ctx, tx, ty, my_density) {
            // SAFETY: can_displace verified bounds
            unsafe { ctx.grid.swap_unchecked(x, y, tx as u32, ty as u32); }
            return;
        }
        
        // 2. Try diagonal movement (mirrors TypeScript)
        let (dx1, dx2) = get_random_dir(ctx.frame, x);
        
        let tx1 = xi + dx1 + gx;
        if self.can_displace(ctx, tx1, ty, my_density) {
            unsafe { ctx.grid.swap_unchecked(x, y, tx1 as u32, ty as u32); }
            return;
        }
        
        let tx2 = xi + dx2 + gx;
        if self.can_displace(ctx, tx2, ty, my_density) {
            unsafe { ctx.grid.swap_unchecked(x, y, tx2 as u32, ty as u32); }
        }
    }
}

--- End of File: packages/engine/src/behaviors/powder.rs ---


--- File: packages/engine/src/behaviors/utility.rs ---

//! UtilityBehavior - Handles Clone and Void elements
//! 
//! Port from: apps/web/src/lib/engine/behaviors/UtilityBehavior.ts
//! EXACT 1:1 port of the TypeScript algorithm
//! 
//! Clone: Duplicates touching elements into empty neighbors
//! Void: Destroys all touching elements

use super::{Behavior, UpdateContext};
use crate::elements::{
    ELEMENT_DATA, ElementId, EL_EMPTY, EL_CLONE, EL_VOID, CAT_UTILITY,
    get_color_with_variation
};

/// Neighbor directions
const DIRECTIONS: [(i32, i32); 4] = [
    (0, -1),  // Up
    (0, 1),   // Down
    (-1, 0),  // Left
    (1, 0),   // Right
];

pub struct UtilityBehavior;

impl UtilityBehavior {
    pub fn new() -> Self {
        Self
    }
    
    /// VOID: Destroys all adjacent particles (except other utilities)
    /// Mirrors TypeScript processVoid exactly
    fn process_void(&self, ctx: &mut UpdateContext) {
        let x = ctx.x as i32;
        let y = ctx.y as i32;
        
        for (dx, dy) in DIRECTIONS.iter() {
            let nx = x + dx;
            let ny = y + dy;
            
            if !ctx.grid.in_bounds(nx, ny) { continue; }
            
            let neighbor_type = ctx.grid.get_type(nx, ny);
            
            // Don't destroy empty, void, or clone
            if neighbor_type != EL_EMPTY && neighbor_type != EL_VOID && neighbor_type != EL_CLONE {
                ctx.grid.clear_cell(nx as u32, ny as u32);
            }
        }
    }
    
    /// CLONE: Finds a donor element and copies it to empty adjacent cells
    /// Mirrors TypeScript processClone exactly
    fn process_clone(&self, ctx: &mut UpdateContext) {
        let x = ctx.x as i32;
        let y = ctx.y as i32;
        let frame = ctx.frame;
        
        // 1. Find a donor element (first non-utility neighbor)
        let mut source_type: ElementId = EL_EMPTY;
        
        for (dx, dy) in DIRECTIONS.iter() {
            let nx = x + dx;
            let ny = y + dy;
            
            if !ctx.grid.in_bounds(nx, ny) { continue; }
            
            let neighbor_type = ctx.grid.get_type(nx, ny);
            
            if neighbor_type != EL_EMPTY {
                // Bounds check
                if (neighbor_type as usize) >= ELEMENT_DATA.len() { continue; }
                
                let cat = ELEMENT_DATA[neighbor_type as usize].category;
                if cat != CAT_UTILITY {
                    source_type = neighbor_type;
                    break;
                }
            }
        }
        
        // No donor found
        if source_type == EL_EMPTY { return; }
        
        // 2. Clone into ONE empty adjacent cell (EXACT TypeScript: rotate start direction by frame)
        let start_dir = (frame % 4) as usize;
        
        for i in 0..4 {
            let dir_idx = (start_dir + i) % 4;
            let (dx, dy) = DIRECTIONS[dir_idx];
            let nx = x + dx;
            let ny = y + dy;
            
            if !ctx.grid.in_bounds(nx, ny) { continue; }
            if !ctx.grid.is_empty(nx, ny) { continue; }
            
            // Create cloned particle (mirrors TypeScript exactly)
            let seed = ((nx as u32 * 7 + ny as u32 * 13 + frame as u32) & 31) as u8;
            let props = &ELEMENT_DATA[source_type as usize];
            
            ctx.grid.set_particle(
                nx as u32, ny as u32,
                source_type,
                get_color_with_variation(source_type, seed),
                props.lifetime,
                props.default_temp
            );
            
            return; // Only clone ONE per frame!
        }
    }
}

impl Behavior for UtilityBehavior {
    fn update(&self, ctx: &mut UpdateContext) {
        let xi = ctx.x as i32;
        let yi = ctx.y as i32;
        
        let element = ctx.grid.get_type(xi, yi);
        if element == EL_EMPTY { return; }
        
        if element == EL_VOID {
            self.process_void(ctx);
        } else if element == EL_CLONE {
            self.process_clone(ctx);
        }
    }
}

--- End of File: packages/engine/src/behaviors/utility.rs ---


--- File: packages/engine/src/chunks.rs ---

//! Chunk System - Spatial optimization for particle simulation
//! 
//! Phase 4: Divide world into chunks (32x32) for:
//! - Skip processing of inactive/sleeping chunks
//! - O(active_chunks) instead of O(W*H)
//! - Wake neighbors when particles cross boundaries

/// Chunk size in pixels (32x32 is cache-friendly)
pub const CHUNK_SIZE: u32 = 32;

/// Number of frames before a chunk goes to sleep
/// Higher value = less aggressive sleeping, more correct behavior
const SLEEP_THRESHOLD: u32 = 30;

/// Chunk state
#[derive(Clone, Copy, PartialEq, Eq)]
pub enum ChunkState {
    /// Chunk has active particles that moved recently
    Active,
    /// Chunk is dormant - no movement for SLEEP_THRESHOLD frames
    Sleeping,
}

/// Manages chunk-based spatial optimization
pub struct ChunkGrid {
    /// Number of chunks horizontally
    chunks_x: u32,
    /// Number of chunks vertically  
    chunks_y: u32,
    /// Total number of chunks
    chunk_count: usize,
    
    /// Current state of each chunk
    state: Vec<ChunkState>,
    /// Dirty flag - chunk needs processing this frame
    dirty: Vec<bool>,
    /// Frames since last activity (for sleep detection)
    idle_frames: Vec<u32>,
    /// Number of non-empty cells in chunk (for quick empty check)
    particle_count: Vec<u32>,
    
    // === Lazy Hydration System ===
    /// Virtual temperature of air in each chunk (updated every frame, even sleeping)
    pub virtual_temp: Vec<f32>,
    /// Flag: chunk just woke up from sleep, needs temperature hydration
    pub just_woke_up: Vec<bool>,
    
    // === Visual Dirty (Phase 3 Fix: State Desync) ===
    /// Visual dirty flag - chunk needs RENDERING (separate from physics dirty)
    /// Cleared only when JS fetches the dirty list, not during physics!
    pub visual_dirty: Vec<bool>,
}

impl ChunkGrid {
    /// Create chunk grid for given world dimensions
    pub fn new(world_width: u32, world_height: u32) -> Self {
        let chunks_x = (world_width + CHUNK_SIZE - 1) / CHUNK_SIZE;
        let chunks_y = (world_height + CHUNK_SIZE - 1) / CHUNK_SIZE;
        let chunk_count = (chunks_x * chunks_y) as usize;
        
        Self {
            chunks_x,
            chunks_y,
            chunk_count,
            state: vec![ChunkState::Active; chunk_count],  // Start active
            dirty: vec![true; chunk_count],                 // All dirty initially
            idle_frames: vec![0; chunk_count],
            particle_count: vec![0; chunk_count],
            // Lazy Hydration: init with room temperature
            virtual_temp: vec![20.0; chunk_count],
            just_woke_up: vec![false; chunk_count],
            // Visual dirty: TRUE initially so first frame draws everything
            visual_dirty: vec![true; chunk_count],
        }
    }
    
    // === Chunk indexing ===
    
    /// Get chunk index from world coordinates
    #[inline]
    pub fn chunk_index(&self, x: u32, y: u32) -> usize {
        let cx = x / CHUNK_SIZE;
        let cy = y / CHUNK_SIZE;
        (cy * self.chunks_x + cx) as usize
    }
    
    /// Get chunk coordinates from world coordinates
    #[inline]
    pub fn chunk_coords(&self, x: u32, y: u32) -> (u32, u32) {
        (x / CHUNK_SIZE, y / CHUNK_SIZE)
    }
    
    /// Get chunk index from chunk coordinates
    #[inline]
    pub fn chunk_idx_from_coords(&self, cx: u32, cy: u32) -> usize {
        (cy * self.chunks_x + cx) as usize
    }
    
    /// Check if chunk coordinates are valid
    #[inline]
    pub fn chunk_in_bounds(&self, cx: i32, cy: i32) -> bool {
        cx >= 0 && cx < self.chunks_x as i32 && cy >= 0 && cy < self.chunks_y as i32
    }
    
    // === Dirty flag management ===
    
    /// Mark chunk as dirty (needs processing)
    /// Lazy Hydration: detects Sleep -> Active transition
    #[inline]
    pub fn mark_dirty(&mut self, x: u32, y: u32) {
        let idx = self.chunk_index(x, y);
        // Catch the wake-up moment for temperature hydration!
        if self.state[idx] == ChunkState::Sleeping {
            self.just_woke_up[idx] = true;
        }
        self.dirty[idx] = true;
        self.idle_frames[idx] = 0;
        self.state[idx] = ChunkState::Active;
    }
    
    /// Mark chunk as dirty by chunk index
    /// Lazy Hydration: detects Sleep -> Active transition
    /// Also marks visual_dirty for renderer!
    #[inline]
    pub fn mark_dirty_idx(&mut self, idx: usize) {
        if idx < self.chunk_count {
            // Catch the wake-up moment for temperature hydration!
            if self.state[idx] == ChunkState::Sleeping {
                self.just_woke_up[idx] = true;
            }
            self.dirty[idx] = true;
            self.visual_dirty[idx] = true; // IMPORTANT: Mark for rendering too!
            self.idle_frames[idx] = 0;
            self.state[idx] = ChunkState::Active;
        }
    }
    
    /// Check if chunk needs processing
    #[inline]
    pub fn is_dirty(&self, cx: u32, cy: u32) -> bool {
        let idx = self.chunk_idx_from_coords(cx, cy);
        self.dirty[idx]
    }
    
    /// Check if chunk is sleeping
    #[inline]
    pub fn is_sleeping(&self, cx: u32, cy: u32) -> bool {
        let idx = self.chunk_idx_from_coords(cx, cy);
        self.state[idx] == ChunkState::Sleeping
    }
    
    /// Should we process this chunk?
    /// Phase 4.1: Now properly tracks particle movements!
    #[inline]
    pub fn should_process(&self, cx: u32, cy: u32) -> bool {
        let idx = self.chunk_idx_from_coords(cx, cy);
        // Process if:
        // 1. Dirty (explicitly marked for update - e.g., neighbor woke us)
        // 2. Has particles (they might need to move)
        self.dirty[idx] || self.particle_count[idx] > 0
    }
    
    // === Wake neighbors ===
    
    /// Wake chunk and its neighbors (called when particle moves near boundary)
    pub fn wake_neighbors(&mut self, x: u32, y: u32) {
        let (cx, cy) = self.chunk_coords(x, y);
        let cxi = cx as i32;
        let cyi = cy as i32;
        
        // Check if near chunk boundary (within 2 pixels)
        let local_x = x % CHUNK_SIZE;
        let local_y = y % CHUNK_SIZE;
        
        let near_left = local_x < 2;
        let near_right = local_x >= CHUNK_SIZE - 2;
        let near_top = local_y < 2;
        let near_bottom = local_y >= CHUNK_SIZE - 2;
        
        // Wake adjacent chunks if near boundary
        if near_left && self.chunk_in_bounds(cxi - 1, cyi) {
            self.mark_dirty_idx(self.chunk_idx_from_coords((cxi - 1) as u32, cy));
        }
        if near_right && self.chunk_in_bounds(cxi + 1, cyi) {
            self.mark_dirty_idx(self.chunk_idx_from_coords((cxi + 1) as u32, cy));
        }
        if near_top && self.chunk_in_bounds(cxi, cyi - 1) {
            self.mark_dirty_idx(self.chunk_idx_from_coords(cx, (cyi - 1) as u32));
        }
        if near_bottom && self.chunk_in_bounds(cxi, cyi + 1) {
            self.mark_dirty_idx(self.chunk_idx_from_coords(cx, (cyi + 1) as u32));
        }
        
        // Diagonals
        if near_left && near_top && self.chunk_in_bounds(cxi - 1, cyi - 1) {
            self.mark_dirty_idx(self.chunk_idx_from_coords((cxi - 1) as u32, (cyi - 1) as u32));
        }
        if near_right && near_top && self.chunk_in_bounds(cxi + 1, cyi - 1) {
            self.mark_dirty_idx(self.chunk_idx_from_coords((cxi + 1) as u32, (cyi - 1) as u32));
        }
        if near_left && near_bottom && self.chunk_in_bounds(cxi - 1, cyi + 1) {
            self.mark_dirty_idx(self.chunk_idx_from_coords((cxi - 1) as u32, (cyi + 1) as u32));
        }
        if near_right && near_bottom && self.chunk_in_bounds(cxi + 1, cyi + 1) {
            self.mark_dirty_idx(self.chunk_idx_from_coords((cxi + 1) as u32, (cyi + 1) as u32));
        }
    }
    
    // === Particle count tracking ===
    
    /// Increment particle count in chunk
    #[inline]
    pub fn add_particle(&mut self, x: u32, y: u32) {
        let idx = self.chunk_index(x, y);
        self.particle_count[idx] += 1;
        self.mark_dirty_idx(idx);
    }
    
    /// Decrement particle count in chunk
    #[inline]
    pub fn remove_particle(&mut self, x: u32, y: u32) {
        let idx = self.chunk_index(x, y);
        if self.particle_count[idx] > 0 {
            self.particle_count[idx] -= 1;
        }
    }
    
    /// Move particle between chunks (if crossing boundary)
    #[inline]
    pub fn move_particle(&mut self, from_x: u32, from_y: u32, to_x: u32, to_y: u32) {
        let from_idx = self.chunk_index(from_x, from_y);
        let to_idx = self.chunk_index(to_x, to_y);
        
        if from_idx != to_idx {
            // Crossed chunk boundary
            if self.particle_count[from_idx] > 0 {
                self.particle_count[from_idx] -= 1;
            }
            self.particle_count[to_idx] += 1;
            self.mark_dirty_idx(to_idx);
        }
        
        // Wake neighbors at destination
        self.wake_neighbors(to_x, to_y);
    }
    
    // === Frame update ===
    
    /// Called at start of each frame - prepare for processing
    pub fn begin_frame(&mut self) {
        // Dirty flags are preserved from previous frame
        // They get cleared as chunks are processed
    }
    
    /// Called after processing a chunk
    /// Sets visual_dirty if movement occurred (for renderer to pick up)
    pub fn end_chunk_update(&mut self, cx: u32, cy: u32, had_movement: bool) {
        let idx = self.chunk_idx_from_coords(cx, cy);
        
        if had_movement {
            self.idle_frames[idx] = 0;
            self.state[idx] = ChunkState::Active;
            self.visual_dirty[idx] = true; // CRITICAL: Mark for render!
            
            // CRITICAL: Wake chunk BELOW us (particles fall down!)
            let cyi = cy as i32;
            if self.chunk_in_bounds(cx as i32, cyi + 1) {
                let below_idx = self.chunk_idx_from_coords(cx, cy + 1);
                self.dirty[below_idx] = true;
                self.visual_dirty[below_idx] = true; // Also mark below for render
                self.state[below_idx] = ChunkState::Active;
                self.idle_frames[below_idx] = 0;
            }
        } else {
            self.idle_frames[idx] += 1;
            // Only sleep if no particles in chunk
            if self.idle_frames[idx] >= SLEEP_THRESHOLD && self.particle_count[idx] == 0 {
                self.state[idx] = ChunkState::Sleeping;
            }
        }
        
        // Clear PHYSICS dirty flag after processing
        // NOTE: visual_dirty is NOT cleared here - it waits for JS to fetch it!
        self.dirty[idx] = false;
    }
    
    /// Clear visual dirty flag (called by World when JS fetches dirty list)
    #[inline]
    pub fn clear_visual_dirty(&mut self, idx: usize) {
        if idx < self.chunk_count {
            self.visual_dirty[idx] = false;
        }
    }
    
    /// Reset all chunks to active (e.g., after clear)
    pub fn reset(&mut self) {
        self.state.fill(ChunkState::Active);
        self.dirty.fill(true);
        self.visual_dirty.fill(true); // Reset visual dirty for full redraw
        self.idle_frames.fill(0);
        self.particle_count.fill(0);
        self.virtual_temp.fill(20.0);
        self.just_woke_up.fill(false);
    }
    
    // === Lazy Hydration Methods ===
    
    /// Get virtual temperature for chunk
    #[inline]
    pub fn get_virtual_temp(&self, cx: u32, cy: u32) -> f32 {
        let idx = self.chunk_idx_from_coords(cx, cy);
        self.virtual_temp[idx]
    }
    
    /// Update virtual temperature smoothly (lerp towards target)
    #[inline]
    pub fn update_virtual_temp(&mut self, cx: u32, cy: u32, target_temp: f32, speed: f32) {
        let idx = self.chunk_idx_from_coords(cx, cy);
        let current = self.virtual_temp[idx];
        let diff = target_temp - current;
        if diff.abs() > 0.01 {
            self.virtual_temp[idx] += diff * speed;
        } else {
            self.virtual_temp[idx] = target_temp;
        }
    }
    
    /// Set virtual temperature directly (for sync after active processing)
    #[inline]
    pub fn set_virtual_temp(&mut self, cx: u32, cy: u32, temp: f32) {
        let idx = self.chunk_idx_from_coords(cx, cy);
        self.virtual_temp[idx] = temp;
    }
    
    /// Clear wake-up flags after processing hydration
    pub fn clear_wake_flags(&mut self) {
        self.just_woke_up.fill(false);
    }
    
    // === Statistics ===
    
    /// Get number of active (non-sleeping) chunks
    pub fn active_chunk_count(&self) -> usize {
        self.state.iter().filter(|&&s| s == ChunkState::Active).count()
    }
    
    /// Get number of dirty chunks
    pub fn dirty_chunk_count(&self) -> usize {
        self.dirty.iter().filter(|&&d| d).count()
    }
    
    /// Get total chunk count
    pub fn total_chunks(&self) -> usize {
        self.chunk_count
    }
    
    /// Get chunks dimensions
    pub fn dimensions(&self) -> (u32, u32) {
        (self.chunks_x, self.chunks_y)
    }
}

/// Iterator over chunks that need processing
pub struct ActiveChunkIterator {
    chunks_x: u32,
    chunks_y: u32,
    current: usize,
    dirty: Vec<bool>,
    active: Vec<bool>,
}

impl ChunkGrid {
    /// Get iterator over chunks that should be processed
    pub fn active_chunks(&self) -> impl Iterator<Item = (u32, u32)> + '_ {
        let chunks_x = self.chunks_x;
        (0..self.chunk_count).filter_map(move |idx| {
            if self.dirty[idx] || (self.particle_count[idx] > 0 && self.state[idx] == ChunkState::Active) {
                let cx = (idx as u32) % chunks_x;
                let cy = (idx as u32) / chunks_x;
                Some((cx, cy))
            } else {
                None
            }
        })
    }
}

--- End of File: packages/engine/src/chunks.rs ---


--- File: packages/engine/src/elements.rs ---

use wasm_bindgen::prelude::*;

/// Element ID as u8 for compact storage
pub type ElementId = u8;

// Element constants matching TypeScript
pub const EL_EMPTY: ElementId = 0;
pub const EL_STONE: ElementId = 1;
pub const EL_SAND: ElementId = 2;
pub const EL_WOOD: ElementId = 3;
pub const EL_METAL: ElementId = 4;
pub const EL_ICE: ElementId = 5;
pub const EL_WATER: ElementId = 6;
pub const EL_OIL: ElementId = 7;
pub const EL_LAVA: ElementId = 8;
pub const EL_ACID: ElementId = 9;
pub const EL_STEAM: ElementId = 10;
pub const EL_SMOKE: ElementId = 11;
pub const EL_FIRE: ElementId = 12;
pub const EL_SPARK: ElementId = 13;
pub const EL_ELECTRICITY: ElementId = 14;
pub const EL_GUNPOWDER: ElementId = 15;
pub const EL_CLONE: ElementId = 16;
pub const EL_VOID: ElementId = 17;
pub const EL_DIRT: ElementId = 18;
pub const EL_SEED: ElementId = 19;
pub const EL_PLANT: ElementId = 20;
pub const ELEMENT_COUNT: usize = 21;

// Category IDs
pub type CategoryId = u8;
pub const CAT_SOLID: CategoryId = 0;
pub const CAT_POWDER: CategoryId = 1;
pub const CAT_LIQUID: CategoryId = 2;
pub const CAT_GAS: CategoryId = 3;
pub const CAT_ENERGY: CategoryId = 4;
pub const CAT_UTILITY: CategoryId = 5;
pub const CAT_BIO: CategoryId = 6;

/// Element properties struct
#[derive(Clone, Copy)]
pub struct ElementProps {
    pub color: u32,
    pub density: f32,
    pub category: CategoryId,
    pub dispersion: u8,
    pub lifetime: u16,
    pub default_temp: f32,
    pub heat_conductivity: u8,
    pub flammable: bool,
    pub conductive: bool,
}

/// Static element data - indexed by ElementId
pub static ELEMENT_DATA: [ElementProps; ELEMENT_COUNT] = [
    // 0: Empty
    ElementProps { color: 0xFF0A0A0A, density: 0.0, category: CAT_SOLID, dispersion: 0, lifetime: 0, default_temp: 20.0, heat_conductivity: 5, flammable: false, conductive: false },
    // 1: Stone
    ElementProps { color: 0xFF808080, density: 2500.0, category: CAT_SOLID, dispersion: 0, lifetime: 0, default_temp: 20.0, heat_conductivity: 10, flammable: false, conductive: false },
    // 2: Sand
    ElementProps { color: 0xFFC2B280, density: 1600.0, category: CAT_POWDER, dispersion: 0, lifetime: 0, default_temp: 20.0, heat_conductivity: 15, flammable: false, conductive: false },
    // 3: Wood
    ElementProps { color: 0xFF8B4513, density: 600.0, category: CAT_SOLID, dispersion: 0, lifetime: 0, default_temp: 20.0, heat_conductivity: 5, flammable: true, conductive: false },
    // 4: Metal
    ElementProps { color: 0xFFA9A9A9, density: 7800.0, category: CAT_SOLID, dispersion: 0, lifetime: 0, default_temp: 20.0, heat_conductivity: 90, flammable: false, conductive: true },
    // 5: Ice
    ElementProps { color: 0xFFA5F2F3, density: 916.0, category: CAT_SOLID, dispersion: 0, lifetime: 0, default_temp: -10.0, heat_conductivity: 20, flammable: false, conductive: false },
    // 6: Water
    ElementProps { color: 0xFF4169E1, density: 1000.0, category: CAT_LIQUID, dispersion: 8, lifetime: 0, default_temp: 20.0, heat_conductivity: 40, flammable: false, conductive: true },
    // 7: Oil
    ElementProps { color: 0xFF4A4A2A, density: 800.0, category: CAT_LIQUID, dispersion: 5, lifetime: 0, default_temp: 20.0, heat_conductivity: 15, flammable: true, conductive: false },
    // 8: Lava
    ElementProps { color: 0xFFFF4500, density: 2500.0, category: CAT_LIQUID, dispersion: 2, lifetime: 0, default_temp: 1000.0, heat_conductivity: 30, flammable: false, conductive: false },
    // 9: Acid
    ElementProps { color: 0xFF39FF14, density: 1050.0, category: CAT_LIQUID, dispersion: 5, lifetime: 0, default_temp: 20.0, heat_conductivity: 35, flammable: false, conductive: true },
    // 10: Steam
    ElementProps { color: 0xB4E0E0E0, density: 0.6, category: CAT_GAS, dispersion: 6, lifetime: 0, default_temp: 100.0, heat_conductivity: 10, flammable: false, conductive: false },
    // 11: Smoke
    ElementProps { color: 0xC83F3F3F, density: 1.1, category: CAT_GAS, dispersion: 4, lifetime: 0, default_temp: 50.0, heat_conductivity: 5, flammable: false, conductive: false },
    // 12: Fire
    ElementProps { color: 0xFFFF6600, density: 0.3, category: CAT_ENERGY, dispersion: 0, lifetime: 60, default_temp: 800.0, heat_conductivity: 50, flammable: false, conductive: false },
    // 13: Spark
    ElementProps { color: 0xFFFFFF00, density: 0.1, category: CAT_ENERGY, dispersion: 0, lifetime: 10, default_temp: 500.0, heat_conductivity: 50, flammable: false, conductive: false },
    // 14: Electricity
    ElementProps { color: 0xFF00FFFF, density: 0.0, category: CAT_ENERGY, dispersion: 0, lifetime: 3, default_temp: 200.0, heat_conductivity: 80, flammable: false, conductive: false },
    // 15: Gunpowder
    ElementProps { color: 0xFF404040, density: 1400.0, category: CAT_POWDER, dispersion: 0, lifetime: 0, default_temp: 20.0, heat_conductivity: 10, flammable: true, conductive: false },
    // 16: Clone
    ElementProps { color: 0xFF00FF00, density: f32::INFINITY, category: CAT_UTILITY, dispersion: 0, lifetime: 0, default_temp: 20.0, heat_conductivity: 0, flammable: false, conductive: false },
    // 17: Void
    ElementProps { color: 0xFF000000, density: f32::INFINITY, category: CAT_UTILITY, dispersion: 0, lifetime: 0, default_temp: 20.0, heat_conductivity: 0, flammable: false, conductive: false },
    // 18: Dirt
    ElementProps { color: 0xFF5C4033, density: 1200.0, category: CAT_POWDER, dispersion: 0, lifetime: 0, default_temp: 20.0, heat_conductivity: 10, flammable: false, conductive: false },
    // 19: Seed
    ElementProps { color: 0xFFE2C489, density: 1100.0, category: CAT_BIO, dispersion: 0, lifetime: 0, default_temp: 20.0, heat_conductivity: 5, flammable: true, conductive: false },
    // 20: Plant
    ElementProps { color: 0xFF228B22, density: 900.0, category: CAT_BIO, dispersion: 0, lifetime: 0, default_temp: 20.0, heat_conductivity: 10, flammable: true, conductive: false },
];

/// Get element properties by ID
#[inline]
pub fn get_props(id: ElementId) -> &'static ElementProps {
    &ELEMENT_DATA[id as usize]
}

/// Get color with variation - EXACT TypeScript algorithm
/// Phase 5: Returns ABGR format for direct copy to Canvas ImageData!
/// On little-endian: u32 0xAABBGGRR -> bytes [RR, GG, BB, AA] = RGBA in ImageData
pub fn get_color_with_variation(id: ElementId, seed: u8) -> u32 {
    let base = ELEMENT_DATA[id as usize].color;
    // Match TypeScript: (seed & 31) gives 0-31, then (i - 16) * 2 gives -32 to +30
    let i = (seed & 31) as i32;
    let variation = (i - 16) * 2;
    
    // Extract ARGB from base color
    let a = (base >> 24) & 0xFF;
    let r = (((base >> 16) & 0xFF) as i32 + variation).clamp(0, 255) as u32;
    let g = (((base >> 8) & 0xFF) as i32 + variation).clamp(0, 255) as u32;
    let b = ((base & 0xFF) as i32 + variation).clamp(0, 255) as u32;
    
    // Return ABGR format for Canvas ImageData (little-endian)
    (a << 24) | (b << 16) | (g << 8) | r
}

// Legacy enum for JS compatibility
#[wasm_bindgen]
#[repr(u8)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum ElementType {
    Empty = 0,
    Stone = 1,
    Sand = 2,
    Wood = 3,
    Metal = 4,
    Ice = 5,
    Water = 6,
    Oil = 7,
    Lava = 8,
    Acid = 9,
    Steam = 10,
    Smoke = 11,
    Fire = 12,
    Spark = 13,
    Electricity = 14,
    Gunpowder = 15,
    Clone = 16,
    Void = 17,
    Dirt = 18,
    Seed = 19,
    Plant = 20,
}

impl ElementType {
    /// Convert enum to ElementId
    pub fn to_id(self) -> ElementId {
        self as ElementId
    }
    
    /// Get properties for this element type
    pub fn props(self) -> &'static ElementProps {
        get_props(self as ElementId)
    }
}

--- End of File: packages/engine/src/elements.rs ---


--- File: packages/engine/src/grid.rs ---

//! Grid - Structure of Arrays (SoA) for cache-friendly particle storage
//! 
//! Phase 5: ABGR color format for direct Canvas copy
//! 
//! Instead of: Vec<Option<Particle>>  // Bad: many allocations, poor cache
//! We have:    types[], colors[], temps[]  // Good: linear memory, SIMD-friendly

use crate::elements::{ElementId, EL_EMPTY};
use crate::chunks::CHUNK_SIZE;

// Background color in ABGR format (little-endian: 0xAABBGGRR -> bytes [RR,GG,BB,AA])
// RGB(10,10,10) with alpha=255 -> 0xFF0A0A0A in ABGR
const BG_COLOR: u32 = 0xFF0A0A0A; // Same value since R=G=B

/// Recorded particle movement (from_x, from_y, to_x, to_y)
pub type ParticleMove = (u32, u32, u32, u32);

// === PHASE 4: ZERO-ALLOCATION MOVE BUFFER ===
// Fixed-size buffer that never reallocates. GC killer!

/// Fixed-capacity move buffer - allocated once, reused forever
pub struct MoveBuffer {
    data: Vec<ParticleMove>,
    pub count: usize,
    capacity: usize,
}

impl MoveBuffer {
    pub fn new(capacity: usize) -> Self {
        Self {
            data: vec![(0, 0, 0, 0); capacity], // Single allocation at startup
            count: 0,
            capacity,
        }
    }
    
    /// Push move - drops silently if buffer full (1 frame desync is invisible)
    #[inline(always)]
    pub fn push(&mut self, m: ParticleMove) {
        if self.count < self.capacity {
            // SAFETY: We just checked bounds above
            unsafe {
                *self.data.get_unchecked_mut(self.count) = m;
            }
            self.count += 1;
        }
        // If full, silently drop. Better than GC stutter!
    }
    
    /// Reset counter - memory stays allocated
    #[inline(always)]
    pub fn clear(&mut self) {
        self.count = 0;
    }
    
    /// Get raw pointer to data for unsafe iteration
    #[inline(always)]
    pub fn as_ptr(&self) -> *const ParticleMove {
        self.data.as_ptr()
    }
}

/// SoA Grid - all particle data in separate arrays
pub struct Grid {
    width: u32,
    height: u32,
    size: usize,
    
    // Structure of Arrays - each property in its own contiguous array
    pub types: Vec<ElementId>,      // Element type (0 = empty)
    pub colors: Vec<u32>,           // ABGR packed color
    pub life: Vec<u16>,             // Remaining lifetime (0 = infinite)
    pub updated: Vec<u8>,           // 0 = not updated, 1 = updated this frame
    pub temperature: Vec<f32>,      // Temperature in Â°C
    
    // Phase 4: Zero-allocation move buffer
    pub pending_moves: MoveBuffer,
}

impl Grid {
    pub fn new(width: u32, height: u32) -> Self {
        let size = (width * height) as usize;
        
        Self {
            width,
            height,
            size,
            types: vec![EL_EMPTY; size],
            colors: vec![BG_COLOR; size],
            life: vec![0; size],
            updated: vec![0; size],
            temperature: vec![20.0; size],
            // Phase 4: Fixed buffer for ~100k moves (~1.6MB RAM)
            // Enough for nuclear explosions, never reallocates!
            pending_moves: MoveBuffer::new(100_000),
        }
    }
    
    // === Dimensions ===
    #[inline]
    pub fn width(&self) -> u32 { self.width }
    
    #[inline]
    pub fn height(&self) -> u32 { self.height }
    
    #[inline]
    pub fn size(&self) -> usize { self.size }
    
    // === Index conversion ===
    #[inline]
    pub fn index(&self, x: u32, y: u32) -> usize {
        (y * self.width + x) as usize
    }
    
    #[inline]
    pub fn coords(&self, idx: usize) -> (u32, u32) {
        let x = (idx as u32) % self.width;
        let y = (idx as u32) / self.width;
        (x, y)
    }
    
    // === Bounds checking ===
    #[inline]
    pub fn in_bounds(&self, x: i32, y: i32) -> bool {
        x >= 0 && x < self.width as i32 && y >= 0 && y < self.height as i32
    }
    
    #[inline]
    pub fn is_empty(&self, x: i32, y: i32) -> bool {
        if !self.in_bounds(x, y) { return false; }
        self.types[self.index(x as u32, y as u32)] == EL_EMPTY
    }
    
    #[inline]
    pub fn is_empty_idx(&self, idx: usize) -> bool {
        self.types[idx] == EL_EMPTY
    }
    
    // === Type access ===
    #[inline]
    pub fn get_type(&self, x: i32, y: i32) -> ElementId {
        if !self.in_bounds(x, y) { return EL_EMPTY; }
        self.types[self.index(x as u32, y as u32)]
    }
    
    #[inline]
    pub fn get_type_idx(&self, idx: usize) -> ElementId {
        self.types[idx]
    }
    
    #[inline]
    pub fn set_type(&mut self, x: u32, y: u32, t: ElementId) {
        let idx = self.index(x, y);
        self.types[idx] = t;
    }
    
    // === Color access ===
    #[inline]
    pub fn get_color(&self, x: u32, y: u32) -> u32 {
        self.colors[self.index(x, y)]
    }
    
    #[inline]
    pub fn set_color(&mut self, x: u32, y: u32, c: u32) {
        let idx = self.index(x, y);
        self.colors[idx] = c;
    }
    
    // === Life access ===
    #[inline]
    pub fn get_life(&self, x: u32, y: u32) -> u16 {
        self.life[self.index(x, y)]
    }
    
    #[inline]
    pub fn set_life(&mut self, x: u32, y: u32, l: u16) {
        let idx = self.index(x, y);
        self.life[idx] = l;
    }
    
    // === Updated flag ===
    #[inline]
    pub fn is_updated(&self, x: u32, y: u32) -> bool {
        self.updated[self.index(x, y)] == 1
    }
    
    #[inline]
    pub fn is_updated_idx(&self, idx: usize) -> bool {
        self.updated[idx] == 1
    }
    
    #[inline]
    pub fn set_updated(&mut self, x: u32, y: u32, u: bool) {
        let idx = self.index(x, y);
        self.updated[idx] = if u { 1 } else { 0 };
    }
    
    #[inline]
    pub fn reset_updated(&mut self) {
        self.updated.fill(0);
    }
    
    // === Temperature access ===
    #[inline]
    pub fn get_temp(&self, x: i32, y: i32) -> f32 {
        if !self.in_bounds(x, y) { return 20.0; }
        self.temperature[self.index(x as u32, y as u32)]
    }
    
    #[inline]
    pub fn set_temp(&mut self, x: u32, y: u32, t: f32) {
        let idx = self.index(x, y);
        self.temperature[idx] = t;
    }
    
    // === Swap two cells (all data) ===
    // Phase 4: Records the move for chunk tracking
    pub fn swap(&mut self, x1: u32, y1: u32, x2: u32, y2: u32) {
        let idx1 = self.index(x1, y1);
        let idx2 = self.index(x2, y2);
        
        // Record move if there's a particle moving (idx1 has particle, going to idx2)
        // This tracks where particles go for chunk system
        if self.types[idx1] != EL_EMPTY {
            self.pending_moves.push((x1, y1, x2, y2));
        }
        
        self.swap_idx(idx1, idx2);
    }
    
    #[inline]
    pub fn swap_idx(&mut self, idx1: usize, idx2: usize) {
        self.types.swap(idx1, idx2);
        self.colors.swap(idx1, idx2);
        self.life.swap(idx1, idx2);
        self.updated.swap(idx1, idx2);
        self.temperature.swap(idx1, idx2);
    }
    
    // === Phase 4: Move tracking for chunks (Zero-Allocation) ===
    
    /// Clear pending moves (call at frame start)
    /// Memory stays allocated - just resets counter
    pub fn clear_moves(&mut self) {
        self.pending_moves.clear();
    }
    
    // === Set particle with all data ===
    // Match TypeScript: new particles are NOT updated, so they can move this frame
    pub fn set_particle(&mut self, x: u32, y: u32, element: ElementId, color: u32, life: u16, temp: f32) {
        let idx = self.index(x, y);
        self.types[idx] = element;
        self.colors[idx] = color;
        self.life[idx] = life;
        self.updated[idx] = 0;  // NOT updated - can move this frame!
        self.temperature[idx] = temp;
    }
    
    // === Clear single cell ===
    pub fn clear_cell(&mut self, x: u32, y: u32) {
        let idx = self.index(x, y);
        self.types[idx] = EL_EMPTY;
        self.colors[idx] = BG_COLOR;
        self.life[idx] = 0;
        self.temperature[idx] = 20.0;
    }
    
    // === Clear entire grid ===
    pub fn clear(&mut self) {
        self.types.fill(EL_EMPTY);
        self.colors.fill(BG_COLOR);
        self.life.fill(0);
        self.updated.fill(0);
        self.temperature.fill(20.0);
    }
    
    // === Get raw pointers for JS interop ===
    pub fn types_ptr(&self) -> *const ElementId {
        self.types.as_ptr()
    }
    
    pub fn colors_ptr(&self) -> *const u32 {
        self.colors.as_ptr()
    }
    
    pub fn temperature_ptr(&self) -> *const f32 {
        self.temperature.as_ptr()
    }
    
    // === PHASE 1: UNSAFE ACCESS (ZERO OVERHEAD) ===
    // These methods skip bounds checks for maximum performance.
    // ONLY use when coordinates are mathematically guaranteed valid!
    
    /// Get index without bounds check
    #[inline(always)]
    pub fn index_unchecked(&self, x: u32, y: u32) -> usize {
        (y * self.width + x) as usize
    }
    
    /// Fast type read - UNSAFE: caller must ensure x,y are valid
    #[inline(always)]
    pub unsafe fn get_type_unchecked(&self, x: u32, y: u32) -> ElementId {
        let idx = self.index_unchecked(x, y);
        *self.types.get_unchecked(idx)
    }
    
    /// Fast updated check - UNSAFE: caller must ensure idx is valid  
    #[inline(always)]
    pub unsafe fn is_updated_unchecked(&self, idx: usize) -> bool {
        *self.updated.get_unchecked(idx) == 1
    }
    
    /// Fast set updated - UNSAFE: caller must ensure idx is valid
    #[inline(always)]
    pub unsafe fn set_updated_unchecked(&mut self, idx: usize, u: bool) {
        *self.updated.get_unchecked_mut(idx) = if u { 1 } else { 0 };
    }
    
    /// Fast life read - UNSAFE: caller must ensure idx is valid
    #[inline(always)]
    pub unsafe fn get_life_unchecked(&self, idx: usize) -> u16 {
        *self.life.get_unchecked(idx)
    }
    
    /// Fast life write - UNSAFE: caller must ensure idx is valid
    #[inline(always)]
    pub unsafe fn set_life_unchecked(&mut self, idx: usize, l: u16) {
        *self.life.get_unchecked_mut(idx) = l;
    }
    
    /// Fast particle write - UNSAFE: caller must ensure x,y are valid
    #[inline(always)]
    pub unsafe fn set_particle_unchecked(&mut self, x: u32, y: u32, element: ElementId, color: u32, life: u16, temp: f32) {
        let idx = self.index_unchecked(x, y);
        *self.types.get_unchecked_mut(idx) = element;
        *self.colors.get_unchecked_mut(idx) = color;
        *self.life.get_unchecked_mut(idx) = life;
        *self.updated.get_unchecked_mut(idx) = 0;
        *self.temperature.get_unchecked_mut(idx) = temp;
    }
    
    /// Fast swap using raw pointers - UNSAFE: caller must ensure both coords are valid
    /// This is the hottest path in the simulation!
    #[inline(always)]
    pub unsafe fn swap_unchecked(&mut self, x1: u32, y1: u32, x2: u32, y2: u32) {
        let idx1 = self.index_unchecked(x1, y1);
        let idx2 = self.index_unchecked(x2, y2);
        
        // Record move for chunk tracking (only if particle is moving)
        if *self.types.get_unchecked(idx1) != EL_EMPTY {
            self.pending_moves.push((x1, y1, x2, y2));
        }
        
        // Raw pointer swap - no bounds checks!
        let ptr_types = self.types.as_mut_ptr();
        let ptr_colors = self.colors.as_mut_ptr();
        let ptr_life = self.life.as_mut_ptr();
        let ptr_updated = self.updated.as_mut_ptr();
        let ptr_temp = self.temperature.as_mut_ptr();
        
        std::ptr::swap(ptr_types.add(idx1), ptr_types.add(idx2));
        std::ptr::swap(ptr_colors.add(idx1), ptr_colors.add(idx2));
        std::ptr::swap(ptr_life.add(idx1), ptr_life.add(idx2));
        std::ptr::swap(ptr_updated.add(idx1), ptr_updated.add(idx2));
        std::ptr::swap(ptr_temp.add(idx1), ptr_temp.add(idx2));
    }
    
    /// Fast clear cell - UNSAFE: caller must ensure x,y are valid
    #[inline(always)]
    pub unsafe fn clear_cell_unchecked(&mut self, x: u32, y: u32) {
        let idx = self.index_unchecked(x, y);
        *self.types.get_unchecked_mut(idx) = EL_EMPTY;
        *self.colors.get_unchecked_mut(idx) = BG_COLOR;
        *self.life.get_unchecked_mut(idx) = 0;
        *self.temperature.get_unchecked_mut(idx) = 20.0;
    }
    
    // === Lazy Hydration: Chunk temperature methods ===
    
    /// Hydrate chunk - fill air cells with virtual temperature
    /// Called when chunk wakes up from sleep
    pub fn hydrate_chunk(&mut self, cx: u32, cy: u32, temp: f32) {
        let start_x = cx * CHUNK_SIZE;
        let start_y = cy * CHUNK_SIZE;
        let end_x = (start_x + CHUNK_SIZE).min(self.width);
        let end_y = (start_y + CHUNK_SIZE).min(self.height);
        
        // Use raw pointers for speed (chunk bounds are guaranteed valid)
        let types_ptr = self.types.as_ptr();
        let temps_ptr = self.temperature.as_mut_ptr();
        let width = self.width as usize;
        
        unsafe {
            for y in start_y..end_y {
                let row_offset = (y as usize) * width;
                for x in start_x..end_x {
                    let idx = row_offset + (x as usize);
                    // Only update temperature if cell is empty (air)
                    // Particles keep their own temperature!
                    if *types_ptr.add(idx) == EL_EMPTY {
                        *temps_ptr.add(idx) = temp;
                    }
                }
            }
        }
    }
    
    /// Get average air temperature in chunk (for sync when going to sleep)
    pub fn get_average_air_temp(&self, cx: u32, cy: u32) -> f32 {
        let start_x = cx * CHUNK_SIZE;
        let start_y = cy * CHUNK_SIZE;
        let end_x = (start_x + CHUNK_SIZE).min(self.width);
        let end_y = (start_y + CHUNK_SIZE).min(self.height);
        
        let types_ptr = self.types.as_ptr();
        let temps_ptr = self.temperature.as_ptr();
        let width = self.width as usize;
        
        let mut sum = 0.0f32;
        let mut count = 0u32;
        
        unsafe {
            for y in start_y..end_y {
                let row_offset = (y as usize) * width;
                for x in start_x..end_x {
                    let idx = row_offset + (x as usize);
                    if *types_ptr.add(idx) == EL_EMPTY {
                        sum += *temps_ptr.add(idx);
                        count += 1;
                    }
                }
            }
        }
        
        if count > 0 {
            sum / (count as f32)
        } else {
            // No air in chunk (fully occupied) - return room temp
            20.0
        }
    }
}

--- End of File: packages/engine/src/grid.rs ---


--- File: packages/engine/src/lib.rs ---

//! Particula Engine - High-performance particle simulation in WASM
//! 
//! Phase 4: Spatial Optimization with Chunks
//! 
//! Architecture (SOLID):
//! - elements.rs    - Element definitions and properties
//! - grid.rs        - SoA data storage
//! - chunks.rs      - Spatial optimization (32x32 chunks)
//! - behaviors/     - Particle physics (one file per category)
//! - reactions.rs   - Chemical reactions
//! - temperature.rs - Thermodynamics and phase changes
//! - world.rs       - Orchestration only

mod elements;
mod grid;
mod chunks;
mod behaviors;
mod reactions;
mod temperature;
mod world;

use wasm_bindgen::prelude::*;

// Better error messages in debug mode
#[cfg(feature = "console_error_panic_hook")]
pub fn set_panic_hook() {
    console_error_panic_hook::set_once();
}

/// Initialize the engine
#[wasm_bindgen]
pub fn init() {
    #[cfg(feature = "console_error_panic_hook")]
    set_panic_hook();
    
    web_sys::console::log_1(&"ðŸ¦€ Particula WASM Engine initialized!".into());
}

/// Get engine version
#[wasm_bindgen]
pub fn version() -> String {
    env!("CARGO_PKG_VERSION").to_string()
}

// Re-export main types
pub use world::World;
pub use elements::ElementType;

// Export element constants for JS
#[wasm_bindgen]
pub fn el_empty() -> u8 { elements::EL_EMPTY }
#[wasm_bindgen]
pub fn el_stone() -> u8 { elements::EL_STONE }
#[wasm_bindgen]
pub fn el_sand() -> u8 { elements::EL_SAND }
#[wasm_bindgen]
pub fn el_wood() -> u8 { elements::EL_WOOD }
#[wasm_bindgen]
pub fn el_metal() -> u8 { elements::EL_METAL }
#[wasm_bindgen]
pub fn el_ice() -> u8 { elements::EL_ICE }
#[wasm_bindgen]
pub fn el_water() -> u8 { elements::EL_WATER }
#[wasm_bindgen]
pub fn el_oil() -> u8 { elements::EL_OIL }
#[wasm_bindgen]
pub fn el_lava() -> u8 { elements::EL_LAVA }
#[wasm_bindgen]
pub fn el_acid() -> u8 { elements::EL_ACID }
#[wasm_bindgen]
pub fn el_steam() -> u8 { elements::EL_STEAM }
#[wasm_bindgen]
pub fn el_smoke() -> u8 { elements::EL_SMOKE }
#[wasm_bindgen]
pub fn el_fire() -> u8 { elements::EL_FIRE }
#[wasm_bindgen]
pub fn el_spark() -> u8 { elements::EL_SPARK }
#[wasm_bindgen]
pub fn el_electricity() -> u8 { elements::EL_ELECTRICITY }
#[wasm_bindgen]
pub fn el_gunpowder() -> u8 { elements::EL_GUNPOWDER }
#[wasm_bindgen]
pub fn el_clone() -> u8 { elements::EL_CLONE }
#[wasm_bindgen]
pub fn el_void() -> u8 { elements::EL_VOID }
#[wasm_bindgen]
pub fn el_dirt() -> u8 { elements::EL_DIRT }
#[wasm_bindgen]
pub fn el_seed() -> u8 { elements::EL_SEED }
#[wasm_bindgen]
pub fn el_plant() -> u8 { elements::EL_PLANT }

--- End of File: packages/engine/src/lib.rs ---


--- File: packages/engine/src/reactions.rs ---

//! Chemical Reactions - Data-Driven Bilateral Reaction System
//! 
//! Port from: apps/web/src/lib/engine/reactions.ts
//! EXACT 1:1 port of the TypeScript reaction rules
//! 
//! Philosophy:
//! - Rules are data, not code (OCP: Open for extension, Closed for modification)
//! - BILATERAL: Both aggressor AND victim can transform
//! - Solves "infinite lava" problem (conservation of energy)
//! - Simple lookup: Aggressor -> Victim -> Result

use crate::elements::ElementId;
use crate::elements::{
    EL_EMPTY, EL_STONE, EL_WOOD, EL_METAL, EL_ICE,
    EL_WATER, EL_OIL, EL_LAVA, EL_ACID,
    EL_STEAM, EL_SMOKE, EL_FIRE,
    EL_GUNPOWDER, EL_DIRT, EL_SEED, EL_PLANT
};

/// Reaction result
#[derive(Clone, Copy)]
pub struct Reaction {
    /// What victim becomes (EL_EMPTY = destroyed, same = unchanged)
    pub target_becomes: ElementId,
    /// What aggressor becomes (255 = unchanged, EL_EMPTY = destroyed)
    pub source_becomes: u8,  // 255 = no change
    /// Probability 0-100 (100 = 100%)
    pub chance: u8,
    /// Spawn byproduct (EL_EMPTY = none)
    pub spawn: ElementId,
}

impl Reaction {
    /// No change marker for source
    pub const NO_CHANGE: u8 = 255;
}

/// Get reaction between aggressor and victim
/// Uses match instead of 2D array for simpler initialization
pub fn get_reaction(aggressor: ElementId, victim: ElementId) -> Option<&'static Reaction> {
    // FIRE reactions
    static FIRE_WOOD: Reaction = Reaction { target_becomes: EL_FIRE, source_becomes: EL_SMOKE, chance: 10, spawn: EL_SMOKE };
    static FIRE_OIL: Reaction = Reaction { target_becomes: EL_FIRE, source_becomes: EL_SMOKE, chance: 20, spawn: EL_SMOKE };
    static FIRE_WATER: Reaction = Reaction { target_becomes: EL_STEAM, source_becomes: EL_EMPTY, chance: 50, spawn: EL_EMPTY };
    static FIRE_ICE: Reaction = Reaction { target_becomes: EL_WATER, source_becomes: EL_EMPTY, chance: 30, spawn: EL_STEAM };
    static FIRE_GUNPOWDER: Reaction = Reaction { target_becomes: EL_FIRE, source_becomes: EL_FIRE, chance: 100, spawn: EL_SMOKE };
    static FIRE_PLANT: Reaction = Reaction { target_becomes: EL_FIRE, source_becomes: EL_SMOKE, chance: 10, spawn: EL_SMOKE };
    static FIRE_SEED: Reaction = Reaction { target_becomes: EL_FIRE, source_becomes: EL_SMOKE, chance: 20, spawn: EL_EMPTY };
    
    // LAVA reactions
    static LAVA_WATER: Reaction = Reaction { target_becomes: EL_STEAM, source_becomes: EL_STONE, chance: 15, spawn: EL_STEAM };
    static LAVA_WOOD: Reaction = Reaction { target_becomes: EL_FIRE, source_becomes: Reaction::NO_CHANGE, chance: 30, spawn: EL_SMOKE };
    static LAVA_OIL: Reaction = Reaction { target_becomes: EL_FIRE, source_becomes: Reaction::NO_CHANGE, chance: 40, spawn: EL_SMOKE };
    static LAVA_ICE: Reaction = Reaction { target_becomes: EL_STEAM, source_becomes: EL_STONE, chance: 30, spawn: EL_EMPTY };
    static LAVA_GUNPOWDER: Reaction = Reaction { target_becomes: EL_FIRE, source_becomes: Reaction::NO_CHANGE, chance: 100, spawn: EL_SMOKE };
    static LAVA_PLANT: Reaction = Reaction { target_becomes: EL_FIRE, source_becomes: Reaction::NO_CHANGE, chance: 50, spawn: EL_SMOKE };
    static LAVA_DIRT: Reaction = Reaction { target_becomes: EL_STONE, source_becomes: Reaction::NO_CHANGE, chance: 5, spawn: EL_EMPTY };
    
    // ACID reactions
    static ACID_STONE: Reaction = Reaction { target_becomes: EL_EMPTY, source_becomes: EL_EMPTY, chance: 10, spawn: EL_SMOKE };
    static ACID_METAL: Reaction = Reaction { target_becomes: EL_EMPTY, source_becomes: EL_EMPTY, chance: 5, spawn: EL_EMPTY };
    static ACID_WOOD: Reaction = Reaction { target_becomes: EL_EMPTY, source_becomes: EL_EMPTY, chance: 20, spawn: EL_EMPTY };
    static ACID_ICE: Reaction = Reaction { target_becomes: EL_WATER, source_becomes: EL_EMPTY, chance: 20, spawn: EL_EMPTY };
    static ACID_PLANT: Reaction = Reaction { target_becomes: EL_EMPTY, source_becomes: EL_EMPTY, chance: 15, spawn: EL_EMPTY };
    static ACID_DIRT: Reaction = Reaction { target_becomes: EL_EMPTY, source_becomes: EL_EMPTY, chance: 5, spawn: EL_EMPTY };
    
    // WATER reactions (reverse)
    static WATER_LAVA: Reaction = Reaction { target_becomes: EL_STONE, source_becomes: EL_STEAM, chance: 15, spawn: EL_STEAM };
    static WATER_FIRE: Reaction = Reaction { target_becomes: EL_EMPTY, source_becomes: EL_STEAM, chance: 30, spawn: EL_EMPTY };
    
    match (aggressor, victim) {
        // Fire
        (EL_FIRE, EL_WOOD) => Some(&FIRE_WOOD),
        (EL_FIRE, EL_OIL) => Some(&FIRE_OIL),
        (EL_FIRE, EL_WATER) => Some(&FIRE_WATER),
        (EL_FIRE, EL_ICE) => Some(&FIRE_ICE),
        (EL_FIRE, EL_GUNPOWDER) => Some(&FIRE_GUNPOWDER),
        (EL_FIRE, EL_PLANT) => Some(&FIRE_PLANT),
        (EL_FIRE, EL_SEED) => Some(&FIRE_SEED),
        
        // Lava
        (EL_LAVA, EL_WATER) => Some(&LAVA_WATER),
        (EL_LAVA, EL_WOOD) => Some(&LAVA_WOOD),
        (EL_LAVA, EL_OIL) => Some(&LAVA_OIL),
        (EL_LAVA, EL_ICE) => Some(&LAVA_ICE),
        (EL_LAVA, EL_GUNPOWDER) => Some(&LAVA_GUNPOWDER),
        (EL_LAVA, EL_PLANT) => Some(&LAVA_PLANT),
        (EL_LAVA, EL_DIRT) => Some(&LAVA_DIRT),
        
        // Acid
        (EL_ACID, EL_STONE) => Some(&ACID_STONE),
        (EL_ACID, EL_METAL) => Some(&ACID_METAL),
        (EL_ACID, EL_WOOD) => Some(&ACID_WOOD),
        (EL_ACID, EL_ICE) => Some(&ACID_ICE),
        (EL_ACID, EL_PLANT) => Some(&ACID_PLANT),
        (EL_ACID, EL_DIRT) => Some(&ACID_DIRT),
        
        // Water (reverse reactions)
        (EL_WATER, EL_LAVA) => Some(&WATER_LAVA),
        (EL_WATER, EL_FIRE) => Some(&WATER_FIRE),
        
        _ => None
    }
}

--- End of File: packages/engine/src/reactions.rs ---


--- File: packages/engine/src/temperature.rs ---

//! Temperature System - Thermodynamics and Phase Changes
//! 
//! Port from: apps/web/src/lib/engine/core/Simulation.ts
//! EXACT 1:1 port of the TypeScript temperature algorithms
//! 
//! - Heat transfer using Newton's law of cooling (simplified)
//! - Stochastic: only check ONE random neighbor for performance
//! - Phase changes (melting, freezing, boiling, condensing)

use crate::grid::Grid;
use crate::elements::{
    ELEMENT_DATA, ElementId, EL_EMPTY, EL_STONE, EL_SAND, EL_METAL, EL_ICE, EL_WATER, EL_STEAM, EL_LAVA,
    ELEMENT_COUNT, get_color_with_variation
};

/// Phase change definitions: (element, high_temp, high_to, low_temp, low_to)
/// EXACT match to TypeScript apps/web/src/lib/engine/elements.ts
const PHASE_CHANGES: [(ElementId, Option<(f32, ElementId)>, Option<(f32, ElementId)>); 7] = [
    // Stone: melts at 900Â°C -> Lava
    (EL_STONE, Some((900.0, EL_LAVA)), None),
    // Sand: melts at 1700Â°C -> Lava (glass)
    (EL_SAND, Some((1700.0, EL_LAVA)), None),
    // Metal: melts at 1500Â°C -> Lava
    (EL_METAL, Some((1500.0, EL_LAVA)), None),
    // Ice: melts at 0Â°C -> Water
    (EL_ICE, Some((0.0, EL_WATER)), None),
    // Water: boils at 100Â°C -> Steam, freezes at 0Â°C -> Ice
    (EL_WATER, Some((100.0, EL_STEAM)), Some((0.0, EL_ICE))),
    // Lava: solidifies at 700Â°C -> Stone
    (EL_LAVA, None, Some((700.0, EL_STONE))),
    // Steam: condenses at 90Â°C -> Water (EXACT TypeScript value!)
    (EL_STEAM, None, Some((90.0, EL_WATER))),
];

/// Get phase change for element at given temperature
/// Returns new element if phase change occurs, None otherwise
pub fn check_phase_change(element: ElementId, temp: f32) -> Option<ElementId> {
    for (el, high, low) in PHASE_CHANGES.iter() {
        if *el == element {
            // Check high temp (melting/boiling)
            if let Some((threshold, new_el)) = high {
                if temp > *threshold {
                    return Some(*new_el);
                }
            }
            // Check low temp (freezing/condensing)
            if let Some((threshold, new_el)) = low {
                if temp < *threshold {
                    return Some(*new_el);
                }
            }
            return None;
        }
    }
    None
}

/// Process temperature for entire grid
/// Mirrors TypeScript processTemperatureGrid exactly
pub fn process_temperature_grid(grid: &mut Grid, ambient_temp: f32, frame: u64, rng: &mut u32) {
    let h = grid.height();
    let w = grid.width();
    
    for y in 0..h {
        for x in 0..w {
            update_temperature(grid, x, y, ambient_temp, frame, rng);
        }
    }
}

/// Heat transfer using Newton's law of cooling (simplified)
/// Stochastic: only check ONE random neighbor for performance
/// EXACT port of TypeScript updateTemperature
fn update_temperature(grid: &mut Grid, x: u32, y: u32, ambient_temp: f32, frame: u64, rng: &mut u32) {
    let xi = x as i32;
    let yi = y as i32;
    
    let my_temp = grid.get_temp(xi, yi);
    let element = grid.get_type(xi, yi);
    
    // Empty cells (air) tend towards ambient temperature
    if element == EL_EMPTY {
        let diff = ambient_temp - my_temp;
        
        if diff.abs() > 0.5 {
            grid.set_temp(x, y, my_temp + diff * 0.02);
        }
    }
    
    // Get conductivity (air = 5 if empty)
    let conductivity = if element != EL_EMPTY && (element as usize) < ELEMENT_COUNT {
        ELEMENT_DATA[element as usize].heat_conductivity
    } else {
        5
    };
    
    // Skip if insulator (conductivity 0)
    if conductivity == 0 { return; }
    
    // Pick random neighbor direction (EXACT TypeScript: Math.floor(Math.random() * 4))
    let dir = xorshift32(rng) % 4;
    let (nx, ny) = match dir {
        0 => (xi, yi - 1),     // Up
        1 => (xi, yi + 1),     // Down
        2 => (xi - 1, yi),     // Left
        _ => (xi + 1, yi),     // Right
    };
    
    // Boundary: heat sink to ambient temperature
    if !grid.in_bounds(nx, ny) {
        let diff = ambient_temp - my_temp;
        // Slow heat loss at edges
        grid.set_temp(x, y, my_temp + diff * 0.02);
        return;
    }
    
    // Heat transfer with neighbor
    let neighbor_temp = grid.get_temp(nx, ny);
    let diff = neighbor_temp - my_temp;
    
    // Optimization: skip if temperature difference is negligible
    if diff.abs() < 0.5 { return; }
    
    // Transfer rate based on conductivity (0-100 â†’ 0.0-0.5)
    let transfer_rate = (conductivity as f32 / 100.0) * 0.5;
    
    // Exchange heat (conservation of energy)
    let new_temp = my_temp + diff * transfer_rate;
    grid.set_temp(x, y, new_temp);
    grid.set_temp(nx as u32, ny as u32, neighbor_temp - diff * transfer_rate);
    
    // Check phase changes for particles
    if element != EL_EMPTY {
        if let Some(new_element) = check_phase_change(element, new_temp) {
            transform_particle(grid, x, y, new_element, new_temp, frame);
        }
    }
}

/// Transform particle to new element, preserving temperature
/// Mirrors TypeScript transformParticle exactly
fn transform_particle(grid: &mut Grid, x: u32, y: u32, new_element: ElementId, temp: f32, frame: u64) {
    let seed = ((x * 7 + y * 13 + frame as u32) & 31) as u8;
    let props = &ELEMENT_DATA[new_element as usize];
    
    grid.set_particle(
        x, y,
        new_element,
        get_color_with_variation(new_element, seed),
        props.lifetime,
        temp  // Keep temperature! Hot stone from lava stays hot
    );
    
    // Mark as updated so it doesn't process again this frame
    grid.set_updated(x, y, true);
}

/// Xorshift32 random number generator
#[inline]
fn xorshift32(state: &mut u32) -> u32 {
    let mut x = *state;
    x ^= x << 13;
    x ^= x >> 17;
    x ^= x << 5;
    *state = x;
    x
}

use crate::chunks::{ChunkGrid, CHUNK_SIZE};

/// Lazy Hydration: Process temperature with chunk-aware optimization
/// 
/// - Sleeping chunks: Only update virtual_temp (O(1) per chunk)
/// - Active chunks: Process pixels + sync virtual_temp back
/// 
/// This reduces O(W*H) to O(active_pixels + all_chunks)
pub fn process_temperature_grid_chunked(
    grid: &mut Grid,
    chunks: &mut ChunkGrid,  // Now mutable for virtual_temp updates!
    ambient_temp: f32,
    frame: u64,
    rng: &mut u32
) {
    let (cx_count, cy_count) = chunks.dimensions();
    
    // Air conductivity speed (same as in update_temperature: 0.02)
    const AIR_LERP_SPEED: f32 = 0.02;
    
    for cy in 0..cy_count {
        for cx in 0..cx_count {
            if chunks.is_sleeping(cx, cy) {
                // === PATH 1: CHUNK IS SLEEPING (Fast O(1)) ===
                // Just smoothly animate virtual_temp towards ambient
                // This is the SAME math as update_temperature for air, but for ONE number
                chunks.update_virtual_temp(cx, cy, ambient_temp, AIR_LERP_SPEED);
            } else {
                // === PATH 2: CHUNK IS ACTIVE (Slow, pixel-by-pixel) ===
                // Process all pixels in this chunk
                let start_x = cx * CHUNK_SIZE;
                let start_y = cy * CHUNK_SIZE;
                let end_x = (start_x + CHUNK_SIZE).min(grid.width());
                let end_y = (start_y + CHUNK_SIZE).min(grid.height());
                
                for y in start_y..end_y {
                    for x in start_x..end_x {
                        update_temperature(grid, x, y, ambient_temp, frame, rng);
                    }
                }
                
                // Sync virtual_temp with actual air temperature in chunk
                // (so when chunk goes to sleep, it continues from correct value)
                // Do this every 4th frame to save CPU
                if frame % 4 == 0 {
                    let avg = grid.get_average_air_temp(cx, cy);
                    chunks.set_virtual_temp(cx, cy, avg);
                }
            }
        }
    }
}

--- End of File: packages/engine/src/temperature.rs ---


--- File: packages/engine/src/world.rs ---

//! World - High-performance particle simulation
//! 
//! Phase 4: Chunk-based spatial optimization
//! 
//! Refactored for SOLID principles:
//! - Single Responsibility: World only orchestrates, delegates to behaviors/reactions/temperature
//! - Open/Closed: New behaviors can be added without modifying this file
//! 
//! All particle physics are in behaviors/ module
//! Chemical reactions are in reactions.rs
//! Temperature system is in temperature.rs
//! Chunk optimization in chunks.rs

use wasm_bindgen::prelude::*;
use crate::grid::Grid;
use crate::chunks::{ChunkGrid, CHUNK_SIZE};
use crate::elements::{
    ELEMENT_DATA, ElementId, EL_EMPTY, ELEMENT_COUNT,
    get_color_with_variation, get_props
};
use crate::behaviors::{BehaviorRegistry, UpdateContext};
use crate::reactions::{get_reaction, Reaction};
use crate::temperature::process_temperature_grid_chunked;

/// Random number generator (xorshift32)
#[inline]
fn xorshift32(state: &mut u32) -> u32 {
    let mut x = *state;
    x ^= x << 13;
    x ^= x >> 17;
    x ^= x << 5;
    *state = x;
    x
}

/// The simulation world
#[wasm_bindgen]
pub struct World {
    grid: Grid,
    chunks: ChunkGrid,
    behaviors: BehaviorRegistry,
    
    // Settings
    gravity_x: f32,
    gravity_y: f32,
    ambient_temperature: f32,
    
    // State
    particle_count: u32,
    frame: u64,
    rng_state: u32,
    
    // Phase 3: Smart Rendering buffers
    dirty_list: Vec<u32>,           // List of dirty chunk indices for rendering
    chunk_transfer_buffer: Vec<u32>, // 32x32 pixel buffer for chunk extraction
}

#[wasm_bindgen]
impl World {
    /// Create a new world with given dimensions
    #[wasm_bindgen(constructor)]
    pub fn new(width: u32, height: u32) -> Self {
        Self {
            grid: Grid::new(width, height),
            chunks: ChunkGrid::new(width, height),
            behaviors: BehaviorRegistry::new(),
            gravity_x: 0.0,
            gravity_y: 1.0,
            ambient_temperature: 20.0,
            particle_count: 0,
            frame: 0,
            rng_state: 12345,
            // Phase 3: Smart Rendering
            dirty_list: Vec::with_capacity(1000),
            chunk_transfer_buffer: vec![0u32; (CHUNK_SIZE * CHUNK_SIZE) as usize],
        }
    }

    #[wasm_bindgen(getter)]
    pub fn width(&self) -> u32 { self.grid.width() }

    #[wasm_bindgen(getter)]
    pub fn height(&self) -> u32 { self.grid.height() }

    #[wasm_bindgen(getter)]
    pub fn particle_count(&self) -> u32 { self.particle_count }

    #[wasm_bindgen(getter)]
    pub fn frame(&self) -> u64 { self.frame }

    pub fn set_gravity(&mut self, x: f32, y: f32) {
        // Match TypeScript: gx/gy = sign of gravity, can be 0
        self.gravity_x = if x > 0.0 { 1.0 } else if x < 0.0 { -1.0 } else { 0.0 };
        self.gravity_y = if y > 0.0 { 1.0 } else if y < 0.0 { -1.0 } else { 0.0 };
    }

    pub fn set_ambient_temperature(&mut self, temp: f32) {
        self.ambient_temperature = temp;
    }

    /// Add a particle at position
    pub fn add_particle(&mut self, x: u32, y: u32, element: u8) -> bool {
        if x >= self.grid.width() || y >= self.grid.height() {
            return false;
        }
        
        // Validate element ID
        if (element as usize) >= ELEMENT_COUNT || element == EL_EMPTY {
            return false;
        }
        
        if !self.grid.is_empty(x as i32, y as i32) {
            return false;
        }
        
        let seed = ((x * 7 + y * 13 + self.frame as u32) & 31) as u8;
        let props = get_props(element);
        
        self.grid.set_particle(
            x, y, 
            element, 
            get_color_with_variation(element, seed),
            props.lifetime,
            props.default_temp
        );
        
        // Phase 4: Track particle in chunk
        self.chunks.add_particle(x, y);
        
        self.particle_count += 1;
        true
    }

    /// Add particles in radius (brush)
    pub fn add_particles_in_radius(&mut self, cx: i32, cy: i32, radius: i32, element: u8) {
        let r2 = radius * radius;
        for dy in -radius..=radius {
            for dx in -radius..=radius {
                if dx * dx + dy * dy <= r2 {
                    let x = cx + dx;
                    let y = cy + dy;
                    if x >= 0 && y >= 0 {
                        self.add_particle(x as u32, y as u32, element);
                    }
                }
            }
        }
    }

    /// Remove particle at position
    pub fn remove_particle(&mut self, x: u32, y: u32) -> bool {
        if x >= self.grid.width() || y >= self.grid.height() {
            return false;
        }
        
        if self.grid.is_empty(x as i32, y as i32) {
            return false;
        }
        
        // Phase 4: Track removal in chunk
        self.chunks.remove_particle(x, y);
        
        self.grid.clear_cell(x, y);
        if self.particle_count > 0 {
            self.particle_count -= 1;
        }
        true
    }

    /// Remove particles in radius
    pub fn remove_particles_in_radius(&mut self, cx: i32, cy: i32, radius: i32) {
        let r2 = radius * radius;
        for dy in -radius..=radius {
            for dx in -radius..=radius {
                if dx * dx + dy * dy <= r2 {
                    let x = cx + dx;
                    let y = cy + dy;
                    if x >= 0 && y >= 0 {
                        self.remove_particle(x as u32, y as u32);
                    }
                }
            }
        }
    }

    /// Clear all particles
    pub fn clear(&mut self) {
        self.grid.clear();
        self.chunks.reset();
        self.particle_count = 0;
        self.frame = 0;
    }

    /// Step the simulation forward
    /// Phase 4: Only process active chunks!
    pub fn step(&mut self) {
        // === LAZY HYDRATION: Process waking chunks ===
        // When a chunk transitions Sleep -> Active, we need to fill its air cells
        // with the current virtual_temp (which has been smoothly animating)
        self.hydrate_waking_chunks();
        
        // Reset updated flags and clear move tracking
        self.grid.reset_updated();
        self.grid.clear_moves();
        
        // Phase 4: Begin frame for chunk tracking
        self.chunks.begin_frame();
        
        let go_right = (self.frame & 1) == 0;
        let (chunks_x, chunks_y) = self.chunks.dimensions();
        
        // Process chunks from bottom to top (for gravity)
        if self.gravity_y >= 0.0 {
            for cy in (0..chunks_y).rev() {
                self.process_chunk_row(cy, chunks_x, go_right);
            }
        } else {
            for cy in 0..chunks_y {
                self.process_chunk_row(cy, chunks_x, go_right);
            }
        }
        
        // Phase 4.1: Apply recorded moves to chunk system
        self.apply_pending_moves();
        
        // Temperature pass - run every other frame for performance
        // Lazy Hydration: now updates virtual_temp for sleeping chunks!
        if self.frame % 2 == 0 {
            process_temperature_grid_chunked(
                &mut self.grid,
                &mut self.chunks,  // Now mutable for virtual_temp updates
                self.ambient_temperature,
                self.frame,
                &mut self.rng_state
            );
        }
        
        self.frame += 1;
    }
    
    /// Lazy Hydration: Fill waking chunks with their virtual temperature
    /// This ensures particles entering a previously-sleeping chunk
    /// encounter the correct (smoothly animated) air temperature
    fn hydrate_waking_chunks(&mut self) {
        let (chunks_x, _) = self.chunks.dimensions();
        
        for (idx, &woke) in self.chunks.just_woke_up.iter().enumerate() {
            if woke {
                let cx = (idx as u32) % chunks_x;
                let cy = (idx as u32) / chunks_x;
                let v_temp = self.chunks.virtual_temp[idx];
                
                // Fill all air cells in this chunk with the virtual temperature
                self.grid.hydrate_chunk(cx, cy, v_temp);
            }
        }
        
        // Clear wake flags after processing
        self.chunks.clear_wake_flags();
    }
    
    /// Phase 4.1: Apply all recorded moves to chunk tracking
    /// Zero-allocation: uses raw pointer iteration instead of drain()
    fn apply_pending_moves(&mut self) {
        let count = self.grid.pending_moves.count;
        let moves_ptr = self.grid.pending_moves.as_ptr();
        
        // SAFETY: We iterate only over valid data (0..count)
        // ParticleMove is Copy, so we can read directly
        unsafe {
            for i in 0..count {
                let (from_x, from_y, to_x, to_y) = *moves_ptr.add(i);
                self.chunks.move_particle(from_x, from_y, to_x, to_y);
            }
        }
    }
    
    /// Get active chunk count (for debugging/stats)
    pub fn active_chunks(&self) -> usize {
        self.chunks.active_chunk_count()
    }
    
    /// Get total chunk count
    pub fn total_chunks(&self) -> usize {
        self.chunks.total_chunks()
    }

    /// Get pointer to types array (for JS rendering)
    pub fn types_ptr(&self) -> *const u8 {
        self.grid.types_ptr()
    }

    /// Get pointer to colors array (for JS rendering)
    pub fn colors_ptr(&self) -> *const u32 {
        self.grid.colors_ptr()
    }

    /// Get grid size for types
    pub fn types_len(&self) -> usize {
        self.grid.size()
    }

    /// Get grid size for colors
    pub fn colors_len(&self) -> usize {
        self.grid.size() * 4
    }
    
    /// Get pointer to temperature array (for JS thermal rendering)
    pub fn temperature_ptr(&self) -> *const f32 {
        self.grid.temperature_ptr()
    }
    
    /// Get temperature array length
    pub fn temperature_len(&self) -> usize {
        self.grid.size()
    }
    
    // === PHASE 3: SMART RENDERING API ===
    
    /// Collect list of dirty chunks that need rendering
    /// Uses visual_dirty (separate from physics dirty) to avoid state desync!
    /// Returns the count of dirty chunks
    pub fn collect_dirty_chunks(&mut self) -> usize {
        self.dirty_list.clear();
        let total = self.chunks.total_chunks();
        
        for i in 0..total {
            // Check VISUAL dirty, not physics dirty!
            if self.chunks.visual_dirty[i] {
                self.dirty_list.push(i as u32);
                
                // Clear flag immediately - we're sending this to JS
                self.chunks.clear_visual_dirty(i);
            }
        }
        
        self.dirty_list.len()
    }
    
    /// Get pointer to dirty chunk list
    pub fn get_dirty_list_ptr(&self) -> *const u32 {
        self.dirty_list.as_ptr()
    }
    
    /// Extract pixels from a chunk into transfer buffer (strided -> linear)
    /// Returns pointer to the transfer buffer
    pub fn extract_chunk_pixels(&mut self, chunk_idx: u32) -> *const u32 {
        let (cx_count, _) = self.chunks.dimensions();
        let cx = chunk_idx % cx_count;
        let cy = chunk_idx / cx_count;
        
        let start_x = cx * CHUNK_SIZE;
        let start_y = cy * CHUNK_SIZE;
        let end_x = (start_x + CHUNK_SIZE).min(self.grid.width());
        let end_y = (start_y + CHUNK_SIZE).min(self.grid.height());
        
        let grid_width = self.grid.width() as usize;
        let colors_ptr = self.grid.colors.as_ptr();
        let buffer_ptr = self.chunk_transfer_buffer.as_mut_ptr();
        
        let mut buf_idx = 0usize;
        
        unsafe {
            for y in start_y..end_y {
                let row_offset = (y as usize) * grid_width;
                let src_start = row_offset + (start_x as usize);
                let row_len = (end_x - start_x) as usize;
                
                // Fast memcpy for each row
                std::ptr::copy_nonoverlapping(
                    colors_ptr.add(src_start),
                    buffer_ptr.add(buf_idx),
                    row_len
                );
                
                // Move to next row in 32x32 buffer
                buf_idx += CHUNK_SIZE as usize;
            }
        }
        
        self.chunk_transfer_buffer.as_ptr()
    }
    
    /// Get chunk transfer buffer size (32*32 = 1024 pixels * 4 bytes = 4096 bytes)
    pub fn chunk_buffer_byte_size(&self) -> usize {
        (CHUNK_SIZE * CHUNK_SIZE * 4) as usize
    }
    
    /// Get chunks X count (for JS coordinate calculation)
    pub fn chunks_x(&self) -> u32 {
        self.chunks.dimensions().0
    }
    
    /// Get chunks Y count
    pub fn chunks_y(&self) -> u32 {
        self.chunks.dimensions().1
    }
}

// Private simulation methods
impl World {
    /// Process a row of chunks
    fn process_chunk_row(&mut self, cy: u32, chunks_x: u32, go_right: bool) {
        if go_right {
            for cx in 0..chunks_x {
                self.process_chunk(cx, cy, go_right);
            }
        } else {
            for cx in (0..chunks_x).rev() {
                self.process_chunk(cx, cy, go_right);
            }
        }
    }
    
    /// Process a single chunk
    fn process_chunk(&mut self, cx: u32, cy: u32, go_right: bool) {
        // Skip sleeping chunks with no activity
        if !self.chunks.should_process(cx, cy) {
            return;
        }
        
        // Calculate pixel bounds for this chunk
        let start_x = cx * CHUNK_SIZE;
        let start_y = cy * CHUNK_SIZE;
        let end_x = (start_x + CHUNK_SIZE).min(self.grid.width());
        let end_y = (start_y + CHUNK_SIZE).min(self.grid.height());
        
        let mut had_movement = false;
        
        // Process rows within chunk (bottom to top for gravity)
        if self.gravity_y >= 0.0 {
            for y in (start_y..end_y).rev() {
                if go_right {
                    for x in start_x..end_x {
                        if self.update_particle_chunked(x, y) {
                            had_movement = true;
                        }
                    }
                } else {
                    for x in (start_x..end_x).rev() {
                        if self.update_particle_chunked(x, y) {
                            had_movement = true;
                        }
                    }
                }
            }
        } else {
            for y in start_y..end_y {
                if go_right {
                    for x in start_x..end_x {
                        if self.update_particle_chunked(x, y) {
                            had_movement = true;
                        }
                    }
                } else {
                    for x in (start_x..end_x).rev() {
                        if self.update_particle_chunked(x, y) {
                            had_movement = true;
                        }
                    }
                }
            }
        }
        
        // Update chunk state
        self.chunks.end_chunk_update(cx, cy, had_movement);
    }
    
    /// Update particle and return true if it moved
    /// PHASE 1: Optimized with unsafe access - coordinates are guaranteed valid by process_chunk bounds
    fn update_particle_chunked(&mut self, x: u32, y: u32) -> bool {
        // SAFETY: x,y are bounded by process_chunk's min() calls
        unsafe {
            // Fast type read without bounds check
            let element = self.grid.get_type_unchecked(x, y);
            if element == EL_EMPTY { return false; }
            
            // Element ID bounds check (data could be corrupted)
            if (element as usize) >= ELEMENT_COUNT {
                self.grid.clear_cell_unchecked(x, y);
                return false;
            }
            
            let idx = self.grid.index_unchecked(x, y);
            
            // Fast updated check
            if self.grid.is_updated_unchecked(idx) { return false; }
            
            // Fast set updated
            self.grid.set_updated_unchecked(idx, true);
            
            // Handle lifetime with fast access
            let life = self.grid.get_life_unchecked(idx);
            if life > 0 {
                self.grid.set_life_unchecked(idx, life - 1);
                if life - 1 == 0 {
                    self.grid.clear_cell_unchecked(x, y);
                    self.chunks.remove_particle(x, y);
                    if self.particle_count > 0 {
                        self.particle_count -= 1;
                    }
                    return true; // Particle disappeared = activity
                }
            }
            
            // Get category and dispatch to behavior
            let category = ELEMENT_DATA[element as usize].category;
            
            // Remember position before update
            let old_type = element;
            
            // Create update context
            let mut ctx = UpdateContext {
                grid: &mut self.grid,
                x,
                y,
                frame: self.frame,
                gravity_x: self.gravity_x,
                gravity_y: self.gravity_y,
                ambient_temp: self.ambient_temperature,
                rng: &mut self.rng_state,
            };
            
            // Delegate to behavior registry
            self.behaviors.update(category, &mut ctx);
            
            // Check if particle moved (cell is now empty or different)
            let new_type = self.grid.get_type_unchecked(x, y);
            let moved = new_type != old_type || new_type == EL_EMPTY;
            
            if moved {
                // Wake neighbors if particle moved
                self.chunks.wake_neighbors(x, y);
            }
            
            // Process chemical reactions AFTER movement (EXACT TypeScript)
            let current_type = self.grid.get_type_unchecked(x, y);
            if current_type != EL_EMPTY {
                self.process_reactions(x, y, current_type);
            }
            
            moved
        }
    }
    
    // Legacy method for compatibility
    fn process_row(&mut self, y: u32, w: u32, go_right: bool) {
        if go_right {
            for x in 0..w {
                self.update_particle(x, y);
            }
        } else {
            for x in (0..w).rev() {
                self.update_particle(x, y);
            }
        }
    }

    fn update_particle(&mut self, x: u32, y: u32) {
        let xi = x as i32;
        let yi = y as i32;
        
        let element = self.grid.get_type(xi, yi);
        if element == EL_EMPTY { return; }
        
        // Bounds check for element ID
        if (element as usize) >= ELEMENT_COUNT {
            self.grid.clear_cell(x, y);
            return;
        }
        
        if self.grid.is_updated(x, y) { return; }
        
        self.grid.set_updated(x, y, true);
        
        // Handle lifetime
        let life = self.grid.get_life(x, y);
        if life > 0 {
            self.grid.set_life(x, y, life - 1);
            if life - 1 == 0 {
                self.grid.clear_cell(x, y);
                if self.particle_count > 0 {
                    self.particle_count -= 1;
                }
                return;
            }
        }
        
        // Get category and dispatch to behavior
        let category = ELEMENT_DATA[element as usize].category;
        
        // Create update context
        let mut ctx = UpdateContext {
            grid: &mut self.grid,
            x,
            y,
            frame: self.frame,
            gravity_x: self.gravity_x,
            gravity_y: self.gravity_y,
            ambient_temp: self.ambient_temperature,
            rng: &mut self.rng_state,
        };
        
        // Delegate to behavior registry
        self.behaviors.update(category, &mut ctx);
        
        // Process chemical reactions AFTER movement (EXACT TypeScript)
        let current_type = self.grid.get_type(x as i32, y as i32);
        if current_type != EL_EMPTY {
            self.process_reactions(x, y, current_type);
        }
    }
    
    /// Process chemical reactions (mirrors TypeScript processReactionsTyped)
    fn process_reactions(&mut self, x: u32, y: u32, element: ElementId) {
        // Pick a random neighbor
        let dir = xorshift32(&mut self.rng_state) % 4;
        let xi = x as i32;
        let yi = y as i32;
        
        let (nx, ny) = match dir {
            0 => (xi, yi - 1),     // Up
            1 => (xi, yi + 1),     // Down
            2 => (xi - 1, yi),     // Left
            _ => (xi + 1, yi),     // Right
        };
        
        if !self.grid.in_bounds(nx, ny) { return; }
        
        let neighbor_type = self.grid.get_type(nx, ny);
        if neighbor_type == EL_EMPTY { return; }
        
        // Check if there's a reaction
        if let Some(reaction) = get_reaction(element, neighbor_type) {
            // Roll the dice
            let roll = (xorshift32(&mut self.rng_state) % 100) as u8;
            if roll >= reaction.chance { return; }
            
            // Apply the reaction
            self.apply_reaction(x, y, nx as u32, ny as u32, reaction);
        }
    }
    
    /// Apply a bilateral reaction (mirrors TypeScript applyReaction)
    fn apply_reaction(&mut self, src_x: u32, src_y: u32, target_x: u32, target_y: u32, reaction: &Reaction) {
        // A. Transform the TARGET (victim)
        if reaction.target_becomes == EL_EMPTY {
            self.remove_particle(target_x, target_y);
        } else {
            self.replace_particle(target_x, target_y, reaction.target_becomes);
        }
        
        // B. Transform the SOURCE (aggressor) - BILATERAL!
        if reaction.source_becomes != Reaction::NO_CHANGE {
            if reaction.source_becomes == EL_EMPTY {
                self.remove_particle(src_x, src_y);
            } else {
                self.replace_particle(src_x, src_y, reaction.source_becomes);
            }
        }
        
        // C. Spawn byproduct (smoke, steam)
        if reaction.spawn != EL_EMPTY {
            let sxi = src_x as i32;
            let syi = src_y as i32;
            let txi = target_x as i32;
            let tyi = target_y as i32;
            
            // Try to spawn above the reaction site
            if self.grid.is_empty(sxi, syi - 1) {
                self.add_particle(src_x, (syi - 1) as u32, reaction.spawn);
            } else if self.grid.is_empty(txi, tyi - 1) {
                self.add_particle(target_x, (tyi - 1) as u32, reaction.spawn);
            }
        }
    }
    
    /// Replace a particle with a new element type
    /// PRESERVES temperature like TypeScript! Hot stone from lava stays hot
    fn replace_particle(&mut self, x: u32, y: u32, element: ElementId) {
        let seed = ((x * 7 + y * 13 + self.frame as u32) & 31) as u8;
        let props = &ELEMENT_DATA[element as usize];
        
        // Save current temperature BEFORE replacing
        let current_temp = self.grid.get_temp(x as i32, y as i32);
        
        self.grid.set_particle(
            x, y,
            element,
            get_color_with_variation(element, seed),
            props.lifetime,
            current_temp  // Keep temperature! (was: props.default_temp)
        );
        
        // Mark as updated
        self.grid.set_updated(x, y, true);
    }
}

--- End of File: packages/engine/src/world.rs ---
